<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="Thomas_Xu&#39;s Bolg">
    <meta name="keyword"  content="Thomas_Xu, BlockChain">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          深入可升级合约 - Thomas_Xu
        
    </title>

    <link rel="canonical" href="https://thomasxu-blockchain.github.io/Proxy/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="../css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="../css/dusign-light.css">

        
<link rel="stylesheet" href="../css/dusign-common-light.css">

        
<link rel="stylesheet" href="../css/font-awesome.css">

        
<link rel="stylesheet" href="../css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="../css/highlight.css">


    
<link rel="stylesheet" href="../css/widget.css">


    
<link rel="stylesheet" href="../css/rocket.css">


    
<link rel="stylesheet" href="../css/signature.css">


    
<link rel="stylesheet" href="../css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="../css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('Iron-Man-3.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#杂谈" title="杂谈">杂谈</a>
                            
                        </div>
                        <h1>深入可升级合约</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Thomas_Xu on
                            2022-12-27
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Thomas_Xu&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="深入可升级合约"><a href="#深入可升级合约" class="headerlink" title="深入可升级合约"></a>深入可升级合约</h1><hr>
<pre><code>author：Thomas_Xu
</code></pre><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>Solidity</code>合约部署在链上之后，代码是不可变的（immutable）。这样既有优点，也有缺点：</p>
<ul>
<li>优点：安全，用户知道会发生什么（大部分时候）。</li>
<li>坏处：就算合约中存在bug，也不能修改或升级，只能部署新合约。但是新合约的地址与旧的不一样，且合约的数据也需要花费大量gas进行迁移。</li>
</ul>
<p>有没有办法在合约部署后进行修改或升级呢？答案是有的，那就是<strong>代理模式</strong>。</p>
<p><img src="proxy1.png" alt=""></p>
<p>代理模式将合约数据和逻辑分开，分别保存在不同合约中。我们拿上图中简单的代理合约为例，数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。代理合约（Proxy）通过<code>delegatecall</code>，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。</p>
<p>代理模式主要有两个好处：</p>
<ol>
<li>可升级：当我们需要升级合约的逻辑时，只需要将代理合约指向新的逻辑合约。</li>
<li>省gas：如果多个合约复用一套逻辑，我们只需部署一个逻辑合约，然后再部署多个只保存数据的代理合约，指向逻辑合约。</li>
</ol>
<p>在代理模式中，代理合约就等同于数据库，作为一个存储数据的地方，更新系统时只需要更改逻辑合约即可。省去了升级中的数据迁移带来的巨大gas消耗。</p>
<p><img src="proxy_storage.png" alt=""></p>
<p>题外话：最近看到<code>MixBytes</code>团队一篇关于可升级合约存储解决方案的Blog，它是将传统数据库和区块链相结合的一种方式，采用了“协定数据库”的方案。</p>
<p><img src="proxy_Nosql.png" alt=""></p>
<p>利用智能合约开发了一个基于NoSQL的<a href="https://github.com/mixbytes/ethereum-cdf" target="_blank" rel="noopener">以太坊列式数据存储原型</a>。我觉得非常有意思。</p>
<p>原文连接：<a href="https://mixbytes.io/blog/storage-upgradable-ethereum-smart-contracts" target="_blank" rel="noopener">可升级以太坊智能合约的存储 (mixbytes.io)</a></p>
<h2 id="简单的可升级合约"><a href="#简单的可升级合约" class="headerlink" title="简单的可升级合约"></a>简单的可升级合约</h2><p>在理解了代理合约后，就很容易理解可升级合约。它就是一个可以更改逻辑合约的代理合约。</p>
<p><img src="upgrade.png" alt=""></p>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>下面我们实现一个简单的可升级合约，它包含<code>3</code>个合约：代理合约，旧的逻辑合约，和新的逻辑合约。</p>
<h4 id="代理合约"><a href="#代理合约" class="headerlink" title="代理合约"></a>代理合约</h4><p><code>roxy</code>合约不长，但是用到了内联汇编，因此比较难理解。它只有一个状态变量，一个构造函数，和一个回调函数。状态变量<code>implementation</code>，在构造函数中初始化，用于保存<code>Logic</code>合约地址。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的可升级合约，管理员可以通过升级函数更改逻辑合约地址，从而改变合约的逻辑。</span></span><br><span class="line">contract SimpleUpgrade &#123;</span><br><span class="line">    address public implementation; <span class="comment">// 逻辑合约地址</span></span><br><span class="line">    address public admin; <span class="comment">// admin地址</span></span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化admin和逻辑合约地址</span></span><br><span class="line">    <span class="keyword">constructor</span>(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback函数，将调用委托给逻辑合约</span></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        address _implementation = implementation;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="comment">// 将msg.data拷贝到内存里</span></span><br><span class="line">            <span class="comment">// calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度</span></span><br><span class="line">            calldatacopy(<span class="number">0</span>, <span class="number">0</span>, calldatasize())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用delegatecall调用implementation合约</span></span><br><span class="line">            <span class="comment">// delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位				置，output area mem长度</span></span><br><span class="line">            <span class="comment">// output area起始位置和长度位置，所以设为0</span></span><br><span class="line">            <span class="comment">// delegatecall成功返回1，失败返回0</span></span><br><span class="line">            <span class="keyword">let</span> result := delegatecall(gas(), _implementation, <span class="number">0</span>, calldatasize(), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将return data拷贝到内存</span></span><br><span class="line">            <span class="comment">// returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度</span></span><br><span class="line">            returndatacopy(<span class="number">0</span>, <span class="number">0</span>, returndatasize())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> result</span><br><span class="line">            <span class="comment">// 如果delegate call失败，revert</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> &#123;</span><br><span class="line">                revert(<span class="number">0</span>, returndatasize())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）</span></span><br><span class="line">            <span class="keyword">default</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>(<span class="number">0</span>, returndatasize())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Proxy</code>的回调函数将外部对本合约的调用委托给 <code>Logic</code> 合约。这个回调函数很别致，它利用内联汇编（inline assembly），让本来不能有返回值的回调函数有了<strong>返回值</strong>。其中用到的内联汇编操作码：</p>
<ul>
<li><code>calldatacopy(t, f, s)</code>：将calldata（输入数据）从位置<code>f</code>开始复制<code>s</code>字节到mem（内存）的位置<code>t</code>。</li>
<li><code>delegatecall(g, a, in, insize, out, outsize)</code>：调用地址<code>a</code>的合约，输入为<code>mem[in..(in+insize))</code> ，输出为<code>mem[out..(out+outsize))</code>， 提供<code>g</code>wei的以太坊gas。这个操作码在错误时返回<code>0</code>，在成功时返回<code>1</code>。</li>
<li><code>returndatacopy(t, f, s)</code>：将returndata（输出数据）从位置<code>f</code>开始复制<code>s</code>字节到mem（内存）的位置<code>t</code>。</li>
<li><code>switch</code>：基础版<code>if/else</code>，不同的情况<code>case</code>返回不同值。可以有一个默认的<code>default</code>情况。</li>
<li><code>return(p, s)</code>：终止函数执行, 返回数据<code>mem[p..(p+s))</code>。</li>
<li><code>revert(p, s)</code>：终止函数执行, 回滚状态，返回数据<code>mem[p..(p+s))</code>。</li>
</ul>
<h4 id="旧逻辑合约"><a href="#旧逻辑合约" class="headerlink" title="旧逻辑合约"></a>旧逻辑合约</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openzeppelin&#96;的文档中，一般称逻辑合约的英文为&#96;implementation contract&#96;而不是&#96;logic contract&#96;</span><br></pre></td></tr></table></figure>
<p>这个逻辑合约包含<code>3</code>个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数<code>foo()</code>，将代理合约中的<code>words</code>的值改为<code>&quot;old&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑合约1</span></span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"old"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="新逻辑合约"><a href="#新逻辑合约" class="headerlink" title="新逻辑合约"></a>新逻辑合约</h4><p>这个逻辑合约包含<code>3</code>个状态变量，与保持代理合约一致，防止插槽冲突。它只有一个函数<code>foo()</code>，将代理合约中的<code>words</code>的值改为<code>&quot;new&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑合约2</span></span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器：0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"new"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管理者"><a href="#管理者" class="headerlink" title="管理者"></a>管理者</h4><p>管理者只需要调用SimpleUpgrade中的<code>upgrade(address logic2)</code>函数即可完成合约的升级。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这样的可升级模式看起来会给<code>DEFI</code>项目带来很多便利，同时也带来许多问题：</p>
<h4 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h4><p>​            在solidity中，函数选择器是函数签名的哈希的前4个字节，但由于函数选择器仅有4个字节，范围很小，因此两个不同的函数可能会有相同的选择器，例如下面两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择器冲突的例子</span></span><br><span class="line">contract Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint256</span>) <span class="title">external</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">collate_propagate_storage</span>(<span class="params">bytes16</span>) <span class="title">external</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中，函数<code>burn()</code>和<code>collate_propagate_storage()</code>的选择器都为<code>0x42966c68</code>，是一样的，这种情况被称为“选择器冲突”。在这种情况下，<code>EVM</code>无法通过函数选择器分辨用户调用哪个函数，因此该合约无法通过编译。</p>
<p>由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。举个例子，如果逻辑合约的<code>a</code>函数和代理合约的升级函数的选择器相同，那么管理人就会在调用<code>a</code>函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。</p>
<p>目前，有三种实现方式来避免这个问题，分别是：</p>
<ul>
<li>UUPS Implementation —— EIP1822</li>
<li>Transparent Proxy Implementation —— EIP1967</li>
</ul>
<ul>
<li>Diamond Implementation —— EIP2535</li>
</ul>
<p>其中，UUPS模式使用的最多，钻石协议比较新，被认为是很有潜力的一个EIP协议。</p>
<h4 id="存储冲突"><a href="#存储冲突" class="headerlink" title="存储冲突"></a>存储冲突</h4><p>由于委托调用的代理模式，使用代理时很快就会出现一个问题，与代理合约中存储变量的方式有关。假设代理将逻辑协定的地址存储在其唯一的变量中。现在，假设逻辑协定是一个基本标记，其第一个变量是 。这两个变量的大小均为 32 字节，据 EVM 所知，它们占据代理委托调用的结果执行流的第一个槽。当逻辑协定写入 时，它会在代理状态的范围内执行此操作，实际上写入 。此问题可称为“存储冲突”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|Proxy                     |Implementation           |</span><br><span class="line">|--------------------------|-------------------------|</span><br><span class="line">|address _implementation   |address _owner           | &lt;&#x3D;&#x3D;&#x3D; 存储碰撞</span><br><span class="line">|...                       |mapping _balances        |</span><br><span class="line">|                          |uint256 _supply          |</span><br><span class="line">|                          |...                      |</span><br></pre></td></tr></table></figure>
<h5 id="非结构化存储代理"><a href="#非结构化存储代理" class="headerlink" title="非结构化存储代理"></a>非结构化存储代理</h5><p>有很多方法可以克服这个问题，OpenZeppelin Upgrades实施的“非结构化存储”方法的工作原理如下。它不是将地址存储在代理的第一个存储槽中，而是选择一个伪随机槽。此插槽足够随机，逻辑合约在同一插槽中声明变量的概率可以忽略不计。在代理存储中随机化插槽位置的相同原理也用于代理可能具有的任何其他变量，例如管理员地址（允许更新的值）等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|Proxy                     |Implementation           |</span><br><span class="line">|--------------------------|-------------------------|</span><br><span class="line">|...                       |address _owner           |</span><br><span class="line">|...                       |mapping _balances        |</span><br><span class="line">|...                       |uint256 _supply          |</span><br><span class="line">|...                       |...                      |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br><span class="line">|address _implementation   |                         | &lt;&#x3D;&#x3D;&#x3D; 随机的slot.</span><br><span class="line">|...                       |                         |</span><br><span class="line">|...                       |                         |</span><br></pre></td></tr></table></figure>
<p>在 <a href="http://eips.ethereum.org/EIPS/eip-1967" target="_blank" rel="noopener">EIP 1967</a> 之后如何实现随机存储的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes32 private constant implementationPosition &#x3D; bytes32(uint256(</span><br><span class="line">  keccak256(&#39;eip1967.proxy.implementation&#39;)) - 1</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>因此，逻辑协定不需要关心覆盖代理的任何变量。面临此问题的其他代理实现通常意味着让代理了解逻辑协定的存储结构并适应它，或者让逻辑协定知道代理的存储结构并适应它。这就是为什么这种方法被称为“非结构化存储”的原因;任何一份合同都不需要关心另一份合同的结构。</p>
<h5 id="实现版本之间的存储冲突"><a href="#实现版本之间的存储冲突" class="headerlink" title="实现版本之间的存储冲突"></a>实现版本之间的存储冲突</h5><p>如前所述，非结构化方法避免了逻辑协定和代理之间的存储冲突。但是，不同版本的逻辑协定之间可能会发生存储冲突。在这种情况下，假设逻辑协定的第一个实现存储在第一个存储槽中，升级后的逻辑协定存储在同一个第一个槽中。当更新的逻辑协定尝试写入变量时，它将使用存储先前值的相同存储位置，并覆盖它。</p>
<p>不正确的存储保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|Implementation_v0   |Implementation_v1        |</span><br><span class="line">|--------------------|-------------------------|</span><br><span class="line">|address _owner      |address _lastContributor | &lt;&#x3D;&#x3D;&#x3D; 存储碰撞</span><br><span class="line">|mapping _balances   |address _owner           |</span><br><span class="line">|uint256 _supply     |mapping _balances        |</span><br><span class="line">|...                 |uint256 _supply          |</span><br><span class="line">|                    |...                      |</span><br></pre></td></tr></table></figure>
<p>正确的存储保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|Implementation_v0   |Implementation_v1        |</span><br><span class="line">|--------------------|-------------------------|</span><br><span class="line">|address _owner      |address _owner           |</span><br><span class="line">|mapping _balances   |mapping _balances        |</span><br><span class="line">|uint256 _supply     |uint256 _supply          |</span><br><span class="line">|...                 |address _lastContributor | &lt;&#x3D;&#x3D;&#x3D; 存储扩展</span><br><span class="line">|                    |...                      |</span><br></pre></td></tr></table></figure>
<p>非结构化存储代理机制无法防止这种情况。由用户决定让逻辑协定的新版本扩展以前的版本，或者保证存储层次结构始终追加但不修改。但是，OpenZeppelin Upgrades检测到此类冲突并适当地警告开发人员。</p>
<h2 id="四种可升级模式"><a href="#四种可升级模式" class="headerlink" title="四种可升级模式"></a>四种可升级模式</h2><p>在本文中只分析四种升级模式，接下来可能会写一篇文章深入EIP897，EIP1822，EIP1967，EIP2535。</p>
<p>需要注意的是除了EIP2535对应钻石代理以外，897，1822，1967是一个进化过程，现在oz库的UUPS，透明代理和信标代理均是在1967的基础上开发的。</p>
<p>目前大致有四种可升级方案，分别是</p>
<ul>
<li>UUPS代理</li>
<li>透明代理</li>
<li>信标代理</li>
<li>钻石代理</li>
</ul>
<p><code>OpenZeppelin</code>中包含的原始代理遵循<code>透明代理模式</code>，虽然<code>oz</code>仍然提供这种模式，但<code>oz</code>的建议是现在转向 UUPS 代理，它既轻量级又通用。</p>
<p>推荐阅读<code>OpenZeppelin</code>的官方博客：</p>
<p><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy" target="_blank" rel="noopener">Proxies - OpenZeppelin Docs</a></p>
<p>钻石代理是唯一没有被<code>OZ</code>收录的代理协议，一方面是因为此代理现在存在一定的争议，一方面是因为支持钻石代理对于oz来说工作量太大。就目前的情况来看，oz并不打算将钻石代理整合进oz库。</p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2793" target="_blank" rel="noopener">EIP-2535 Diamonds Implementation for OpenZeppelin · Issue #2793 · OpenZeppelin/openzeppelin-contracts (github.com)</a></p>
<h3 id="透明代理—Transparent"><a href="#透明代理—Transparent" class="headerlink" title="透明代理—Transparent"></a>透明代理—Transparent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"</span>;</span><br></pre></td></tr></table></figure>
<p>此协定实现可由管理员升级的代理。</p>
<p>这种模式意味着:</p>
<ul>
<li><p>如果管理员以外的任何帐户调用代理合约，则调用将转发到逻辑合约，即使该调用与代理本身公开的管理函数之一冲突。</p>
</li>
<li><p>如果管理员调用代理，它只可以访问管理功能，其调用永远不会转发到逻辑合约。如果管理员尝试在逻辑合约上调用函数，它将失败并显示错误 “管理员无法回退到代理目标”。</p>
</li>
</ul>
<p>这些属性意味着管理员帐户只能用于管理员操作，例如升级代理或更改 管理员，因此最好是不用于其他任何用途的专用帐户。这些属性将避免<strong>选择器冲突</strong>发送的可能。</p>
<p>以下是根据openzeppelin库给出的实现逻辑梳理的call graph：</p>
<p><img src="transparent.png" alt=""></p>
<h4 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h4><p>以下代码由<code>TransparentUpgradeableProxy</code>简化而成</p>
<h5 id="代理合约-1"><a href="#代理合约-1" class="headerlink" title="代理合约"></a>代理合约</h5><p>它包含<code>3</code>个变量：</p>
<ul>
<li><code>implementation</code>：逻辑合约地址。</li>
<li><code>admin</code>：admin地址。</li>
<li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li>
</ul>
<p>它包含<code>3</code>个函数</p>
<ul>
<li>构造函数：初始化admin和逻辑合约地址。</li>
<li><code>fallback()</code>：回调函数，将调用委托给逻辑合约，不能由<code>admin</code>调用。</li>
<li><code>upgrade()</code>：升级函数，改变逻辑合约地址，只能由<code>admin</code>调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract TransparentProxy &#123;</span><br><span class="line">    address implementation; <span class="comment">// logic合约地址</span></span><br><span class="line">    address admin; <span class="comment">// 管理员</span></span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化admin和逻辑合约地址</span></span><br><span class="line">    <span class="keyword">constructor</span>(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback函数，将调用委托给逻辑合约</span></span><br><span class="line">    <span class="comment">// 不能被admin调用，避免选择器冲突引发意外</span></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender != admin);</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender != admin) revert();</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="逻辑合约"><a href="#逻辑合约" class="headerlink" title="逻辑合约"></a>逻辑合约</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧逻辑合约</span></span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"old"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新逻辑合约</span></span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器：0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"new"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="管理者合约"><a href="#管理者合约" class="headerlink" title="管理者合约"></a>管理者合约</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol"</span>;</span><br></pre></td></tr></table></figure>
<p>openzeppelin给我们提供了一个辅助合同，旨在被分配为 <code>TransparentUpgradeableProxy</code>的管理员。对于一个 解释为什么要使用它，请参阅 <a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#TransparentUpgradeableProxy" target="_blank" rel="noopener"><code>TransparentUpgradeableProxy</code></a> 的文档。</p>
<p>在本合约是管理者的情况下，调用<code>upgrade(proxy, _implementation)</code>或<code>upgradeAndCall(proxy, implementation, data)</code>即可</p>
<h3 id="通用可升级代理—UUPS"><a href="#通用可升级代理—UUPS" class="headerlink" title="通用可升级代理—UUPS"></a>通用可升级代理—UUPS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;proxy&#x2F;utils&#x2F;UUPSUpgradeable.sol&quot;;</span><br></pre></td></tr></table></figure>
<p>UUPS 的名称来自 <a href="https://eips.ethereum.org/EIPS/eip-1822" target="_blank" rel="noopener">EIP1822</a>，它首先记录了该模式。</p>
<p>在该模式中，升级函数存在于逻辑合约中而非代理合约。这也使得管理员随时可以把合约变为不可升级的合约。</p>
<p>UUPS和透明代理共享相同的升级接口，但在 UUPS 代理中，升级由实现处理，最终可以删除。另一方面，透明代理在代理本身中包含升级和管理逻辑。这意味着<code>TransparentUpgradeableProxy</code>的部署成本高于UUPS代理。</p>
<p>UUPS 代理是使用 <code>ERC1967Proxy</code>实现的。请注意，UUPS代理本身不可升级。实现<code>ERC1967Proxy</code>的作用是，除了合约的逻辑之外，还包括更新存储在代理存储空间中特定插槽中的实现地址所需的所有代码。这就是<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable" target="_blank" rel="noopener"><code>UUPSUpgradeable</code></a>合约的用武之地。从它继承（并使用相关的访问控制机制覆盖<code>_authorizeUpgrade</code>函数将使您的合约变成符合 UUPS 的实现。</p>
<p>请注意，由于两个代理使用相同的存储槽作为实现地址，因此将符合 UUPS 的实现与 <code>TransparentUpgradeableProxy</code>一起使用可能允许非管理员执行升级操作。</p>
<p>默认情况下，<code>UUPSUpgradeable</code>中包含的升级功能包含一种安全机制，该机制将阻止对不符合 UUPS 的实现进行任何升级。这可以防止升级到不包含必要升级机制的实现协定，因为它会永久锁定代理的可升级性。以下任一方法都可以绕过此安全机制：</p>
<ul>
<li>在实现中添加一个标志机制，该机制将在触发时禁用升级功能。</li>
<li>升级到具有升级机制的实现，而无需额外的安全检查，然后再次升级到没有升级机制的另一个实现。</li>
</ul>
<p>此安全机制的当前实现使用 <a href="https://eips.ethereum.org/EIPS/eip-1822" target="_blank" rel="noopener">EIP1822</a> 来检测实现使用的存储槽。以前的实现（现已弃用）依赖于回滚检查。可以从使用旧机制的合约升级到新合约。然而，相反是不可能的，因为旧的实现（4.5 版之前）不包括接口。<code>ERC1822</code></p>
<p><code>oz</code>库中UUPS实现的call graph：</p>
<p><img src="UUPS.png" alt=""></p>
<h4 id="简单实现-2"><a href="#简单实现-2" class="headerlink" title="简单实现"></a>简单实现</h4><h5 id="代理合约-2"><a href="#代理合约-2" class="headerlink" title="代理合约"></a>代理合约</h5><p>UUPS的代理合约看起来像是个不可升级的代理合约，非常简单，因为升级函数被放在了逻辑合约中。它包含<code>3</code>个变量：</p>
<ul>
<li><code>implementation</code>：逻辑合约地址。</li>
<li><code>admin</code>：admin地址。</li>
<li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li>
</ul>
<p>它包含<code>2</code>个函数</p>
<ul>
<li>构造函数：初始化admin和逻辑合约地址。</li>
<li><code>fallback()</code>：回调函数，将调用委托给逻辑合约。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract UUPSProxy &#123;</span><br><span class="line">    address public implementation; <span class="comment">// 逻辑合约地址</span></span><br><span class="line">    address public admin; <span class="comment">// admin地址</span></span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化admin和逻辑合约地址</span></span><br><span class="line">    <span class="keyword">constructor</span>(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback函数，将调用委托给逻辑合约</span></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="逻辑合约-1"><a href="#逻辑合约-1" class="headerlink" title="逻辑合约"></a>逻辑合约</h5><p>UUPS的逻辑合约与透明代理中的不同是多了个升级函数。UUPS逻辑合约包含<code>3</code>个状态变量，与保持代理合约一致，防止插槽冲突。它包含<code>2</code>个</p>
<ul>
<li><code>upgrade()</code>：升级函数，将改变逻辑合约地址<code>implementation</code>，只能由<code>admin</code>调用。</li>
<li><code>foo()</code>：旧UUPS逻辑合约会将<code>words</code>的值改为<code>&quot;old&quot;</code>，新的会改为<code>&quot;new&quot;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UUPS逻辑合约（升级函数写在逻辑合约内）</span></span><br><span class="line">contract UUPS1&#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"old"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span></span><br><span class="line">    <span class="comment">// UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的UUPS逻辑合约</span></span><br><span class="line">contract UUPS2&#123;</span><br><span class="line">    <span class="comment">// 状态变量和proxy合约一致，防止插槽冲突</span></span><br><span class="line">    address public implementation; </span><br><span class="line">    address public admin; </span><br><span class="line">    string public words; <span class="comment">// 字符串，可以通过逻辑合约的函数改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变proxy中状态变量，选择器： 0xc2985578</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        words = <span class="string">"new"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span></span><br><span class="line">    <span class="comment">// UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">address newImplementation</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="oz库的完整实现"><a href="#oz库的完整实现" class="headerlink" title="oz库的完整实现"></a>oz库的完整实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;proxy&#x2F;utils&#x2F;UUPSUpgradeable.sol&quot;;</span><br></pre></td></tr></table></figure>
<p><code>UUPSUpgradeable</code>是专为 UUPS 代理设计的可升级性机制。此处包含的函数可以执行<code>ERC1967Proxy</code>的升级，当此合约设置为此类代理后面的实现时。</p>
<p>安全机制可确保升级不会意外关闭可升级性，尽管此风险是 如果升级保留可升级性但删除了安全机制，例如，通过替换为升级的自定义实现，则恢复。<code>UUPSUpgradeable</code></p>
<p>必须覆盖<code>_authorizeUpgrade</code>函数以包括对升级机制的访问限制。</p>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>onlyProxy()</th>
</tr>
</thead>
<tbody>
<tr>
<td>检查是否通过委托调用调用执行，以及执行上下文是否为 具有指向 self 的实现（如 ERC1967 中所定义）的代理合约。应该只是这种情况 对于使用当前合同作为其实现的 UUPS 和透明代理。执行 通过ERC1167的功能 最小代理（克隆）通常不会通过此测试，但不能保证 失败。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>notDelegated()</th>
</tr>
</thead>
<tbody>
<tr>
<td>检查是否未通过委托调用执行。这允许函数 可在实施合同上调用，但不能通过代理调用</td>
</tr>
</tbody>
</table>
</div>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><div class="table-container">
<table>
<thead>
<tr>
<th>onlyProxy()</th>
</tr>
</thead>
<tbody>
<tr>
<td>检查是否通过委托调用调用执行，以及执行上下文是否为 具有指向 self 的实现（如 ERC1967 中所定义）的代理合约。应该只是这种情况 对于使用当前合同作为其实现的 UUPS 和透明代理。执行 通过ERC1167的功能 最小代理（克隆）通常不会通过此测试，但不能保证 失败。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>notDelegated()</th>
</tr>
</thead>
<tbody>
<tr>
<td>检查是否通过委托调用调用执行，以及执行上下文是否为 具有指向 self 的实现（如 ERC1967 中所定义）的代理合约。应该只是这种情况 对于使用当前合同作为其实现的 UUPS 和透明代理。执行 通过ERC1167的功能 最小代理（克隆）通常不会通过此测试，但不能保证 失败。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>proxiableUUID() → bytes32</th>
</tr>
</thead>
<tbody>
<tr>
<td>ERC1822 <code>proxiableUUID</code>函数的实现。这将返回 实现。它用于在执行升级时验证实现的兼容性。</td>
</tr>
<tr>
<td>注意：</td>
</tr>
<tr>
<td>指向可代理合约的代理本身不应被视为可代理合约，因为存在风险 砖砌一个升级到它的代理，通过委派给自己直到耗尽气体。因此，至关重要的是 如果通过代理调用，则函数还原。这是由修饰符<code>notDelegated()</code>保证的。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>upgradeTo(address newImplementation)</th>
</tr>
</thead>
<tbody>
<tr>
<td>①将代理的实现升级到 。<code>newImplementation</code>。②呼叫<code>_authorizeUpgrade</code>。③发出升级事件。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>upgradeToAndCall(address newImplementation, bytes data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>①将代理的实现升级到 ，然后执行函数调用 以 编码。<code>newImplementation``data</code>。②呼叫<code>_authorizeUpgrade</code>③发出升级事件</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>_authorizeUpgrade(address newImplementation)</th>
</tr>
</thead>
<tbody>
<tr>
<td>在无权升级合约时应还原的功能。通过升级<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-upgradeTo-address-" target="_blank" rel="noopener"><code>到</code></a>和<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-upgradeToAndCall-address-bytes-" target="_blank" rel="noopener"><code>升级到和调用调用</code></a>。通常，此函数将使用<a href="https://docs.openzeppelin.com/contracts/4.x/api/access" target="_blank" rel="noopener">访问控制</a>修饰符，例如 <code>function _authorizeUpgrade(address) internal override onlyOwner {}</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="信标代理—Beacon"><a href="#信标代理—Beacon" class="headerlink" title="信标代理—Beacon"></a>信标代理—Beacon</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin&#x2F;contracts&#x2F;proxy&#x2F;beacon&#x2F;BeaconProxy.sol&quot;;</span><br></pre></td></tr></table></figure>
<p>以上两种代理，都存在一种缺陷，就是如果我要升级一批具有相同逻辑合约的代理合约，那么需要在每个代理合约都执行一遍升级（因为每个代理合约独立存储了_implementation）。信标合约，就是将所有的具有相同逻辑合约的代理合约的_implementation只存一份在信标合约中，所有的代理合约通过和信标合约接口调用，获取_implementation，这样，在升级的时候，就可以只升级信标合约，就能搞定所有的代理合约的升级。</p>
<p><img src="Beacon.png" alt=""></p>
<h4 id="简单实现-3"><a href="#简单实现-3" class="headerlink" title="简单实现"></a>简单实现</h4><h5 id="代理合约-3"><a href="#代理合约-3" class="headerlink" title="代理合约"></a>代理合约</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数需要信标合约的地址，所以信标合约要先部署。将信标合约的地址传给代理合约进行构造。</span></span><br><span class="line"><span class="keyword">constructor</span>(address beacon, bytes memory data) payable &#123;</span><br><span class="line">    _upgradeBeaconToAndCall(beacon, data, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从信标合约获取实现。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_implementation</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">virtual</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IBeacon(_getBeacon()).implementation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信标合约"><a href="#信标合约" class="headerlink" title="信标合约"></a>信标合约</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数需要逻辑合约的实现，所以先要部署逻辑合约，再部署信标合约。</span><br><span class="line">constructor(address implementation_) &#123;</span><br><span class="line">    _setImplementation(implementation_);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 升级直接升级信标合约的implementation即可。</span><br><span class="line">function upgradeTo(address newImplementation) public virtual onlyOwner &#123;</span><br><span class="line">    _setImplementation(newImplementation);</span><br><span class="line">    emit Upgraded(newImplementation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="钻石代理—Diamond"><a href="#钻石代理—Diamond" class="headerlink" title="钻石代理—Diamond"></a>钻石代理—Diamond</h3><p>EIP-2535 是以太坊上一个将合约进行代码模块化组合的提案，其目的是为了让大型的智能合约突破 24kb 大小的最大限制，并且让合约更方便地更新功能。</p>
<p>钻石代理，较EIP1967来讲，最大的改变其实是在存储模型上的改进，笔者在阅读钻石代理相关文档的时候，感觉又被酷到，这里的钻石术语让我感觉很有意思，但同时也增加了审计代码的困难度。</p>
<p>虽然钻石代理的设计模式非常好，但笔者不认为这个代理模式会对现在市面上最常见的以EIP1967为基础的透明代理和UUPS的地位造成威胁。一是因为钻石代理模式相对比较复杂，开发周期会延长，且现目前<code>OZ</code>库中所实现的三种代理模式足够满足绝大多数项目的需求。二是<code>oz</code>方面对实现钻石代理并不感兴趣，毕竟在代理方面，稍不注意就会出现漏洞，还涉及文档和其他材料、对升级插件和 OpenZeppelin Defender 中模式的支持，这对钻石代理的发展明显是不利的。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>要理解钻石协议，首先有几个相关的概念定义需要知道：</p>
<ul>
<li><strong>钻石（diamond）</strong> : 钻石可以理解为代理合约（Proxy），也是与用户进行交互的主合约</li>
<li><strong>切面（facet）</strong> : 正如真正的钻石有不同的侧面一样，一个钻石合约也有着不同的面，钻石合约的每个功能所需要调用的合约对应一个切面，所以也可以理解为实现合约 （Implementation）</li>
<li><strong>钻石切割（diamondCut）</strong> : 钻石协议标准扩展了一种叫钻石切割的功能，其主要作用从钻石中增加、替换或删除切面和功能，可以理解为合约的升级 （Upgrade）</li>
<li><strong>放大镜（The Loupe）</strong> : 钻石协议标准中的放大镜功能主要是返回关于切面的信息和钻石存在的功能，这些信息是保存在钻石合约内部的存储结构——DiamondStorage 中</li>
</ul>
<p>钻石模型：</p>
<p><img src="Diamond_info.png" alt=""></p>
<p>通过使用钻石标准规范去创建钻石合约，这个合约可以像使用当前合约的代码一样使用任何数量的其他切面合约的代码。</p>
<p>在该钻石合约中不同的函数功能需要调用对应的不同的切面合约的代码来实现，并且可以利用钻石切割的功能来对钻石合约中的函数功能进行修改（添加、替换或删除）。</p>
<p>这与市面上大多数使用一个代理合约和一个实现合约来实现交互与升级的方式有所区别。</p>
<p><img src="Diamond_upgrade.png" alt=""></p>
<h4 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h4><p>提案的草稿声称要给予<code>delegatecall</code>方法提出合约升级的一种新范式。EIP 2535 提议使用：</p>
<ol>
<li>与实现合约适配的查找表（lookup table）</li>
<li><strong>任意的存储指针</strong>（arbitrary storage pointer）</li>
</ol>
<h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><p>基于 delegatecall 的升级方法主要使用两个组件：一个代理合约和一个实现合约</p>
<p><img src="Diamond_lookup.png" alt=""></p>
<p>用户与代理合约交互，代理合约向实现合约发送 delegatecall 调用实现合约内的函数。执行的是实现合约内的代码，但整套合约的 storage 保存在代理合约内。</p>
<p>使用了查找表，代理合约就可以向<strong>多个逻辑合约</strong>发起 delegatecall 调用，可根据要调用的函数来选择合适的实现合约。</p>
<p><img src="Diamond_lookup2.png" alt=""></p>
<p>其实这种模式不是什么新东西。之前也有其他项目使用过这样的查找表来实现可升级性。例如<code>ColonyNetwork</code></p>
<h5 id="钻石存储——任意的存储指针"><a href="#钻石存储——任意的存储指针" class="headerlink" title="钻石存储——任意的存储指针"></a>钻石存储——任意的存储指针</h5><p>请注意不要和非结构化存储混淆，二者从根本上不一样。</p>
<p>钻石提案还建议使用 Solidity 最近引入的一个功能：任意的存储指针。这个功能名副其实，就是允许你把一个 storage 的指针指向任意一个位置。</p>
<p><code>EIP2535</code>作者<strong>Nick Mudge</strong>对钻石代理存储模式的解释：</p>
<p><a href="https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb" target="_blank" rel="noopener">New Storage Layout For Proxy Contracts and Diamonds | by Nick Mudge | 1MillionDevs | Medium</a></p>
<ol>
<li>创建合同。这是一个钻石存储合同，但我们称之为“存储合同”，因为它更短。</li>
<li>在存储协定中创建一个结构，其中包含您关注的状态变量。</li>
<li>选择存储中的位置来读取和写入结构。</li>
<li>在存储协定中编写一个函数，该函数为结构创建存储指针并返回它。</li>
<li>任何需要读取/写入存储协定中定义的状态变量的协定/代理/分面只需要继承存储协定并调用返回存储指针的函数。</li>
</ol>
<p>下面是一个使用钻石存储的合同的简单示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract MyStorageContract &#123;</span><br><span class="line"><span class="comment">// The state variables we care about.</span></span><br><span class="line">  struct MyStorage &#123;</span><br><span class="line">    uint aVar;</span><br><span class="line">    bytes myBytes;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bytes32) myMap;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// Creates and returns the storage pointer to the struct.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myStorage</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span>(<span class="params">MyStorage storage ms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ms_slot = keccak256("com.mycompany.my.storage")</span></span><br><span class="line">    assembly &#123;ms.slot := <span class="number">0xabcd55b489adb030b</span>...d09c4154cf0&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您想查看真实示例，请查看最近更新为使用钻石存储的<a href="https://github.com/mudgen/Diamond" target="_blank" rel="noopener">钻石标准的参考实现</a>。具体看看<a href="https://github.com/mudgen/diamond-1/blob/master/contracts/libraries/LibDiamond.sol" target="_blank" rel="noopener">LibDiamond.sol</a>。</p>
<p>下面是使用上述 <code>MyStorageContract</code> 的代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is MyStorageContract &#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">uint selector, bytes32 myData</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">   MyStorage storage ms = myStorage();</span><br><span class="line">   ms.myMap[selector] = myData;</span><br><span class="line">   ms.aVar = uint(myData);</span><br><span class="line">   <span class="comment">//... more code;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMyData</span>(<span class="params">uint selector</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bytes32</span>)</span>&#123;</span><br><span class="line">   MyStorage storage ms = myStorage();</span><br><span class="line">   bytes32 data = ms.myMap[selector];</span><br><span class="line">   <span class="comment">//... more code</span></span><br><span class="line">   <span class="keyword">return</span> data;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 storage 都存储在代理合约里，实现合约的 storage 布局必须与代理合约的 storage 布局保持一致。在升级的时候，很难跟踪这种布局。</p>
<p>这个 EIP 提议，每个实现合约都要有一个相关联的结构体来保管实现合约的变量，然后用一个指针指向存储该结构体的 storage 位置。这类似于 <code>unstructured storage</code>模式，也是 Solidity 的一个新功能，支持使用一个结构体来替代一个单一的变量。</p>
<p>此处的假定是：来自两个不同实现的结构体不可能冲突，只要它们的基础指针（base pointer）不同。</p>
<p><img src="Diamond_storagepoint.png" alt=""></p>
<h5 id="任意存储指针vs非结构化存储"><a href="#任意存储指针vs非结构化存储" class="headerlink" title="任意存储指针vs非结构化存储"></a>任意存储指针vs非结构化存储</h5><ul>
<li><p>非结构化存储</p>
<blockquote>
<p><em>Solidity的存储布局可以通过汇编绕过，允许程序员在合约存储中的任意位置设置和存储值。这就是非结构化存储模式。</em></p>
</blockquote>
<ul>
<li><p>缺点：</p>
<blockquote>
<ol>
<li>需要为每个存储变量定义和使用 getter 和 setter 函数。</li>
<li>这适用于简单值。它不适用于结构或映射。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>任意存储指针</p>
</li>
</ul>
<p>​        钻石存储与非结构化存储模式有一些相似之处，因为它使用程序集绕过了 Solidity 的默认存储布局。但是钻石存储有几个主要区别，没有缺点。</p>
<ol>
<li>钻石存储只有一个 getter 函数，该函数返回指向可以包含任意数量值的结构的存储指针。存储指针直接用于读取和写入值到存储。</li>
<li>钻石存储与可以包含多个简单值、数组、映射和其他结构的结构一起工作。</li>
</ol>
<h4 id="放大镜（The-Loupe）"><a href="#放大镜（The-Loupe）" class="headerlink" title="放大镜（The Loupe）"></a>放大镜（The Loupe）</h4><p>Loupe可以说是钻石代理全新的东西，Eip作者Nick Mudge也做出了全面的解答。</p>
<p><a href="https://eip2535diamonds.substack.com/p/why-on-chain-loupe-functions-are" target="_blank" rel="noopener">Why On-Chain Loupe Functions are Good - by Nick Mudge 💎 (substack.com)</a></p>
<p><a href="https://dev.to/mudgen/why-loupe-functions-for-diamonds-1kc3" target="_blank" rel="noopener">Diamond Loupe Functions - DEV Community 👩‍💻👨‍💻</a></p>
<blockquote>
<p>放大镜是用来观察钻石的放大镜。</p>
<p>在 <a href="https://eips.ethereum.org/EIPS/eip-2535" target="_blank" rel="noopener">EIP-2535 钻石标准</a>中，放大镜是四个标准的只读函数，用于告诉您菱形提供哪些功能和刻面。</p>
<p>刻面是一种智能合约，为钻石提供外部功能。</p>
</blockquote>
<p>放大函数存在的一个重要原因是因为智能合约上的函数比事件更可靠。这些功能使钻石坚固耐用。这确保了它们的透明度和与软件的互操作性。</p>
<p>以下是四个标准的只读放大函数：</p>
<ul>
<li><code>facetAddresses()</code>返回菱形使用的所有分面地址。</li>
<li><code>facetAddress(bytes4 _functionSelector)</code>返回实现函数的分面地址。</li>
<li><code>facetFunctionSelectors(address _facet)</code>返回菱形使用的所有函数，这些函数来自特定刻面。</li>
<li><code>facets()</code>返回一个数组，该数组由菱形使用的所有分面地址和函数组成。</li>
</ul>
<p>放大镜功能可用于许多有用的事情，包括：</p>
<ol>
<li>使用分面地址查询 Etherscan 等服务，以检索和显示钻石使用的所有源代码。</li>
<li>检索钻石的 ABI 信息。</li>
<li>工具和编程库使用它们来部署菱形。</li>
<li>工具和编程库使用它们来升级钻石。</li>
<li>用户界面使用它们来显示有关钻石的信息。</li>
<li>用户界面使用它们使用户能够显示和调用钻石上的函数。</li>
<li>测试使用它们来验证是否正确使用了正确的函数和方面。</li>
</ol>
<p>放大镜功能使钻石透明。这对于理解、展示和使用钻石提供的功能非常重要。</p>
<p>它们对于验证钻石使用是否正确而不是错误或恶意使用非常重要。</p>
<p>它们对于测试以确保菱形包含正确的函数和刻面以及测试使用钻石的代码非常重要。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>1.钻石通过delegatecall调用代理合约中的函数。</p>
<p>2.钻石通过调用diamondCut函数增加、替换或删除代理合约以及函数。</p>
<p>3.当钻石发生任何变化时，产生一个DiamondCut事件。</p>
<h2 id="最小代理"><a href="#最小代理" class="headerlink" title="最小代理"></a>最小代理</h2><p>在开始之前，<strong>EIP 1167 与可升级性无关</strong>，也不试图替换它。</p>
<p>EIP1167其实有点生涩，因为它是用EVM低级代码编写的。</p>
<h3 id="为什么是最小代理？"><a href="#为什么是最小代理？" class="headerlink" title="为什么是最小代理？"></a>为什么是最小代理？</h3><p>假设您需要为您的dApp上的每个用户部署一个钱包。或者，您可能需要为平台处理的每个交易操作设置托管。</p>
<p>这些只是您必须多次部署同一协定的示例。当然，每个合约的初始化数据可能不同，但代码是相同的。</p>
<p>由于部署大型合约可能非常昂贵，因此有一种聪明的解决方法，通过它，您可以以<em>最低</em>的部署成本部署同一合约数千次：它称为 <a href="https://eips.ethereum.org/EIPS/eip-1167" target="_blank" rel="noopener">EIP 1167</a>，但我们只称其为<strong>最小代理</strong>。</p>
<h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><p>避免重复部署同样的合约代码，取而代之的是只部署一次合约代码，当需要一份拷贝的时候，就只需要部署一个简单的代理合约。代理合约使用<code>delegatecall</code>来调用合约代码，代理合约有自己的地址、存储插槽和以太余额等。主要目的是为了节约Gas。</p>
<p>EIP-1167标准是为了以不可改变的方式简单而廉价地克隆目标合约的功能，它规定了一个最小的字节码实现，它将所有调用委托给一个已知的固定地址。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，让我们考虑一下最小代理需要做什么：</p>
<ol>
<li>接收一些数据</li>
<li>使用 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md" target="_blank" rel="noopener">DELEGATECALL</a> 指令将接收到的数据转发到实施协定。</li>
<li>获取外部调用的结果（即 DELEGATECALL 的结果）</li>
<li>如果步骤 3 成功，则将外部调用的结果返回给调用方，或者在任何其他情况下还原事务。</li>
</ol>
<p>这四个步骤映射到 EVM 指令中：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>需求</th>
<th>EVM 指令</th>
<th>简短解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>解析从调用方接收的数据</td>
<td><a href="https://ethervm.io/#CALLDATACOPY" target="_blank" rel="noopener">CALLDATACOPY</a></td>
<td>calldata 是在交易中发送到合约的数据，因此我们需要将其复制到内存中，以便以后能够转发它。</td>
</tr>
<tr>
<td>执行对实现协定的委托调用</td>
<td><a href="https://ethervm.io/#DELEGATECALL" target="_blank" rel="noopener">DELEGATECALL</a></td>
<td>在这里，我们将获得的调用数据转发到实现合约。</td>
</tr>
<tr>
<td>检索外部调用的结果</td>
<td><a href="https://ethervm.io/#RETURNDATACOPY" target="_blank" rel="noopener">RETURNDATACOPY</a></td>
<td>我们将 DELEGATECALL 的返回数据复制到内存中。</td>
</tr>
<tr>
<td>将数据返回给调用方或还原事务</td>
<td><a href="https://ethervm.io/#JUMPI" target="_blank" rel="noopener">JUMPI</a>, <a href="https://ethervm.io/#RETURN" target="_blank" rel="noopener">RETURN</a>, <a href="https://ethervm.io/#REVERT" target="_blank" rel="noopener">REVERT</a></td>
<td>根据外部调用的成功/失败状态，我们要么返回数据，要么还原事务。</td>
</tr>
</tbody>
</table>
</div>
<p>看上去和我们之前讲到的透明代理以及UUPS的fallback内容很相似，这并不难，理解到这里以及吃透了一半。我们现在只需要解决一些次要的实现细节。</p>
<h3 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3</span><br></pre></td></tr></table></figure>
<p>这样一串字节码其实就是EIP1167的核心内容甚至可以说是全部内容。</p>
<p>其中<code>bebebebebebebebebebebebebebebebebebebebe</code>是目标合约的地址。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>    <span class="number">36</span>  CALLDATASIZE		cSize</span><br><span class="line"><span class="number">0001</span>    <span class="number">3</span>D  RETURNDATASIZE		cSize <span class="number">0</span></span><br><span class="line"><span class="number">0002</span>    <span class="number">3</span>D  RETURNDATASIZE		cSize <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0003</span>    <span class="number">37</span>  CALLDATACOPY		</span><br><span class="line"><span class="number">0004</span>    <span class="number">3</span>D  RETURNDATASIZE		<span class="number">0</span></span><br><span class="line"><span class="number">0005</span>    <span class="number">3</span>D  RETURNDATASIZE		<span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0006</span>    <span class="number">3</span>D  RETURNDATASIZE		<span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0007</span>    <span class="number">36</span>  CALLDATASIZE		<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize</span><br><span class="line"><span class="number">0008</span>    <span class="number">3</span>D  RETURNDATASIZE		<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize <span class="number">0</span></span><br><span class="line"><span class="number">0009</span>    <span class="number">73</span>  PUSH20 <span class="number">0xbebebebebebebebebebebebebebebebebebebebe</span>	<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize <span class="number">0</span> addr</span><br><span class="line"><span class="number">001</span>E    <span class="number">5</span>A  GAS					<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> cSize <span class="number">0</span> addr gas</span><br><span class="line"><span class="number">001</span>F    F4  DELEGATECALL		<span class="number">0</span> success</span><br><span class="line"><span class="number">0020</span>    <span class="number">3</span>D  RETURNDATASIZE		<span class="number">0</span> success rSize</span><br><span class="line"><span class="number">0021</span>    <span class="number">82</span>  DUP3				<span class="number">0</span> success rSize <span class="number">0</span></span><br><span class="line"><span class="number">0022</span>    <span class="number">80</span>  DUP1				<span class="number">0</span> success rSize <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0023</span>    <span class="number">3</span>E  RETURNDATACOPY		<span class="number">0</span> success</span><br><span class="line"><span class="number">0024</span>    <span class="number">90</span>  SWAP1				success <span class="number">0</span></span><br><span class="line"><span class="number">0025</span>    <span class="number">3</span>D  RETURNDATASIZE		success <span class="number">0</span> rSize</span><br><span class="line"><span class="number">0026</span>    <span class="number">91</span>  SWAP2				rSize <span class="number">0</span> success</span><br><span class="line"><span class="number">0027</span>    <span class="number">60</span>  PUSH1 <span class="number">0x2b</span>			rSize <span class="number">0</span> success <span class="number">0x2b</span></span><br><span class="line"><span class="number">0029</span>    <span class="number">57</span>  *JUMPI				</span><br><span class="line"><span class="number">002</span>A    FD  *REVERT</span><br><span class="line"><span class="number">002</span>B    <span class="number">5</span>B  JUMPDEST			rSize <span class="number">0</span></span><br><span class="line"><span class="number">002</span>C    F3  *RETURN</span><br><span class="line">=&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">address addr</span>) </span>&#123;</span><br><span class="line">	assembly&#123;</span><br><span class="line">		<span class="keyword">let</span> cSize := calldatasize()</span><br><span class="line">		calldatacopy(<span class="number">0</span>,<span class="number">0</span>,cSize) <span class="comment">// 此时MEM[0:0+cSize] = input data,即把函数选择器连同参数一起存放在内存0x00位置处</span></span><br><span class="line">		<span class="keyword">let</span> gas := gas()</span><br><span class="line">		<span class="keyword">let</span> success := delegatecall(gas, addr, <span class="number">0</span>, cSize, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">//此时调用了addr地址处的代码，方法参数为我方合约内存MEM[0:0+cSize]</span></span><br><span class="line">		returndatacopy(<span class="number">0</span>,<span class="number">0</span>,returndatasize()) <span class="comment">//拷贝返回值到内存中MEM[0:rSize]</span></span><br><span class="line">		<span class="keyword">if</span> (success) &#123;</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>, rSize) <span class="comment">//将存放在内存中的返回值返回回去</span></span><br><span class="line">		&#125;</span><br><span class="line">		revert(<span class="number">0</span>, rSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：为了尽可能减少gas成本，上述字节码依赖于EIP-211规范，即<code>returndatasize</code>在调用帧内的任何调用之前返回0。 <code>returndatasize</code>比<code>dup</code>*少用1 gas。</p>
<p>可以将<code>returndatasize</code>换成更好理解的<code>push1 0x00</code>,更好理解</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们需要以下合约:</p>
<ul>
<li>实现：这是我们的逻辑所在的地方，我们将其称为Implementation.sol。</li>
<li>CloneFactory：这将是我们的工厂，我们将有一个clone() 函数，用户将触发该函数，工厂将输出代理的地址。工厂的名称将是CloneFactory.sol。</li>
<li>代理：与代理无关，代理将是CloneFactory.sol 中的clone() 函数的输出。可以有尽可能多的不同代理，这就是整个目的，以创建许多Implementation.sol的克隆。</li>
</ul>
<h4 id="逻辑合约-2"><a href="#逻辑合约-2" class="headerlink" title="逻辑合约"></a>逻辑合约</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.8</span><span class="number">.0</span> &lt; <span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Implementation &#123;</span><br><span class="line">    uint public x;</span><br><span class="line">    bool public isBase;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner,<span class="string">"ERROR: Only Owner"</span>);</span><br><span class="line"></span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑合约的构造函数应该是无参的</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        isBase = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦创建代理克隆，需要立即调用 initialize 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params">address _owner</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证该合约只用于逻辑，不会被初始化（代理或者克隆合约不知道构造函数）</span></span><br><span class="line">        <span class="built_in">require</span>(isBase == <span class="literal">false</span>,<span class="string">"ERROR: This the base contract, cannot initialize"</span>);</span><br><span class="line">        <span class="comment">// 确保 initialize 函数只被调用一次</span></span><br><span class="line">        <span class="built_in">require</span>(owner == address(<span class="number">0</span>),<span class="string">"ERROR: Contract already initialized"</span>);</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setX</span>(<span class="params">uint _newX</span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        x = _newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOLIDITY</span><br></pre></td></tr></table></figure>
<h4 id="CloneFactory"><a href="#CloneFactory" class="headerlink" title="CloneFactory"></a>CloneFactory</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;= <span class="number">0.8</span><span class="number">.0</span> &lt; <span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface Implementation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params">address _owner</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">CloneFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑合约的地址</span></span><br><span class="line">    address public implementation;</span><br><span class="line">    <span class="comment">// 跟踪所有已部署克隆的映射</span></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> address[]) public allClones;</span><br><span class="line">    event NewClone(address _newClone, address _owner);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _imlementation) &#123;</span><br><span class="line">        implementation = _imlementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 Open Zeppelin，用于动态创建代理合约并返回新合约的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">address _imlementation</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">address instance</span>) </span>&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr := mload(<span class="number">0x40</span>)</span><br><span class="line">            mstore(ptr, <span class="number">0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000</span>)<span class="comment">//32 bytes</span></span><br><span class="line">            mstore(add(ptr, <span class="number">0x14</span>), shl(<span class="number">0x60</span>, _imlementation)) <span class="comment">//20bytes</span></span><br><span class="line">            mstore(add(ptr, <span class="number">0x28</span>), <span class="number">0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000</span>)<span class="comment">//32 bytes</span></span><br><span class="line">            instance := create(<span class="number">0</span>, ptr, <span class="number">0x37</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">require</span>(instance != address(<span class="number">0</span>),<span class="string">"ERC1167: create failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是用户需要调用的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_clone</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        address identicalChild = clone(implementation);</span><br><span class="line">        allClones[msg.sender].push(identicalChild);</span><br><span class="line">        <span class="comment">// 这将使 _clone() 函数的调用者成为克隆合约的所有者。</span></span><br><span class="line">        Implementation(identicalChild).initialize(msg.sender);</span><br><span class="line">        emit NewClone(identicalChild,msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">returnClones</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[] memory</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allClones[_owner];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>如果要从 Solidity 合约部署 EIP 1167 最小代理，可以使用 <code>OpenZeppelin</code> 合约中的<a href="https://docs.openzeppelin.com/contracts/api/proxy#Clones" target="_blank" rel="noopener"><code>克隆</code></a>库。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然通过<code>delegatecall</code>的方式将外部对代理合约的调用全部转接到远程合约上，省去了部署一次合约的开销，但是它存在以下问题：</p>
<ul>
<li>代理合约只拷贝了远程合约的runtime code，由于涉及初始化部分的代码在init code中，故代理合约无法拷贝远程合约的构造函数内的内容，需要一个额外的initialize 函数来初始化代理合约的状态值。</li>
<li><code>delegatecall</code>只能调用public 或者 external的方法，对于其internal 和 private 方法无法调用。所以代理合约相当于只拷贝了远程合约的公开的方法。</li>
</ul>
<p>您可能听说过<a href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7" target="_blank" rel="noopener">parity multisig wallet hack</a>。有多个代理（不是 EIP1167）引用相同的实现。但是，钱包具有自毁功能，可以清空合约的存储空间和代码。不幸的是，Parity 钱包的访问控制存在一个错误，有人意外获得了原始实现的所有权。那并没有直接从其他平价钱包中窃取资产，但随后黑客删除了原始实现，使所有剩余的钱包成为没有功能的外壳，并将资产永久锁定在其中。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/Multisig-Wallet/" data-toggle="tooltip" data-placement="top" title="由BT钱包引发的多签钱包思考">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/frontRunningBot/" data-toggle="tooltip" data-placement="top" title="抢跑机器人实现">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                
                <div class="comment_notes_blank"></div>
                <div class="visitor_notice">
                    <img 
                        src="/img/notice.png" 
                        alt="notice"
                        title="notice"/>
                    <p class="notice">
                        true
                    </p>
                </div>
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                
<link rel="stylesheet" href="../css/music-player/fonts/iconfont.css">


<link rel="stylesheet" href="../css/music-player/css/reset.css">


<link rel="stylesheet" href="../css/music-player/css/player.css">


<div class="music-player">
    <audio class="music-player__audio" ></audio>
    <div class="music-player__main">
        <div class="music-player__blur"></div>
        <div class="music-player__disc">
            <div class="music-player__image">
                <img width="100%" src="" alt="">
            </div>
            <div class="music-player__pointer"><img width="100%" src="/img/cd_tou.png" alt=""></div>
        </div>
        <div class="music-player__controls">
            <div class="music__info">
                <h3 class="music__info--title">...</h3>
                <p class="music__info--singer">...</p>
            </div>
            <div class="player-control">
                <div class="player-control__content">
                    <div class="player-control__btns">
                        <div class="player-control__btn player-control__btn--prev"><i class="iconfont icon-prev"></i></div>
                        <div class="player-control__btn player-control__btn--play"><i class="iconfont icon-play"></i></div>
                        <div class="player-control__btn player-control__btn--next"><i class="iconfont icon-next"></i></div>
                        <div class="player-control__btn player-control__btn--mode"><i class="iconfont icon-loop"></i></div>
                    </div>
                    <div class="player-control__volume">
                        <div class="control__volume--icon player-control__btn"><i class="iconfont icon-volume"></i></div>
                        <div class="control__volume--progress player_progress"></div>
                    </div>
                </div>
                <div class="player-control__content">
                    <div class="player__song--progress player_progress"></div>
                    <div class="player__song--timeProgess nowTime">00:00</div>
                    <div class="player__song--timeProgess totalTime">00:00</div>
                </div>
            </div>
        </div>
    </div>
</div>


<script src="../js/music-player/utill.js"></script>


<script src="../js/music-player/jquery.min.js"></script>

<!-- netease; qqkg -->
<!--
<script src="../js/music-player/player.js?library=config.music.library.js"></script>
-->
<script src="../../../../js/music-player/player.js?library=netease&music=https://kg.qq.com/node/play?s=7deFpz7Z26Jmv7di&g_f=share_html"></script>
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#深入可升级合约"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">深入可升级合约</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#引言"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">引言</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#简单的可升级合约"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">简单的可升级合约</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#简单实现"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">简单实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#代理合约"><span class="toc-nav-number">1.2.1.1.</span> <span class="toc-nav-text">代理合约</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#旧逻辑合约"><span class="toc-nav-number">1.2.1.2.</span> <span class="toc-nav-text">旧逻辑合约</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#新逻辑合约"><span class="toc-nav-number">1.2.1.3.</span> <span class="toc-nav-text">新逻辑合约</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#管理者"><span class="toc-nav-number">1.2.1.4.</span> <span class="toc-nav-text">管理者</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#问题"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#选择器碰撞"><span class="toc-nav-number">1.2.2.1.</span> <span class="toc-nav-text">选择器碰撞</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#存储冲突"><span class="toc-nav-number">1.2.2.2.</span> <span class="toc-nav-text">存储冲突</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#非结构化存储代理"><span class="toc-nav-number">1.2.2.2.1.</span> <span class="toc-nav-text">非结构化存储代理</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#实现版本之间的存储冲突"><span class="toc-nav-number">1.2.2.2.2.</span> <span class="toc-nav-text">实现版本之间的存储冲突</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#四种可升级模式"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">四种可升级模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#透明代理—Transparent"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">透明代理—Transparent</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#简单实现-1"><span class="toc-nav-number">1.3.1.1.</span> <span class="toc-nav-text">简单实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#代理合约-1"><span class="toc-nav-number">1.3.1.1.1.</span> <span class="toc-nav-text">代理合约</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#逻辑合约"><span class="toc-nav-number">1.3.1.1.2.</span> <span class="toc-nav-text">逻辑合约</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#管理者合约"><span class="toc-nav-number">1.3.1.1.3.</span> <span class="toc-nav-text">管理者合约</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#通用可升级代理—UUPS"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text">通用可升级代理—UUPS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#简单实现-2"><span class="toc-nav-number">1.3.2.1.</span> <span class="toc-nav-text">简单实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#代理合约-2"><span class="toc-nav-number">1.3.2.1.1.</span> <span class="toc-nav-text">代理合约</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#逻辑合约-1"><span class="toc-nav-number">1.3.2.1.2.</span> <span class="toc-nav-text">逻辑合约</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#oz库的完整实现"><span class="toc-nav-number">1.3.2.2.</span> <span class="toc-nav-text">oz库的完整实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#修饰符"><span class="toc-nav-number">1.3.2.2.1.</span> <span class="toc-nav-text">修饰符</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#函数"><span class="toc-nav-number">1.3.2.2.2.</span> <span class="toc-nav-text">函数</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#信标代理—Beacon"><span class="toc-nav-number">1.3.3.</span> <span class="toc-nav-text">信标代理—Beacon</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#简单实现-3"><span class="toc-nav-number">1.3.3.1.</span> <span class="toc-nav-text">简单实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#代理合约-3"><span class="toc-nav-number">1.3.3.1.1.</span> <span class="toc-nav-text">代理合约</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#信标合约"><span class="toc-nav-number">1.3.3.1.2.</span> <span class="toc-nav-text">信标合约</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#钻石代理—Diamond"><span class="toc-nav-number">1.3.4.</span> <span class="toc-nav-text">钻石代理—Diamond</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#概念"><span class="toc-nav-number">1.3.4.1.</span> <span class="toc-nav-text">概念</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#亮点"><span class="toc-nav-number">1.3.4.2.</span> <span class="toc-nav-text">亮点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#查找表"><span class="toc-nav-number">1.3.4.2.1.</span> <span class="toc-nav-text">查找表</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#钻石存储——任意的存储指针"><span class="toc-nav-number">1.3.4.2.2.</span> <span class="toc-nav-text">钻石存储——任意的存储指针</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#任意存储指针vs非结构化存储"><span class="toc-nav-number">1.3.4.2.3.</span> <span class="toc-nav-text">任意存储指针vs非结构化存储</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#放大镜（The-Loupe）"><span class="toc-nav-number">1.3.4.3.</span> <span class="toc-nav-text">放大镜（The Loupe）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#工作原理"><span class="toc-nav-number">1.3.4.4.</span> <span class="toc-nav-text">工作原理</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#最小代理"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">最小代理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#为什么是最小代理？"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">为什么是最小代理？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#要解决的问题"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">要解决的问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#原理"><span class="toc-nav-number">1.4.3.</span> <span class="toc-nav-text">原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#字节码分析"><span class="toc-nav-number">1.4.4.</span> <span class="toc-nav-text">字节码分析</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实现"><span class="toc-nav-number">1.4.5.</span> <span class="toc-nav-text">实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#逻辑合约-2"><span class="toc-nav-number">1.4.5.1.</span> <span class="toc-nav-text">逻辑合约</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#CloneFactory"><span class="toc-nav-number">1.4.5.2.</span> <span class="toc-nav-text">CloneFactory</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#部署"><span class="toc-nav-number">1.4.6.</span> <span class="toc-nav-text">部署</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#缺点"><span class="toc-nav-number">1.4.7.</span> <span class="toc-nav-text">缺点</span></a></li></ol></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#杂谈" title="杂谈">杂谈</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/ThomasXu-blockchain">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Thomas_Xu 2023 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="../js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="../js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="../js/hux-blog.min.js"></script>


<!-- Search -->

<script src="../js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://thomasxu-blockchain.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🍰&quot;,&quot;当大潮褪去，才知道谁在裸泳&quot;,&quot;🍭&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
